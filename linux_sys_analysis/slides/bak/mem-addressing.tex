% \documentclass[ignorenonframetext,10pt,xcolor=svgnames,hyperref={xetex,colorlinks,linkcolor=blue},compress]{beamer}

\usepackage{pgfpages}
\usepackage{dirtree}

\usepackage{latexsym,pifont,units,amsmath,amsfonts,amssymb,marvosym}
\usepackage{xltxtra} %fontspec,xunicode are loaded here.
\defaultfontfeatures{Mapping=tex-text}
\setsansfont{DejaVu Sans}
\setmainfont{DejaVu Serif}

\usepackage{xeCJK}
\setCJKmainfont[BoldFont={WenQuanYi Zen Hei}, ItalicFont={WenQuanYi Zen Hei}]{SimSun}
\setCJKfamilyfont{hei}{WenQuanYi Zen Hei}
\setCJKfamilyfont{song}{SimSun}

% \usepackage{graphicx} % beamer loads graphicx already.
\graphicspath{{./figs/}{../figs/}{./}{../}} %note that the trailing “/” is required

\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit}
\usepackage{tikz-qtree}

\usepackage{multicol,varwidth,soul}

\newcommand{\cfbox}[2]{%
  \colorlet{currentcolor}{.}%
  {\color{#1}\fbox{\color{currentcolor}#2}}%
}

\newcommand{\code}[1]{\texttt{\textcolor{violet}{#1}}}
\usepackage{minted}
%\newcommand{\code}[1]{\mint{c}|#1|}

\mode<beamer>{
  \usetheme{default}
  \usecolortheme{sidebartab}
  \usefonttheme{serif}
  \setbeamertemplate{footline}[frame number]
  \setbeamertemplate{navigation symbols}{}
  \usenavigationsymbolstemplate{}
  \setbeamertemplate{blocks}[rounded][shadow=true]
  \setbeamercolor{structure}{fg=Green}
  \setbeamercolor{block title}{fg=Green}
}

\begin{document}

\mode<article>{
  \title{Memory Addressing}
  \author{Wang Xiaolin\\wx672ster+os@gmail.com}
  \maketitle
  \tableofcontents
  \vspace{2em}
  \begin{description}
  \item[Textbook:] \
    \begin{itemize}
    \item \emph{Memory Addressing}, \cite[Chapter 2]{bovet2005understanding}
    \item \emph{Memory management in Linux}, \cite{abhishek2002memory}
    \item \emph{Understanding The Linux Virtual Memory Manager},
      \cite{gorman2004understanding}
    \item \emph{Memory Management}, \cite[Chapter 3]{mauerer2008professional}
    \item \emph{Virtual Process Memory}, \cite[Chapter 4]{mauerer2008professional}
    \item \emph{Memory Management}, \cite[Chapter 12]{love2010linux}
    \item \emph{The Process Address Space}, \cite[Chapter 15]{love2010linux}
    \end{itemize}
  \end{description}
  \printbibliography
  \clearpage
}

\begin{frame}<beamer>
  \title{Memory Addressing}
  \author{Wang Xiaolin}
  \titlepage
  \vfill
  \tiny{
    \ding{41} wx672ster+os@gmail.com\\
    % \ding{37} 13577067397
  }
\end{frame}

\section{Memory Addresses}
\label{sec:memory-addresses}

\begin{frame}{Three Kinds Of Addresses}
  \begin{center}
    \includegraphics[width=\textwidth]{addr-trans}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=\textwidth]{memTranslate}
  \end{center}
\end{frame}

Picture source: \url{http://ilinuxkernel.com/wp-content/uploads/2011/09/091011_1614_Linux1.png}

\begin{frame}{All CPUs Share The Same Memory}
  \begin{block}{Memory Arbiter}
    \begin{itemize}
    \item[if] the chip is free
    \item[then] grants access to a CPU
    \item[if] the chip is busy servicing a request by another processor
    \item[then] delay it
    \end{itemize}    
  \end{block}
  \textcolor{blue}{Even uniprocessor systems use memory arbiters because of \emph{DMA}.}
\end{frame}

\section{Segmentation in Hardware}
\label{sec:segm-hardw}

\begin{frame}{Real Mode Address Translation}
  \begin{itemize}
  \item Backward compatibility of the processors
  \item BIOS uses real mode addressing
  \item Use 2 16-bit registers to get a 20-bit address
  \end{itemize}

  \begin{block}{Logical address format}
    \begin{center}
      \texttt{<segment:offset>}
    \end{center}
  \end{block}

  \begin{block}{Real mode address translation}
    $$segment\ number\times{}2^4+offset$$
    \begin{itemize}
    \item[e.g.] to translate <\code{FFFF:0001}> into linear address:
      $$FFFF \times{} 16 + 0001 = FFFF0 + 0001 = FFFF1$$
    \end{itemize}
  \end{block}
\end{frame}

\begin{itemize}
\item \emph{16-bit CPU}, (\cite[Sec 2.4]{wangshuang03}).
\end{itemize}

\begin{frame}{Protected Mode Address Translation}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.8\textwidth]{osc-8-53}
    }
    \mode<article>{
      \includegraphics[width=.5\textwidth]{osc-8-53}
    }
  \end{center}
\end{frame}

\begin{frame}{Segment Selectors}
  \begin{block}{A logical address consists of two parts:}
    \begin{center}
      \begin{tabular}{ccc}
        segment selector&:&offset\\
        {\scriptsize 16 bits}&&{\scriptsize 32 bits}
      \end{tabular}
    \end{center}
  \end{block}
  \begin{description}
  \item[Segment selector] is an index into GDT/LDT
  \end{description}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.8\textwidth]{seg-selector}
    } \mode<article>{
      \includegraphics[width=.5\textwidth]{seg-selector}
    }
  \end{center}
\end{frame}

\begin{frame}{Segmentation Registers}
  \begin{block}{Segment registers hold segment selectors}
    \begin{description}
    \item[cs] code segment register
      \begin{itemize}
      \item[CPL] 2-bit, specifies the Current Privilege Level of the CPU
        \begin{itemize}
        \item[00] - Kernel mode
        \item[11] - User mode
        \end{itemize}
      \end{itemize}
    \item[ss] stack segment register
    \item[ds] data segment register
    \item[es/fs/gs] general purpose registers, may refer to arbitrary data segments
    \end{description}
  \end{block}
\end{frame}

More about privilege levels:
\begin{itemize}
\item \href{http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection}{CPU
    Rings, Privilege, and Proctection}
\item \emph{Segment-Level Protection}, \cite[Sec 6.3]{intel86}
\end{itemize}
\begin{center}
  \includegraphics[width=.6\textwidth]{segmentProtection}
\end{center}

\begin{frame}{Segment Descriptors}
    All the segments are organized in 2 tables:
    \begin{description}
    \item[GDT] \emph{Global Descriptor Table}
      \begin{itemize}
      \item shared by all processes
      \item GDTR stores address and size of the GDT
      \end{itemize}
    \item[LDT] \emph{Local Descriptor Table}
      \begin{itemize}
      \item one process each
      \item LDTR stores address and size of the LDT
      \end{itemize}
    \item[Segment descriptors] are entries in either GDT or LDT, 8-byte long
    \end{description}
      \begin{block}{Analogy}
        \begin{center}
          \begin{tabular}{rcl}
            Process&$\Longleftrightarrow$&Process Descriptor(PCB)\\
            File&$\Longleftrightarrow$&Inode\\
            Segment&$\Longleftrightarrow$&Segment Descriptor
          \end{tabular}
        \end{center}
      \end{block}
\end{frame}

More info:
\begin{itemize}
\item
  \href{http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation}{Memory
    Tanslation And Segmentation}
\item \url{http://www.osdever.net/bkerndev/Docs/gdt.htm}
\item
  \href{http://www.jamesmolloy.co.uk/tutorial_html/4.-The\%20GDT\%20and\%20IDT.html}{Sec 4
    of \emph{JamesM's kernel development tutorials}, The GDT and IDT}
\end{itemize}

\begin{frame}%{Segment Descriptors}
  \begin{block}{Example: A LDT entry for code segment}
    \includegraphics[width=\textwidth]{mos-figs-4-44}
  \end{block}
%  \begin{scriptsize}
    \small{\begin{multicols}{2}
      \begin{itemize}
      \item[Base:] Where the segment starts
      \item[Limit:] 20 bit, $\Rightarrow{}2^{20}$ in size
      \item[G:] Granularity flag
        \begin{itemize}
        \item[0] - segment size in bytes
        \item[1] - in 4096 bytes
        \end{itemize}
      \item[S:] System flag
        \begin{itemize}
        \item[0] - system segment, e.g. LDT
        \item[1] - normal code/data segment
        \end{itemize}\columnbreak
      \item[D/B:]
        \begin{itemize}
        \item[0] - 16-bit offset
        \item[1] - 32-bit offset
        \end{itemize}
      \item[Type:] segment type (cs/ds/tss)
        \begin{itemize}
        \item[TSS:] Task status, i.e. it's executing or not
        \end{itemize}
      \item[DPL:] Descriptor Privilege Level. 0 or 3
      \item[P:] Segment-Present flag
        \begin{itemize}
        \item[0] - not in memory
        \item[1] - in memory
        \end{itemize}
      \item[AVL:] ignored by Linux
      \end{itemize}
    \end{multicols}
}%  \end{scriptsize}
\end{frame}

\begin{itemize}
\item \emph{Segment-Level Protection}, \cite[Sec 6.3, p108]{intel86}
\end{itemize}
\begin{center}
  \includegraphics[width=\textwidth]{gdt-entry2}
\end{center}

\begin{frame}{Fast Access to Segment Descriptors}
  \begin{block}{a non-programmable cache register for each segment register}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.8\textwidth]{nonprogrammable}
      }
      \mode<article>{
        \includegraphics[width=.5\textwidth]{nonprogrammable}
      }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Translating a logical address}
  \mode<beamer>{
    \includegraphics[width=.7\textwidth]{logical2linear}
    \begin{tikzpicture}[remember picture, overlay]
      \node [scale=.9,text opacity=1,color=blue,xshift=8.5em,yshift=0em] at (current
      page.center) {1. $Index\times{}8+\text{table base}$};
      \node [scale=.9,text
      opacity=1,color=blue,xshift=9em,yshift=-2em] at (current page.center)
      {2. $\text{Descriptor base}+offset$};
    \end{tikzpicture}
  }
  \mode<article>{
    \begin{center}
      \includegraphics[width=.4\textwidth]{logical2linear}
    \end{center}
    \begin{enumerate}
    \item $Index\times{}8+table\ base$
    \item $Descriptor\ base+offset$
    \end{enumerate}
  }
\end{frame}

\section{Segmentation in Linux}
\label{sec:segmentation-linux}

\begin{frame}{Linux prefers paging to segmentation}
  \begin{block}{Because}
  \begin{itemize}
  \item Segmentation and paging are somewhat redundant
  \item Memory management is simpler when all processes share the same set of linear addresses
  \item Maximum portability. RISC architectures in particular have limited support for segmentation
  \end{itemize}
  \end{block}
  \textcolor{blue}{The Linux 2.6 uses segmentation only when required by the 80x86 architecture.}
\end{frame}

\begin{frame}{The Linux GDT Layout}
  \textcolor{blue}{Each GDT includes 18 segment descriptors and 14 null, unused, or
    reserved entries}
  \begin{block}{\code{include/asm-i386/segment.h}}
    \begin{scriptsize}
      \begin{multicols}{3}
        \begin{itemize}
        \item[0] null
        \item[1] reserved
        \item[2] reserved
        \item[3] reserved
        \item[4] unused
        \item[5] unused
        \item[6] TLS segment \#1
        \item[7] TLS segment \#2
        \item[8] TLS segment \#3
        \item[9] reserved
        \item[10] reserved
        \item[11] reserved
        \item[12] \textcolor{blue}{kernel code segment}
        \item[13] \textcolor{blue}{kernel data segment}
        \item[14] \textcolor{blue}{default user CS}
        \item[15] \textcolor{blue}{default user DS}
        \item[16] \textcolor{blue}{TSS}
        \item[17] \textcolor{blue}{LDT}
        \item[18] PNPBIOS support
        \item[19] PNPBIOS support
        \item[20] PNPBIOS support
        \item[21] PNPBIOS support
        \item[22] PNPBIOS support
        \item[23] APM BIOS support
        \item[24] APM BIOS support
        \item[25] APM BIOS support
        \item[26] ESPFIX small SS
        \item[27] per-cpu
        \item[28] stack\_canary-20
        \item[29] unused
        \item[30] unused
        \item[31] TSS for double fault handler
        \end{itemize}
      \end{multicols}
    \end{scriptsize}
  \end{block}
\end{frame}

\begin{itemize}
\item (\emph{Task State Segment}, \cite[Sec 3.3.2]{bovet2005understanding}) Although Linux
  doesn't use hardware context switches, it is nonetheless forced to set up a TSS for each
  distinct CPU in the system. This is done for two main reasons:
  \begin{itemize}
  \item When an 80x86 CPU switches from User Mode to Kernel Mode, it fetches the address
    of the Kernel Mode stack from the TSS (see the sections "Hardware Handling of
    Interrupts and Exceptions" in Chapter 4 and "Issuing a System Call via the sysenter
    Instruction" in Chapter
    10). (\href{https://en.wikipedia.org/wiki/Task_State_Segment#Inner-level_stack_pointers}{Wikipedia:
      Inner-level stack pointers})
  \item When a User Mode process attempts to access an I/O port by means of an in or out
    instruction, the CPU may need to access an I/O Permission Bitmap stored in the TSS to
    verify whether the process is allowed to address the
    port. (\href{https://en.wikipedia.org/wiki/Task_State_Segment#I.2FO_port_permissions}{Wikipedia:
      I/O port permissions})
  \end{itemize}
\item \href{https://en.wikipedia.org/wiki/Task_State_Segment}{Wikipedia: Task State
    Segment}
\item \href{https://en.wikipedia.org/wiki/Local_Descriptor_Table}{Wikipedia: Local
    Descriptor Table}
\item \emph{The Linux LDTs}, \cite[Sec 2.3.2]{bovet2005understanding}
\end{itemize}

\begin{frame}{The Four Main Linux Segments}
  \begin{block}{Every process in Linux has these 4 segments}
    \begin{center}
      \begin{scriptsize}
        \begin{tabular}{|l|l|l|l|l|l|l|l|l|}
          \hline
          \textbf{Segment}&\textbf{Base}&\textbf{G}&\textbf{Limit}&\textbf{S}&\textbf{Type}&\textbf{DPL}&\textbf{D/B}&\textbf{P}\\\hline
          user code&0x00000000&1&0xfffff&1&10&3&1&1\\\hline
          user data&0x00000000&1&0xfffff&1&2&3&1&1\\\hline
          kernel code&0x00000000&1&0xfffff&1&10&0&1&1\\\hline
          kernel data&0x00000000&1&0xfffff&1&2&0&1&1\\\hline
        \end{tabular}
      \end{scriptsize}
    \end{center}
  \end{block}
    \begin{block}{All linear addresses start at 0, end at 4G-1}
    \begin{itemize}
    \item All processes share the same set of linear addresses
    \item Logical addresses coincide with linear addresses
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Segment Selectors}
  \begin{block}{\code{include/asm-i386/segment.h}}
    \begin{center}
      \includegraphics[width=\textwidth]{segment}
    \end{center}
  \end{block}
  \begin{block}{$Selector = Index \ll 3 + G + RPL$}
    \begin{center}
      \begin{tabular}{lll}
        \code{\_\_USER\_CS}& $14 \ll 3 + 3 = 115$& 0000 0000 0111 0011\\
        \code{\_\_USER\_DS}& $15 \ll 3 + 3 = 123$& 0000 0000 0111 1011\\
        \code{\_\_KERNEL\_CS}&$12 \ll 3 + 0 = 96$& 0000 0000 0110 0000\\
        \code{\_\_KERNEL\_DS}&$13 \ll 3 + 0 = 104$& 0000 0000 0110 1000
      \end{tabular}
    \end{center}
  \end{block}
\end{frame}

\begin{itemize}
\item Values in segment registers:
\begin{verbatim}
|          Index          |G:RPL|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0 0 0 1 1 1 0|0|1 1| __USER_CS   (14 << 3 + 3)
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0 0 0 1 1 1 1|0|1 1| __USER_DS   (15 << 3 + 3)
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0 0 0 1 1 0 0|0|0 0| __KERNEL_CS (12 << 3 + 0)
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0 0 0 1 1 0 1|0|0 0| __KERNEL_DS (13 << 3 + 0)
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\item \emph{Segmentation in Linux}, \cite[Sec 2.3]{bovet2005understanding}
  \begin{quote}
    The corresponding Segment Selectors are defined by the macros \code{\_\_USER\_CS},
    \code{\_\_USER\_DS}, \code{\_\_KERNEL\_CS}, and \code{\_\_KERNEL\_DS},
    respectively. To address the kernel code segment, for instance, the kernel just loads
    the value yielded by the \code{\_\_KERNEL\_CS} macro into the \code{cs} segmentation
    register.

    Notice that the linear addresses associated with such segments all start at \code{0}
    and reach the addressing limit of $2^{32}-1$. This means that all processes, either in
    User Mode or in Kernel Mode, may use the same logical addresses.

    Another important consequence of having all segments start at \code{0x00000000} is
    that in Linux, logical addresses coincide with linear addresses; that is, the value of
    the Offset field of a logical address always coincides with the value of the
    corresponding linear address.

    As stated earlier, the Current Privilege Level of the CPU indicates whether the
    processor is in User or Kernel Mode and is specified by the RPL field of the Segment
    Selector stored in the \code{cs} register. \emph{Whenever the CPL is changed, some
      segmentation registers must be correspondingly updated.} For instance, when the CPL
    is equal to 3 (User Mode), the \code{ds} register must contain the Segment Selector of
    the user data segment, but when the CPL is equal to 0, the \code{ds} register must
    contain the Segment Selector of the kernel data segment.

    A similar situation occurs for the \code{ss} register. It must refer to a User Mode
    stack inside the user data segment when the CPL is 3, and it must refer to a Kernel
    Mode stack inside the kernel data segment when the CPL is 0. \emph{When switching from
      User Mode to Kernel Mode, Linux always makes sure that the \code{ss} register
      contains the Segment Selector of the kernel data segment}.

    When saving a pointer to an instruction or to a data structure, the kernel does not
    need to store the Segment Selector component of the logical address, because the
    \code{ss} register contains the current Segment Selector. As an example, when the
    kernel invokes a function, it executes a \code{call} assembly language instruction
    specifying just the Offset component of its logical address; the Segment Selector is
    implicitly selected as the one referred to by the \code{cs} register. Because there is
    just one segment of type "executable in Kernel Mode," namely the code segment
    identified by \code{\_\_KERNEL\_CS}, it is sufficient to load \code{\_\_KERNEL\_CS}
    into \code{cs} whenever the CPU switches to Kernel Mode. The same argument goes for
    pointers to kernel data structures (implicitly using the \code{ds} register), as well
    as for pointers to user data structures (the kernel explicitly uses the \code{es}
    register).
  \end{quote}
\end{itemize}

\begin{frame}
  \begin{block}{Example:}
    To address the kernel code segment, the kernel just loads the value yielded by the
    {\code{\_\_KERNEL\_CS}} macro into the {\code{cs}} segmentation register.
  \end{block}
  \begin{block}{Note that}
    \begin{enumerate}
    \item \code{base = 0}
    \item \code{limit = 0xfffff}
    \end{enumerate}
    This means that
    \begin{itemize}
    \item all processes, either in User Mode or in Kernel Mode, may use the same
      logical addresses
    \item logical addresses (Offset fields) coincide with linear addresses
    \end{itemize}
  \end{block}
\end{frame}
  
\begin{frame}{The Linux GDT}{ --- 8 byte segment descriptor}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{gdt-entry}
    } \mode<article>{
      \includegraphics[width=.7\textwidth]{gdt-entry}
    }
  \end{center}
  % \begin{block}{In \emph{include/asm-x86\_64/desc.h}}
  %   \includegraphics[width=\textwidth]{desc}
  % \end{block}
  \begin{block}{\code{arch/i386/kernel/head.S}}
    \begin{center}
      \includegraphics[width=\textwidth]{head3}
    \end{center}
  \end{block}
\end{frame}

\begin{itemize}
\item $0x60 = 12 \ll 3 + 0$
\item $0x68 = 13 \ll 3 + 0$
\item $0x73 = 14 \ll 3 + 3$
\item $0x7b = 15 \ll 3 + 3$
\end{itemize}

From the comments of
\href{http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation}{Memory
  Tanslation And Segmentation}:

\begin{itemize}
\item[Q:] I went to where the \code{gdt\_page} is instantiated
  (\href{http://lxr.linux.no/linux+v2.6.25.6/arch/x86/kernel/cpu/common.c#L24}{line 24,
    \code{common.c}, 2.6.25})

  It has the following code:

  \code{[GDT\_ENTRY\_DEFAULT\_USER\_CS] = { { { 0x0000ffff, 0x00cffa00 } } }}

  Do you know what that means?
\item[A:] This line is building the 8-byte segment descriptor for the user code
  segment. To really follow it, there are 3 things you must bear in mind:
  \begin{enumerate}
  \item The x86 is little endian, meaning that for multi-byte data types (say, 32-bit or
    64-bit integers), the significance of bytes grows with memory address. If you declare
    a 32-bit integer as \code{0xdeadbeef}, then it would be laid out in memory like this
    (in hex, assuming memory addresses are growing to the right):
\begin{verbatim}
ef be ad de
lower => higher
\end{verbatim}
  \item In array declarations, or in this case a struct declaration, earlier elements go
    into lower memory addresses.
  \item The convention for Intel diagrams is to draw things with HIGHER memory addresses
    on the LEFT and on TOP. This is a bit counter intuitive, but I followed it to be
    consistent with Intel docs.
  \end{enumerate}
  When you put this all together, the declaration above will translate into the following
  bytes in memory, using Intel’s ‘reversed’ notation:
\begin{verbatim}
(higher)
00 cf fa 00
00 00 ff ff
(lower)
\end{verbatim}
  If you compare these values against the segment descriptor diagram above, you’ll see
  that: the ‘base’ fields are all zero, so the segment starts at \code{0×00000000}, the
  limit is \code{0xfffff} so the limit covers 4GB, byte 47-40 is \code{11111010}, so the
  DPL is 3 for ring 3.

  If you look into the Intel docs, they describe the fields I left grayed out. Hope this
  helps!
\end{itemize}

\begin{frame}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{gdt}
    }
    \mode<article>{
      \includegraphics[width=.5\textwidth]{gdt}
    }
  \end{center}
  \mode<beamer>{
  \begin{tikzpicture}[remember picture, overlay]    
    \node [scale=.9,text opacity=1,color=blue,xshift=-10.15em,yshift=-11.5em]
    at (current page.center) {\textbf{cpu\_gdt\_table:} store all GDTs};
    \node [scale=.9,text opacity=1,color=blue,xshift=-3em,yshift=-13em]
    at (current page.center) {\textbf{cpu\_gdt\_descr:} store the addresses and sizes of the GDTs};
  \end{tikzpicture}}
\mode<article>{
  \begin{description}
    \item[cpu\_gdt\_table:] is an array of all GDTs
    \item[cpu\_gdt\_descr:] store the addresses and sizes of the GDTs
  \end{description}
}
\end{frame}

\section{Paging in Hardware}
\label{sec:paging-hardware}

\begin{frame}{Paging in Hardware}{ --- Starting with the 80386, all 80x86 processors support paging}
  \begin{block}{A page is}
    \begin{itemize}
    \item a set of linear addresses
    \item a block of data
    \end{itemize}
  \end{block}
  \begin{block}{A page frame is}
    \begin{itemize}
    \item a constituent of main memory
    \item a storage area
    \end{itemize}
  \end{block}
  \begin{block}{A page table}
    \begin{itemize}
    \item is a data structure
    \item maps linear to physical addresses
    \item stored in main memory
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Pentium Paging}{--- Linear Address $\Rightarrow$ Physical Address}
  \begin{varwidth}{.4\textwidth}
    \mbox{Two page size in Pentium:}
    \begin{small}
      \begin{itemize}
      \item[4K:] \mbox{2-level paging}% (Fig.~\ref{fig:2levelpaging})}
      \item[4M:] \mbox{1-level paging}% (Fig.~\ref{fig:paging})}
      \end{itemize}
    \end{small}
    \begin{center}
      \includegraphics[width=1.15\textwidth]{2-level-paging}
    \end{center}
  \end{varwidth}\qquad
  \begin{varwidth}{.5\textwidth}
    \includegraphics[width=1.2\textwidth]{osc-8-54}
  \end{varwidth}
\end{frame}

\begin{itemize}
\item The CR3 register points to the top level page table for the current process.
\end{itemize}

\begin{frame}%{ --- Intel i386}
  \begin{block}{Same structure for Page Dirs and Page Tables}
    \begin{itemize}
    \item 4 bytes (32 bits) long
    \item Page size is usually 4k ($2^{12}$ bytes). OS dependent
      \begin{itemize}
      \item[] $\sim$\$ \code{getconf PAGESIZE}
      \end{itemize}
    \item Could have $2^{32-12}=2^{20}=1M$ pages
      \begin{itemize}
      \item[] Could addressing $1M\times{}4KB=4GB$ memory
      \end{itemize}
    \end{itemize}
  \end{block}
  \begin{block}{Intel i386 page table entry}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.8\textwidth]{i386pte}
      } \mode<article>{
        \includegraphics[width=.6\textwidth]{i386pte}
      }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Physical Address Extension (PAE)}
  { --- 32-bit linear$\Rightarrow{}$36-bit physical}
  \begin{block}{Need a new paging mechanism}
    \begin{scriptsize}
      \begin{center}
        \begin{tabular}{r|llllll}
          &Linear&Physical&Max&Page&PTE&Paging\\
          &Address&Address&RAM&Size&Size&Level\\\hline
          No PAE&32 bits&32 bits&$2^{32}=4GB$&4K,4M&32 bits&1,2\\
          PAE&32 bits&36 bits&$2^{36}=64GB$&4K,2M&64 bits&2,3
        \end{tabular}
      \end{center}
    \end{scriptsize}
  \end{block}
  \vspace{1em}
  \begin{varwidth}{.49\textwidth}
    \begin{itemize}
    \item[PDPT] Page Directory Pointer Table, is a new level of Page Table
      \begin{itemize}
      \item[] $\texttt{64-bit entry}\times{}4$
      \end{itemize}
    \end{itemize}
  \end{varwidth}\hfill
  \begin{varwidth}{.49\textwidth}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=\textwidth]{pae}
      } \mode<article>{
        \includegraphics[width=\textwidth]{pae}
      }
    \end{center}
  \end{varwidth}
\end{frame}

\begin{frame}{PAE with 4K pages}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{x86-pae-4k}
    } \mode<article>{
      \includegraphics[width=.5\textwidth]{x86-pae-4k}
    }
  \end{center}
\end{frame}

\begin{frame}{PAE with 2M pages}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{x86-pae-2m}
    } \mode<article>{
      \includegraphics[width=.5\textwidth]{x86-pae-2m}
    }
  \end{center}
\end{frame}

\begin{frame}{Physical Address Extension (PAE)}
  \begin{block}{The linear address are still 32 bits}
    \begin{itemize}
    \item A process cannot use more than 4G RAM
    \item The kernel programmers have to reuse the same linear addresses to map 64GB RAM
    \item The number of processes is increased
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Translation Lookaside Buffers (TLB)}
    \begin{block}{Fact: 80-20 rule}
    \begin{itemize}
    \item Only a small fraction of the PTEs are heavily read; the rest are barely used at
      all
    \end{itemize}
  \end{block}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.75\textwidth]{osc-8-28}
    }
    \mode<article>{
      \includegraphics[width=.5\textwidth]{osc-8-28}
    }
  \end{center}
\end{frame}

\section{Paging in Linux}
\label{sec:paging-linux}

\begin{frame}{Paging In Linux}{ --- 4-level paging for both 32-bit and 64-bit}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{4-level-paging}
    }
    \mode<article>{
      \includegraphics[width=.5\textwidth]{4-level-paging}
    }
  \end{center}
  % \mode<beamer>{
  %   \begin{tikzpicture}[remember picture, overlay]    
  %     \node [scale=.7,xshift=-19.8em,yshift=-4em] (b) at (current page.center) {cr3};
  %     \draw [->,thick] (b) to[bend left] (.9,3.2);
  %   \end{tikzpicture}
  % }
  % \mode<article>{
  %   \textcolor{blue}{CR3} stores the starting address of PGDir for the current running
  %   process
  %   }
\end{frame}

\begin{frame}%{Paging In Linux}
  \begin{block}{4-level paging for both 32-bit and 64-bit}
    \begin{itemize}
    \item \textcolor{blue}{64-bit: four-level paging}
      \begin{enumerate}
      \item Page Global Directory
      \item Page Upper Directory
      \item Page Middle Directory
      \item Page Table
      \end{enumerate}
    \item \textcolor{blue}{32-bit: two-level paging}
      \begin{enumerate}
      \item Page Global Directory
      \item Page Upper Directory --- 0 bits; 1 entry
      \item Page Middle Directory --- 0 bits; 1 entry
      \item Page Table
      \end{enumerate}
    \end{itemize}
    \textcolor{blue}{The same code can work on 32-bit and 64-bit architectures}
  \end{block}
    \begin{center}
    \begin{scriptsize}
      \begin{tabular}{llllr}
        \hline
        &Page &Address&Paging&Address\\
        Arch&size &bits &levels&splitting\\\hline
        x86 &4KB(12bits) &32 &2 &$10+0+0+10+12$\\\hline
        x86-PAE&4KB(12bits)&32&3&$2+0+9+\hspace{.6em}9+12$\\\hline
        x86-64&4KB(12bits)&48&4&$9+9+9+\hspace{.6em}9+12$\\\hline    
      \end{tabular}
    \end{scriptsize}
  \end{center}
\end{frame}

(\emph{Paging In Linux}, \cite[Sec 2.5]{bovet2005understanding}) For 32-bit architectures
with no PAE, two paging levels are sufficient. Linux essentially eliminates the PUD and
the PMD fields by saying that they contain zero bits. However, \hl{the positions of the PUD
and the PMD in the sequence of pointers are kept so that the same code can work on 32-bit
and 64-bit architectures}.
\begin{description}
\item[Where are \emph{the sequence of pointers} kept?] The kernel keeps a position for the
  PUD and the PMD by setting the number of entries in them to 1 and mapping these two
  entries into the proper entry of the Page Global Directory.
\item[How can Linux use 4-level model, while Intel specifies 2-level paging? (32-bit
  no PAE)]
Quoted from \url{http://stackoverflow.com/questions/6627833/process-page-tables}:
\begin{quote}
  What I was trying to say was that the paging model used by the OS and the model used by
  the hardware are often distinct concepts. Linux uses a uniform paging model internally
  but this is layered on top of the hardware's paging model and requires architecture
  specific hacks to get it to work. It is the hardware's model that determines how address
  translation actually occurs (since it is the MMU that does this). \hl{\emph{Linux simply
    adds a layer of indirection on top. Deep in its bowels it still uses the 10:10:12
    model}}. --- \emph{Abhay Buch Jul 8 '11 at 22:58}
\end{quote}
\item[More about paging] Quoted from \url{http://linux-mm.org/VirtualMemory}:
\begin{quote}
  after bootup, all memory is accessed through the MMU which is paging enabled. So
  everything before and after \code{PAGE\_OFFSET} is paged. not everything can be demand
  paged, though ... (since kernel data structures are resident). pages below
  \code{ PAGE\_OFFSET} belong to user space, and can be demand paged. addresses above
  \code{PAGE\_OFFSET} are kernel memory. there is a linear mapping for the first 900 MB of
  kernel memory, where physical address 0 - 896 MB is mapped into \code{PAGE\_OFFSET} -
  \code{PAGE\_OFFSET}+896MB. so there are 896M/4K physical frames addressable from
  \code{PAGE\_OFFSET}->\code{PAGE\_OFFSET}+896MB.

  memory above \code{PAGE\_OFFSET} is kernel virtual memory. part of it is a direct map of
  the first part of physical memory. \emph{but that same physical memory could also get
    virtual mappings from elsewhere}, eg. userspace or vmalloc. also, userspace and
  vmalloc can map physical memory from outside the 896MB of direct mapped memory (as well
  as inside it).

  most kernel memory allocation needs to come from that 896 MB, indeed, though page tables
  are the big exception ;) which means they're resident in memory all the time. kernel
  data structures are always resident.

  process page tables could be either inside the low 896MB, or in highmem (or some page
  tables in both - more likely).

  physical memory is, by definition, not pageable. the contents of those pages might be
  pageable though. so you could have a page P at physical address 400MB. a process
  (eg. mozilla) is using that page at virtual address 120MB somewhere in its heap. the
  contents of the physical page can be paged out, at which point mozilla's heap page at
  120MB is paged out. but the kernel mapping (at \code{PAGE\_OFFSET} + 400MB) still maps
  the same page P just with different contents ;)
\end{quote}
\end{description}

\subsection{The Linear Address Fields}
\label{sec:paging-linux-1}
    
\begin{frame}{The Linear Address Fields}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=\textwidth]{shift}
      }
      \mode<article>{
        \includegraphics[width=.5\textwidth]{shift}
      }
    \end{center}
  \begin{description}
  \item[\code{*\_SHIFT}] to specify the number of bits being mapped
  \item[\code{*\_MASK}] to mask out all the upper bits
  \item[\code{*\_SIZE}] how many bytes are addressed by each entry
  \end{description}
  \code{*\_MASK} and \code{*\_SIZE} values are calculated based on \code{*\_SHIFT}
\end{frame}

\begin{description}
\item[\code{PAGE\_SHIFT}:] Specifies the size of the area that a \emph{page table entry} can
  cover
\item[\code{PMD\_SHIFT}:] Specifies the size of the area that a \emph{PMD entry} can cover
  \begin{itemize}
  \item When PAE is disabled, \code{PMD\_SHIFT} yields the value 22 (12 from Offset plus 10 from
    Table)
  \item when PAE is enabled, \code{PMD\_SHIFT} yields the value 21 (12 from Offset plus 9 from
    Table)
  \item \code{LARGE\_PAGE\_SIZE = PMD\_SIZE}
    \begin{itemize}
    \item $2^{22}$, without PAE
    \item $2^{21}$, with PAE
    \end{itemize}
%    \includegraphics[width=4cm]{pae}
  \end{itemize}
\item[\code{PUD\_SHIFT}:] Specifies the size of the area that a \emph{PUD entry} can cover
  \begin{itemize}
  \item On the 80x86 processors, \code{PUD\_SHIFT} is always equal to \code{PMD\_SHIFT}
    \begin{itemize}
    \item because both PUD and PMD are 0-bit long
    \end{itemize}
  \item \code{PUD\_SIZE} is equal to 4MB or 2MB.
  \end{itemize}
\item[\code{PGDIR\_SHIFT}:] Specifies the size of the area that a \emph{PGDIR entry} can cover
  \begin{itemize}
  \item When PAE is disabled, \code{PGDIR\_SHIFT = PUD\_SHIFT = PMD\_SHIFT = 22}
  \item when PAE is enabled, \code{PGDIR\_SHIFT} $= 9_{PMD} + 9_{PT} + 12_{Offset} = 30$
  \end{itemize}
\end{description}

\begin{frame}%{Paging In Linux}{ --- The Linear Address Fields}
  \begin{block}{\code{include/asm-i386/page.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=\textwidth]{page}
      } \mode<article>{
        \includegraphics[width=.5\textwidth]{page}
      }
    \end{center}
  \end{block}
  \begin{description}
  \item[\code{PAGE\_SIZE}:] $2^{12} = 4k$
  \item[\code{PAGE\_MASK}:] \code{0xfffff000}
  \item[\code{LARGE\_PAGE\_SIZE}:] depends
    \begin{itemize}
    \item[PAE:] $2^{21} = 2M$
    \item[no PAE:] $2^{22} = 4M$
    \end{itemize}
  \end{description}
\end{frame}

\begin{frame}{Compile Time Dual-mode}
  \begin{block}{\code{include/asm-i386/pgtable.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=\textwidth]{pgtable}
      }
      \mode<article>{
        \includegraphics[width=.7\textwidth]{pgtable}
      }
    \end{center}
  \end{block}
  \begin{center}
    \begin{small}
      \begin{tabular}{l|ccc}
        &\code{PMD\_SHIFT}&\code{PUD\_SHIFT}&\code{PGDIR\_SHIFT}\\\hline
        2-level&22&22&22\\
        3-level&21&21&30
      \end{tabular}
    \end{small}
  \end{center}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{pgdir-shift}
    }
    \mode<article>{
      \includegraphics[width=.7\textwidth]{pgdir-shift}
    }
  \end{center}
\end{frame}

\begin{frame}{2-level --- no PAE, 4K-page}
  \textcolor{blue}{PMD and PUD are folded}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.8\textwidth]{linear-addr-2level}
    }
    \mode<article>{
      \includegraphics[width=.5\textwidth]{linear-addr-2level}
    }
  \end{center}
  \begin{block}{\code{include/asm-generic/pgtable-nopud.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.7\textwidth]{pgtable-nopud}
      }
      \mode<article>{
        \includegraphics[width=.5\textwidth]{pgtable-nopud}
      }
    \end{center}
  \end{block}
  \begin{block}{\code{include/asm-generic/pgtable-nopmd.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.7\textwidth]{pgtable-nopmd}
      }
      \mode<article>{
        \includegraphics[width=.5\textwidth]{pgtable-nopmd}
      }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{3-level --- PAE enabled}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.7\textwidth]{pae2}
    }
    \mode<article>{
      \includegraphics[width=.3\textwidth]{pae2}
    }
  \end{center}
  \begin{block}{\code{include/asm-i386/pgtable-3level-defs.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.7\textwidth]{pgtable-3level-defs}
      }
      \mode<article>{
        \includegraphics[width=.4\textwidth]{pgtable-3level-defs}
      }
    \end{center}
    % On the 80x86 processors, $\texttt{PUD\_SHIFT}= \texttt{PMD\_SHIFT}$
    \textcolor{blue}{PUD} is eliminated
  \end{block}
\end{frame}

\begin{frame}{4-level --- x86\_64}
  \begin{block}{48 address bits}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.9\textwidth]{linear-addr-64}
      }
      \mode<article>{
        \includegraphics[width=.5\textwidth]{linear-addr-64}
      }
    \end{center}
  \end{block}
  \begin{block}{\code{include/asm-x86\_64/pgtable.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.7\textwidth]{pgtable-64}
      }
      \mode<article>{
        \includegraphics[width=.3\textwidth]{pgtable-64}
      }
    \end{center}
  \end{block}
\end{frame}

\subsection{Page Table Handling}
\label{sec:page-table-handling}

\begin{frame}{Page Table Handling}{ --- Data formats}
  \begin{block}{\code{include/asm-i386/page.h}}
    \includegraphics[width=\textwidth]{page2}
  \end{block}
  % Two reasons to use \emph{struct}:
  % \begin{enumerate}
  % \item type protection
  % \item portability. It works with PAE which uses 4 more bits
  % \end{enumerate}
\end{frame}

\begin{description}
\item[Why structs?] (\cite[p158]{mauerer2008professional}) \code{structs} are used
  instead of elementary types to ensure that the contents of page table elements are
  handled only by the associated helper functions and never directly.
  
  (\emph{Describing a Page Table Entry}, \cite[Sec 3.2]{gorman2004understanding}) Even
  though these are often just unsigned integers, they are defined as structs for two
  reasons. The first is for type protection so that they will not be used
  inappropriately. The second is for features like PAE...
\end{description}

\begin{itemize}
\item For 32-bit systems,
  \begin{itemize}
  \item long int: 4 bytes
  \item long long int: 8 bytes
  \end{itemize}
\item \code{pgprot\_t} holds the protection flags associated with a single entry.
  \begin{itemize}
  \item Present/RW/User/Accessed/Dirty...
  \end{itemize}
\item \code{\_\_pmd(x)}, type casting
\item \code{pmd\_val(x)}, reverse casting
\item \code{HPAGE\_SHIFT}, huge page shift.
  \begin{itemize}
  \item 22 - without PAE, page size is $2^{22}=4M$
  \item 21 - with PAE, page size is $2^{21}=2M$
  \end{itemize}
\end{itemize}

\begin{frame}{Page Table Handling}{ --- Read or modify page table
    entries}
  \begin{block}{Macros and functions}
    \begin{scriptsize}
      \begin{center}
        \begin{tabular}{llll}
          pte\_none&pte\_clear&set\_pte&pte\_same(a,b)\\
          pte\_present&pte\_user()&pte\_read()&pte\_write()\\
          pte\_exec()&pte\_dirty()&pte\_young()&pte\_file()\\
          mk\_pte\_huge()&pte\_wrprotect()&pte\_rdprotect()&pte\_exprotect()\\
          pte\_mkwrite()&pte\_mkread()&pte\_mkexec()&pte\_mkclean()\\
          pte\_mkdirty()&pte\_mkold()&pte\_mkyoung()&pte\_modify(p,v)\\
          mk\_pte(p,prot)&pte\_index(addr)&pte\_page(x)&pte\_to\_pgoff(pte)\\
        \end{tabular}
      \end{center}
    \end{scriptsize}
  \end{block}
  \textcolor{blue}{a lot more for pmd, pud, pgd ...}
\end{frame}

\begin{frame}{Example --- To find a page table entry}{\code{mm/memory.c}}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.8\textwidth]{follow-page}
    } \mode<article>{
      \includegraphics[width=.6\textwidth]{follow-page}
    }
  \end{center}
\end{frame}

\begin{description}
\item[\code{pgd\_offset(mm, addr)}] Receives as parameters the address of a memory
  descriptor \code{mm} (\emph{Process Address Space},
  \cite[Chapter 9]{bovet2005understanding}) and a linear address \code{addr}. The macro yields the
  linear address of the entry in a Page Global Directory that corresponds to the address
  \code{addr}; the Page Global Directory is found through a pointer within the memory
  descriptor.
  \begin{description}
  \item[Memory descriptor] (\emph{The Memory Descriptor},
    \cite[Sec 9.2]{bovet2005understanding}) All information related to the process address space is
    included in an object called the memory descriptor of type \code{mm\_struct}. This
    object is referenced by the \code{mm} field of the process descriptor.
  \end{description}

  Line \href{http://lxr.linux.no/linux+v2.6.11/include/asm-i386/pgtable.h#L312}{312} in
  \code{pgtable.h}:
  \begin{center}
    \includegraphics[width=.9\textwidth]{pgd-offset}
  \end{center}

  Line \href{http://lxr.linux.no/linux+v2.6.11/include/asm-i386/pgtable.h#L305}{305} in 
  \code{pgtable.h}:
  \begin{center}
    \includegraphics[width=.9\textwidth]{pgd-index}
  \end{center}

  \code{PTRS\_PER\_PGD} = $ \begin{cases}
    1024&\mathtt{i386, noPAE}\\
    4&\mathtt{i386, PAE}\\
    512&\mathtt{x86\_64}
  \end{cases}$

\item[\code{pud\_offset(pgd, addr)}] Receives as parameters a pointer \code{pgd} to a Page
  Global Directory entry and a linear address \code{addr}. The macro yields the linear
  address of the entry in a Page Upper Directory that corresponds to \code{addr}. In a
  two- or three-level paging system, this macro yields \code{pgd}, the address of a Page
  Global Directory entry.

  Line \href{http://lxr.linux.no/linux+v2.6.11/include/asm-generic/pgtable-nopud.h#L36}{36} in
  \code{pgtable-nopud.h}:
  \begin{center}
    \includegraphics[width=.9\textwidth]{pud-offset}
  \end{center}

\item[\code{pmd\_offset(pud, addr)}] Receives as parameters a pointer \code{pud} to a Page
  Upper Directory entry and a linear address \code{addr}. The macro yields the address of the
  entry in a Page Middle Directory that corresponds to \code{addr}. In a two-level paging system,
  it yields \code{pud}, the address of a Page Global Directory entry.

  Line \href{http://lxr.linux.no/linux+v2.6.11/include/asm-generic/pgtable-nopmd.h#L39}{39} in
  \code{pgtable-nopmd.h}:
  \begin{center}    
    \includegraphics[width=.9\textwidth]{pmd-offset}
  \end{center}


\item[\code{pte\_offset\_kernel(dir, addr)}] Yields the linear address of the Page Table
  that corresponds to the linear address \code{addr} mapped by the Page Middle Directory
  \code{dir}. Used only on the master kernel page tables (see the later section
  "\href{http://cs2.swfu.edu.cn/pub/resources/Books/Linux/kernel/OREILLY-Understanding_The_Linux_Kernel_3e/0596005652/understandlk-chp-2-sect-5.html#understandlk-chp-2-sect-5.5}{Kernel
    Page Tables}").

  Line \href{http://lxr.linux.no/linux+v2.6.11/include/asm-i386/pgtable.h#L335}{335} in
  \code{pgtable.h}:
  \begin{center}
    \includegraphics[width=.9\textwidth]{pte-offset}
  \end{center}

\item[\code{pte\_offset\_map(dir, addr)}] Receives as parameters a pointer \code{dir} to a
  Page Middle Directory entry and a linear address \code{addr}; it yields the linear
  address of the entry in the Page Table that corresponds to the linear address
  \code{addr}. If the Page Table is kept in high memory, the kernel establishes a
  temporary kernel mapping (see the section
  "\href{http://cs2.swfu.edu.cn/pub/resources/Books/Linux/kernel/OREILLY-Understanding_The_Linux_Kernel_3e/0596005652/understandlk-chp-8-sect-1.html#understandlk-chp-8-sect-1.6}{Kernel
    Mappings of High-Memory Page Frames}" in Chapter 8), to be released by means of
  \code{pte\_unmap}. The macros \code{pte\_offset\_map\_nested} and
  \code{pte\_unmap\_nested} are identical, but they use a different temporary kernel
  mapping.

  Line \href{http://lxr.linux.no/linux+v2.6.11/include/asm-i386/pgtable.h#L370}{370} in
  \code{pgtable.h}:
  \begin{center}
    \includegraphics[width=.9\textwidth]{pte-offset-map}
  \end{center}

\item[\code{pte\_none, pmd\_none, pud\_none, pgd\_none}] yield the value 1 if the
  corresponding entry has the value 0; otherwise, they yield the value 0.
\item[\code{pmd\_bad, pud\_bad, pgd\_bad}] The \code{pmd\_bad} macro is used by functions to
  check Page Middle Directory entries passed as input parameters. It yields the value 1 if
  the entry points to a bad Page Table that is, if at least one of the following
  conditions applies:
  \begin{itemize}
  \item The page is not in main memory (Present flag cleared).
  \item The page allows only Read access (Read/Write flag cleared).
  \item Either Accessed or Dirty is cleared (Linux always forces these flags to be set for
    every existing Page Table).
  \end{itemize}
  The \code{pud\_bad} and \code{pgd\_bad} macros always yield 0. No \code{pte\_bad} macro is
  defined, because it is legal for a Page Table entry to refer to a page that is not
  present in main memory, not writable, or not accessible at all.
\end{description}

\subsection{Physical Memory Layout}
\label{sec:phys-memory-layo}

\begin{frame}{Physical Memory Layout}
  \begin{description}
  \item[\code{0x00100000}]--- The kernel starting point
  \end{description}
  \begin{varwidth}{.49\textwidth}
    \begin{block}{Reserved page frames}
      \begin{itemize}
      \item unavailable to users
      \item kernel code and data structures
      \item no dynamic assignment, no swap out
      \end{itemize}
    \end{block}
    \textcolor{blue}{The kernel is loaded starting from the second megabyte ($0x00100000$)
      in RAM}
    \begin{itemize}
    \item Page frame 0 --- BIOS
    \item $640K\sim{}1M$ --- the well-know hole
    \item \code{/proc/iomem}
    \end{itemize}
  \end{varwidth}\hfill
  \begin{varwidth}{.49\textwidth}
    \includegraphics[width=\textwidth]{boot-mem}
  \end{varwidth}
\end{frame}

\textbf{Why isn't the kernel loaded starting with the first available megabyte of RAM?}
(\cite[Sec 2.5.3]{bovet2005understanding}) Well, the PC architecture has several
peculiarities that must be taken into account. For example:

\begin{itemize}
\item Page frame 0 is used by BIOS to store the system hardware configuration detected
  during the Power-On Self-Test(POST); the BIOS of many laptops, moreover, writes data on
  this page frame even after the system is initialized.
\item Physical addresses ranging from \code{0x000a0000} to \code{0x000fffff} are usually
  reserved to BIOS routines and to map the internal memory of ISA graphics cards. This
  area is the well-known hole from 640 KB to 1 MB in all IBM-compatible PCs: the physical
  addresses exist but they are reserved, and the corresponding page frames cannot be used
  by the operating system.
\item Additional page frames within the first megabyte may be reserved by specific computer
  models. For example, the IBM ThinkPad maps the 0xa0 page frame into the 0x9f one.
\end{itemize}

\begin{frame}%{Physical Memory Layout}
  \begin{block}{While booting}
    \begin{enumerate}
    \item The kernel queries the BIOS for available physical address ranges
    \item \code{machine\_specific\_memory\_setup()} --- builds the physical addresses map
    \item \code{setup\_memory()} --- initializes a few variables that describe the
      kernel's physical memory layout
      \begin{itemize}
      \item \code{min\_low\_pfn}, \code{max\_low\_pfn}, \code{highstart\_pfn},
        \code{highend\_pfn}, \code{max\_pfn}
      \end{itemize}
    \end{enumerate}
  \end{block}
\end{frame}

\textbf{Memory Initialization Steps (\cite[Sec 3.4]{mauerer2008professional})}

\begin{center}
  \begin{varwidth}{.9\textwidth}
    \dirtree{%
      .1 \code{setup\_arch}.
      .2 \code{machine\_specific\_memory\_setup}.
      .2 \code{parse\_early\_param}.
      .2 \code{setup\_memory}.
      .2 \code{paging\_init}.
      .3 \code{pagetable\_init}.
      .2 \code{zone\_sizes\_init}.
      .3 \code{add\_active\_range}.
      .3 \code{free\_area\_init\_nodes}.
    }    
  \end{varwidth}
\end{center}

\begin{itemize}
\item \code{setup\_arch} is invoked from within \code{start\_kernel()}
\item \code{machine\_specific\_memory\_setup}: to create a list with the memory regions occupied by
the system and the free memory regions
\item \code{parse\_early\_param}: parsing commandline arguments like \code{mem=XXX[KkmM]}, \code{highmem=XXX[kKmM]}, or \code{memmap=XXX[KkmM]""@XXX[KkmM]} arguments
\item \code{setup\_memory}
  \begin{itemize}
  \item The number of physical pages available (per node) is determined.
  \item The bootmem allocator is initialized (\cite[Sec 3.4.3]{mauerer2008professional})
  \item Various memory areas are then reserved, for instance, for the initial RAM disk needed when
   running the first userspace processes.
  \end{itemize}
\item \code{paging\_init}: initializes the kernel page tables and enables paging
\item \code{pagetable\_init}: initializes the direct mapping of physical memory into the
  kernel address space. All page frames in low memory are directly mapped to the virtual
  memory region above \code{PAGE\_OFFSET}. \textbf{This allows the kernel to address a
    good part of the available memory without having to deal with page tables anymore}.
\item \code{zone\_sizes\_init}: initializes the \code{pgdat\_t} instances of all nodes of
  the system
  \begin{enumerate}
  \item \code{add\_active\_range}: a comparatively simple list of the available physical
    memory is prepared
  \item \code{free\_area\_init\_nodes}: uses this information (got in above step) to
    prepare the full-blown kernel data structures
  \end{enumerate}
\end{itemize}

\begin{frame}{BIOS-Provided Physical Addresses Map}
  \begin{block}{Example --- a typical computer with 128MB RAM}
    \begin{small}
      \begin{center}
        \begin{tabular}{lll}
          Start&End&Type\\\hline
          \code{0x00000000}&\code{0x0009ffff} (640K)&Usable\\
          \code{0x000f0000} (960K)&\code{0x000fffff} (1M-1)&Reserved\\
          \code{0x00100000} (1M)&\code{0x07feffff}&Usable\\
          \code{0x07ff0000}&\code{0x07ff2fff}&ACPI data\\
          \code{0x07ff3000}&\code{0x07ffffff} (128M)&ACPI NVS\\
          \code{0xffff0000}&\code{0xffffffff}&Reserved
        \end{tabular}
      \end{center}
    \end{small}
  \end{block}
\end{frame}

\begin{itemize}
\item The \emph{ACPI data} area stores information about the hardware devices of the system
  written by the BIOS in the POST phase; during the initialization phase, the kernel
  copies such information in a suitable kernel data structure, and then considers these
  page frames usable.
\item The \emph{ACPI NVS} area is mapped to ROM chips of the hardware devices, and hence
  cannot be used.
\item The physical address range starting from \code{0xffff0000} is marked as reserved,
  because it is mapped by the hardware to the BIOS's ROM chip (see
  \href{http://cs2.swfu.edu.cn/pub/resources/Books/Linux/kernel/OREILLY-Understanding_The_Linux_Kernel_3e/0596005652/understandlk-app-a.html}{Appendix
    A}).
\item Notice that the BIOS may not provide information for some physical address ranges
  (in the table, the range is \code{0x000a0000} to \code{0x000effff}). To be on the safe
  side, Linux assumes that such ranges are not usable.
\item The kernel might not see all physical memory reported by the BIOS: for instance, the
  kernel can address only 4GB of RAM if it has not been compiled with PAE support, even
  if a larger amount of physical memory is actually available.
\item \href{http://kerneldiy.com/blog/?p=209}{kernlediy.com: Boot Memory Allocator}
\item \emph{Memory management during the boot process}, \cite[Sec 3.4.3]{mauerer2008professional}
\end{itemize}

\begin{frame}
  \begin{block}{Variables describing the physical memory layout}
    \begin{scriptsize}
      \begin{center}
        \begin{tabular}{lp{.7\textwidth}}\hline
          \textbf{Variable name}&\textbf{Description}\\\hline
          \code{num\_physpages}&Page frame number of the highest usable page frame\\\hline
          \code{totalram\_pages}&Total number of usable page frames\\\hline
          \code{min\_low\_pfn}&Page frame number of the first usable page frame after the kernel image in RAM\\\hline
          \code{max\_pfn}&Page frame number of the last usable page frame\\\hline
          \code{max\_low\_pfn}&Page frame number of the last page frame directly mapped by the kernel (low memory)\\\hline
          \code{totalhigh\_pages}&Total number of page frames not directly mapped by the kernel (high memory)\\\hline
          \code{highstart\_pfn}&Page frame number of the first page frame not directly mapped by the kernel\\\hline
          \code{highend\_pfn}&Page frame number of the last page frame not directly mapped by the kernel\\\hline
        \end{tabular}
      \end{center}
    \end{scriptsize}
  \end{block}
\end{frame}

\begin{frame}%{Physical Memory Layout}
  \begin{block}{The first 768 page frames (3 MB) in Linux 2.6}
    \begin{center}
      \includegraphics[width=\textwidth]{mem-layout}
    \end{center}
  \end{block}
\end{frame}

\begin{itemize}
\item You can find the linear address of these symbols (\code{\_text}, \code{\_etext},
  \code{\_edata}, \code{\_end}) in the file \code{System.map}, which is created right after
  the kernel is compiled.
\end{itemize}

\subsection{Process Page Tables}
\label{sec:process-page-tables}

\begin{frame}{Process Page Tables}
  \begin{description}
  \item[\code{0xC0000000}] $\Leftrightarrow$ \code{PAGE\_OFFSET}
  \end{description}

  \begin{block}{\code{include/asm-i386/page.h}}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=\textwidth]{page3}
      }
      \mode<article>{
        \includegraphics[width=.7\textwidth]{page3}
      }
    \end{center}
  \end{block}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.6\textwidth]{process-linear-addr}
    }
    \mode<article>{
      \includegraphics[width=.4\textwidth]{process-linear-addr}
    }
  \end{center}
  \begin{block}{Why?}
    \begin{itemize}
    \item easy to switch to kernel mode
    \item easy physical addressing due to direct mapping
      $$Physical = Virtual - \mathtt{PAGE\_OFFSET}$$
    \end{itemize}
  \end{block}
  % \begin{block}{include/asm-x86\_64/page.h}
  %   \includegraphics[width=\textwidth]{page4}
  % \end{block}
\end{frame}

\textbf{4G/4G solution}
\begin{itemize}
\item (\href{http://lwn.net/Articles/75174/}{LWN article}) There are users out there
  wanting to scale 32-bit Linux systems up to 32GB or more of main memory, so the
  enterprise-oriented Linux distributors have been scrambling to make that possible. One
  approach is the 4G/4G patch written by Ingo Molnar. This patch separates the kernel and
  user address spaces, allowing user processes to have 4GB of virtual memory while
  simultaneously expanding the kernel's low memory to 4GB. There is a cost, however:
  \emph{the translation buffer (TLB) is no longer shared and must be flushed for every
    transition between kernel and user space}. Estimates of the magnitude of the
  performance hit vary greatly, but numbers as high as 30\% have been thrown around. This
  option makes some systems work, however, so Red Hat ships a 4G/4G kernel with its
  enterprise offerings.

  Better solution: \textbf{go get a 64-bit system}.
\item (LWN article: \href{http://lwn.net/Articles/39283/}{4G/4G split on x86, 64 GB RAM
    (and more) support}) Performance impact of the 4G/4G feature:
  
  There's a runtime cost with the 4G/4G patch: to implement separate address spaces for
  the kernel and userspace VM, the entry/exit code has to switch between the kernel
  pagetables and the user pagetables. This causes TLB flushes, which are quite expensive,
  not so much in terms of TLB misses (which are quite fast on Intel CPUs if they come from
  caches), but in terms of the direct TLB flushing cost (\code{cr3} manipulation) done on
  system-entry. 
\item (\emph{Initialization of Paging}, \cite[Sec 3.4.2, p175]{mauerer2008professional})
  It would also be possible to get rid of the split completely by introducing two 4 GiB
  address spaces, one for the kernel and one for each userspace program. However, context
  switches between kernel and user mode are more costly in this case.
\end{itemize}

\textbf{Linux Memory Management Overview (a bit
  old)[\href{http://tldp.org/LDP/khg/HyperNews/get/memory/linuxmm.html}{tldp.org}]}
\begin{itemize}
\item A process' \code{PGDir} is initialized during a fork by
  \code{copy\_page\_tables()}. The idle process (\code{swapper}) has its \code{PGDir}
  initialized during the initialization sequence (\code{swapper\_pg\_dir}).
\item The kernel code and data segments are priveleged segments defined in the global
  descriptor table (GDT) and extend from 3 GB to 4 GB. The swapper page directory
  (\code{swapper\_pg\_dir}) is set up so that logical addresses and physical addresses are
  identical in kernel space.
\item Each user process has a local descriptor table (LDT) that contains a code segment and
  data-stack segment. These user segments extend from 0 to 3 GB (0xc0000000). In user
  space, linear addresses and logical addresses are identical.
\item The space above 3 GB appears in a process' \code{PGDir} as pointers (each entry in
  \code{PGDir} has a pointer) to kernel page tables. (\emph{The entries of the
    PGDir}, \cite[Sec 2.5.4]{bovet2005understanding})

  This space is invisible to the process in user mode but the mapping becomes relevant
  when privileged mode is entered, for example, to handle a system call. Supervisor mode
  is entered within the context of the current process so address translation occurs with
  respect to the process' \code{PGDir} but using kernel segments. This is identically
  the mapping produced by using the \code{swapper\_pg\_dir} and kernel segments as both page
  directories use the same page tables in this space. Only \code{task[0]} (the idle task,
  sometimes called the swapper task for historical reasons, even though it has nothing to
  do with swapping in the Linux implementation) uses the \code{swapper\_pg\_dir} directly.
  \begin{itemize}
  \item The user process' \code{segment\_base = 0x00}, \code{page\_dir} private to the
    process.
  \item user process makes a system call: \code{segment\_base=0xc0000000},
    \code{page\_dir = same user page\_dir}.
  \item \code{swapper\_pg\_dir} contains a mapping for all physical pages from
    \code{0xc0000000} to \code{0xc0000000 + end\_mem}, so the first 768 entries in
    \code{swapper\_pg\_dir} are 0's, and then there are 4 or more that point to kernel page
    tables.
  \item The user page directories have the same entries as \code{swapper\_pg\_dir} above
    768. The first 768 entries map the user space.
  \end{itemize}
\item The upshot is that whenever the linear address is above \code{0xc0000000} everything uses
  the same kernel page tables.
\item The user stack sits at the top of the user data segment and grows down. The kernel
  stack is not a pretty data structure or segment that I can point to with a ``yon lies
  the kernel stack.'' A \code{kernel\_stack\_frame} (a page) is associated with each newly
  created process and is used whenever the kernel operates within the context of that
  process. Bad things would happen if the kernel stack were to grow below its current
  stack frame.
\end{itemize}

\textbf{\emph{The entries of the PGDir}, \cite[Sec 2.5.4]{bovet2005understanding}}
\begin{itemize}
\item lower than \code{0xc0000000}: (the first 768 entries with PAE disabled, or the first 3
  entries with PAE enabled) depends on the specific process
  \begin{itemize}
  \item Each user process thinks it has 3 GiB of memory
  \end{itemize}
\item higher than \code{0xc0000000}: can be addressed only when the process is in kernel
  mode. This address space is common to all the processes and equal to the corresponding
  entries of the master kernel PGDir (see the following section)
% \item The content of the first entries of the \code{PGDir} that map linear addresses lower
%   than \code{0xc0000000} (the first 768 entries with PAE disabled, or the first 3 entries
%   with PAE enabled) depends on the specific process. Conversely,
% \item the remaining entries should be the same for all processes and equal to the
%   corresponding entries of the master kernel Page Global Directory (see the following
%   section).
\item For 32-bit systems without PAE, \code{PGDir}
\begin{itemize}
\item is 10-bit long 
\item has $2^{10}$ (1K) entries
\item each PGDIR entry covers $2^{22}$ (4M)
\item the first 768 entries cover $768\times{}2^{22}=3G$
\end{itemize}
\item For 32-bit systems with PAE enabled, \code{PGDir}
\begin{itemize}
\item is 2-bit long
\item has $2^2=4$ entries
\item each \code{PGDIR} entry covers $2^{30} = 1G$
\item the first 3 entries cover $3\times{}2^{30}=3G$
\end{itemize}
\item (\emph{Significance of \code{PAGE\_OFFSET}}, \cite[Sec 1.3.1]{abhishek2002memory})
  The address space after \code{PAGE\_OFFSET} is reserved for the kernel and this is where
  the complete physical memory is mapped (eg. if a system has 64mb of RAM, it is mapped
  from \code{PAGE\_OFFSET} to \code{PAGE\_OFFSET + 64mb}). This address space is also used
  to map non-continuous physical memory into continuous virtual memory.
\end{itemize}

\subsection{Kernel Page Tables}
\label{sec:kernel-page-tables}

\begin{frame}{Kernel Page Tables}{ --- Master Kernel Page Global Directory}
  \begin{varwidth}{.39\textwidth}
    \begin{block}{Master Kernel PGDir}
      \begin{itemize}
      \item has 1K 4-byte entries pointing to 1K page tables
      \item only 4 entries are used in initialization phase
      \item after initialization, it's used as a reference model for all processes
      \end{itemize}
    \end{block}
  \end{varwidth}\quad
  \begin{varwidth}{.5\textwidth}
    \begin{center}
      \includegraphics[width=1.3\textwidth]{kernel-page-table}
    \end{center}
  \end{varwidth}
\end{frame}

\begin{frame}{In The Beginning, There Is No Paging}
  \begin{block}{Before tuning on paging, the page tables must be ready}
    Two phases:
    \begin{enumerate}
    \item \textbf{Bootstrapping:} sets up page tables for just 8MB so the paging unit can
      be enabled
      \begin{description}
      \item[8MB?] 2 page tables (pg0, pg1), enough to handle the kernel's code and data
        segments, and 128 KB for some dynamic data structures (page frame bitmap)
      \end{description}
    \item \textbf{Finalising:} initializes the rest of the page tables
    \end{enumerate}
  \end{block}  
\end{frame}

\begin{frame}[squeeze]{Provisional Page Global Directory}
  \begin{itemize}
  \item \textcolor{blue}{A provisional PGDir} is initialized statically during kernel
    compilation
    \begin{center}
      \includegraphics[width=.5\textwidth]{head2}
    \end{center}
  \item \textcolor{blue}{The provisional PTs} are initialized by \code{startup\_32()} in
    \code{arch/i386/kernel/head.S}
  \item \code{swapper\_pg\_dir} --- A 4KB area for holding provisional PGDir
  \item provisional PGDir has only 4 useful entries: 0, 1, 0x300, 0x301
  \end{itemize}
  \begin{block}{What's it for?}
    \begin{center}
      \begin{tabular}{r|c|l}
        Linear&&Physical\\\hline
        $0\sim{}8MB$&$\Rightarrow$&$0\sim{}8MB$\\
        $\mathtt{PAGE\_OFFSET}\sim(\mathtt{PAGE\_OFFSET}+8MB)$&\rotatebox{30}{$\Rightarrow$}&
      \end{tabular}
    \end{center}
    \textcolor{blue}{so that the kernel image ($<8MB$) in physical memory can be addressed
      in both real mode and protected mode}
  \end{block}
\end{frame}

\begin{itemize}
\item \code{.fill 1024, 4, 0}\footnote{\code{.fill REPEAT, SIZE, VALUE}: This emits
    \code{REPEAT} copies of \code{SIZE} bytes.} initializes a 4K area for
  \code{swapper\_pg\_dir}.
\item \code{swapper\_pg\_dir} is at the beginning of BSS (uninitialized data area) because
  BSS is no longer used after system start up.
\item assuming that the kernel's segments, the provisional Page Tables, and the 128KB
  memory area fit in the first 8 MB of RAM.
\item In order to map 8 MB of RAM, two Page Tables are required
\item \code{pg0} is right after the end of BSS (\code{\_end})
\end{itemize}

We won't bother mentioning the Page Upper Directories and Page Middle Directories anymore,
because they are equated to Page Global Directory entries. PAE support is not enabled at
this stage.

The objective of this first phase of paging is \textcolor{blue}{to allow these 8 MB of
  physical RAM to be easily addressed both in real mode and protected mode}. Therefore,
the kernel must create a mapping from both the linear addresses \code{0x00000000} through
\code{0x007fffff} (8M) and the linear addresses \code{0xc0000000} through
\code{0xc07fffff} (8M) into the physical addresses \code{0x00000000} through
\code{0x007fffff}. In other words, the kernel during its first phase of initialization can
address the first 8 MB of RAM by either linear addresses identical to the physical ones or
8 MB worth of linear addresses, starting from \code{0xc0000000}.

\begin{description}
\item[Why?] (quoted from \cite[Sec 1.3.2]{abhishek2002memory})
  \begin{itemize}
  \item All pointers in the compiled kernel refer to addresses $> PAGE\_OFFSET$. That is,
    the kernel is linked under the assumption that its base address will be
    \code{start\_text} (I think; I don't have the code on hand at the moment), which is
    defined to be $PAGE\_OFFSET+(some\ small\ constant,\ call\ it\ C)$.
  \item All the kernel bootstrap code (mostly real mode code) is linked assuming that its
    base address is $0+C$.
  \end{itemize}

  \code{head.S} is part of the bootstrap code. It's running in protected mode with paging
  turned off, so all addresses are physical. In particular, the instruction pointer is
  fetching instructions based on physical address. The instruction that turns on paging
  (\code{movl \%eax, \%cr0}) is located, say, at some physical address $A$.

  As soon as we set the paging bit in \code{cr0}, paging is enabled, and starting at the very
  next instruction, all addressing, including instruction fetches, pass through the
  address translation mechanism (page tables). IOW, all address are henceforth
  virtual. That means that
  \begin{enumerate}
  \item We must have valid page tables, and
  \item Those tables must properly map the instruction pointer to the next instruction to
    be executed.
  \end{enumerate}
  That next instruction is physically located at address \code{A+4} (the address
  immediately after the "\code{movl \%eax, \%cr0}" instruction), but from the point of view
  of all the kernel code --- which has been linked at \code{PAGE\_OFFSET} --- that
  instruction is located at virtual address \code{PAGE\_OFFSET+(A+4)}. Turning on paging,
  however, does not magically change the value of EIP \footnote{The value of EIP is still
    physically $A+4$, not $PAGE\_OFFSET+(A+4)$ yet. But since paging is just enabled, CPU
    could pass $A+4$ through address translation.}.  The CPU fetches the next instruction
  from ***virtual*** address \code{A+4}; that instruction is the beginning of a short
  sequence that effectively relocates the instruction pointer to point to the code at
  \code{PAGE\_OFFSET+A+(something)}.

  But since the CPU is, for those few instructions, fetching instructions based on
  physical addresses ***but having those instructions pass through address translation***,
  we must ensure that both the physical addresses and the virtual addresses are :
  \begin{enumerate}
  \item Valid virtual addresses, and
  \item Point to the same code.
  \end{enumerate}
  That means that at the very least, the initial page tables must
  \begin{enumerate}
  \item map virtual address \code{PAGE\_OFFSET+(A+4)} to physical address \code{(A+4)},
    and must
  \item map virtual address \code{A+4} to physical address \code{A+4}.
  \end{enumerate}
  This dual mapping for the first 8MB of physical RAM is exactly what the initial page
  tables accomplish. The 8MB initally mapped is more or less arbitrary. It's certain that
  no bootable kernel will be greater than 8MB in size. The identity mapping is discarded
  when the MM system gets initialized.
\end{description}

\begin{frame}{Provisional Page Table Initialization}
  \begin{block}{\code{arch/i386/kernel/head.S}}
    \begin{center}
      \includegraphics[width=\textwidth]{head5}
    \end{center}
  \end{block}
\end{frame}

\begin{itemize}
\item The identity mapping is discarded when the MM system gets initialized.
\item \code{page\_pde\_offset = (\_\_PAGE\_OFFSET >> 20); /* 0xC00, the 3K point.*/}
  
  The \code{PGDir} is one page (4K) in size. It's divided into two parts:
  \begin{enumerate}
  \item first 3K (768 entries) for user mode
  \item last 1K (256 entries) for kernel mode
  \end{enumerate}
\item \code{\$(pg0 - \_\_PAGE\_OFFSET)} yields the physical address of \code{pg0} since here
  it is a linear address. Same case for \code{\$(swapper\_pg\_dir - \_\_PAGE\_OFFSET)}
\item Registers:
  \begin{description}
  \item[\code{\%edi}] address of each page table entry, i.e. \code{pg0[0]..pg0[1023]},
    \code{pg1[0]..pg1[1023]}.
  \item[\code{\%edx}] address of \code{swapper\_pg\_dir[0]}| and then to
    \code{swapper\_pg\_dir[1]}.
  \item[\code{\%ecx}] has two uses
    \begin{enumerate}
    \item contents of \code{swapper\_pg\_dir[0]}, \code{swapper\_pg\_dir[1]},
      \code{swapper\_pg\_dir[768]},\\ \code{swapper\_pg\_dir[769]}.
    \item loop counter (1024 -> 0)
    \end{enumerate}
  \item[\code{\%eax}] \code{7, 4k+7, 8k+7 ... 8M-4k+7} for 2k page table entries in
    \code{pg0} and \code{pg1} respectively.
  \item[\code{\%ebp}] \code{= 128k + 7 + \&pg0[1023]} in the first round of loop. Its
    value cannot be determined at coding time, because the address of \code{pg0} is
    not known until compile/link time.
  \end{description}
\item \code{stosl}: stores the contents of EAX at the address
  pointed by \code{EDI}, and increments \code{EDI}. Equivalent to: 
  \begin{enumerate}
  \item \code{movl \%eax, (\%edi)}
  \item \code{addl \$4, \%edi}
  \end{enumerate}
\item \code{cmpl, jb}: if \code{\%eax} < \code{\%ebp}, jump to 10;
  \begin{itemize}
  \item At the end of the 1\textsuperscript{st} round of loop, the value of \code{\%eax} is
    \code{4M-4k+7}, while the value of \code{\%ebp} depends on the address of \code{pg0}.
  \end{itemize}
\item \code{INIT\_MAP\_BEYOND\_END}: \code{128KB} (see \url{http://kerneldiy.com/blog/?p=201})
\end{itemize}

\begin{frame}
  \begin{block}{Equivalent pseudo C code}
    \begin{center}
      \includegraphics[width=\textwidth]{provisional-pgdir1}
    \end{center}
  \end{block}
\end{frame}

Source: \url{http://www.eefocus.com/article/09-04/71517s.html}

\begin{frame}{Enable paging}
  \code{startup\_32()} in \code{arch/i386/kernel/head.S}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{head6}
    }
    \mode<article>{
      \includegraphics[width=.7\textwidth]{head6}
    }
  \end{center}
\end{frame}

\begin{frame}{Final Kernel Page Table Setup}
  \begin{itemize}
  \item \code{master kernel PGDir} is still in \code{swapper\_pg\_dir}
  \item initialized by \code{paging\_init()}
  \end{itemize}
  
  \begin{block}{Situations}
    \begin{enumerate}
    \item \textcolor{blue}{$\mathtt{RAM\ size} < 896M$}
      \begin{itemize}
      \item every RAM cell is mapped
      \end{itemize}
    \item \textcolor{blue}{$896M < \mathtt{RAM\ size} < 4G$}
      \begin{itemize}
      \item 896M are mapped
      \end{itemize}
    \item \textcolor{blue}{$\mathtt{RAM\ size} > 4G$}
      \begin{itemize}
      \item PAE enabled
      \end{itemize}
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}{When RAM size is less than 896 MB}%{Final Kernel Page Table Setup}
  \begin{block}{\code{paging\_init()} without PAE}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.5\textwidth]{paging-init}
      } \mode<article>{
        \includegraphics[width=.3\textwidth]{paging-init}
      }
    \end{center}
  \end{block}
\end{frame}

\begin{description}
\item[Is PAE enabled in your kernel?] try \fbox{\code{grep PAE /boot/config-*}}
\end{description}

\begin{itemize}
\item \noindent\code{paging\_init()} without PAE:
  \begin{enumerate}
  \item Invokes \code{pagetable\_init()} to set up the Page Table entries properly.
  \item Writes the physical address of \code{swapper\_pg\_dir} in the cr3 control register.
  \item Invokes \code{\_\_flush\_tlb\_all()} to invalidate all TLB entries.
  \end{enumerate}
\end{itemize}

\begin{frame}
  \begin{description}
  \item[2 level paging:] \code{PUD} and \code{PMD} are folded
  \end{description}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.7\textwidth]{linear-addr-2level}
    } \mode<article>{
      \includegraphics[width=.5\textwidth]{linear-addr-2level}
    }
  \end{center}
  \begin{description}
  \item[\code{pagetable\_init()}] --- re-initializes the \code{PGDir} at
    \code{swapper\_pg\_dir}
  \item[Equivalent code:] 
  \end{description}  
  \begin{center}
    \includegraphics[width=\textwidth]{pagetable-init1}
  \end{center}
\end{frame}

\begin{itemize}
\item \emph{Final kernel Page Table when RAM size is less than 896 MB},
  \cite[Sec 2.5.5.2]{bovet2005understanding}
\item This loop begins setting up valid PMD entries to point to. In the PAE case, pages
  are allocated with \code{alloc\_bootmem\_low\_pages()} and the PGD is set
  appropriately. Without PAE, there is no middle directory, so it is just “folded” back
  onto the PGD to preserve the illustion of a 3-level pagetable.(\emph{Page Table
    Management}, \cite[Appendix C, p224]{gorman2004understanding})
\item \code{\#define pgd\_index(address) (((address) >> PGDIR\_SHIFT) \& (PTRS\_PER\_PGD-1))}
  \begin{itemize}
  \item \code{(PAGE\_OFFSET >> PGDIR\_SHIFT) \& (PTRS\_PER\_PGD-1)} $\Rightarrow{}$
  \item \code{(C0000000 >> 22) \& (1024 - 1) = 0x300 \& 1023 = 768}
  \end{itemize}
\item \code{pgd} is a pointer initialized to the \code{pgd\_t} corresponding to the
  beginning of the kernel portion of the linear address space. The lower 768 entries are
  left alone for user space.
\item \code{one\_md\_table\_init()} is described in the comments of the source code. And it's
  easy to trace the calls in it to get a clear idea.

  Line \href{http://lxr.linux.no/linux+v2.6.11/arch/i386/mm/init.c#L55}{55} in \code{mm/init.c}:
  \begin{center}
    \includegraphics[width=.8\textwidth]{one-md-table-init}
  \end{center}
\item \code{\#define set\_pmd(pmdptr, pmdval) (*(pmdptr) = (pmdval))}
\end{itemize}

\begin{frame}{When RAM Size Is Between 896MB $\sim$ 4096MB}
  \begin{description}
  \item[Physical memory zones:]
  \end{description}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.3\textwidth]{zones}
    } \mode<article>{
      \includegraphics[width=.3\textwidth]{zones}
    }
  \end{center}
  \begin{description}
  \item[Direct mapping for \code{ZONE\_NORMAL}:]
  \end{description}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{pa-va}
    } \mode<article>{
      \includegraphics[width=.7\textwidth]{pa-va}
    }
  \end{center}
\end{frame}

\begin{itemize}
\item To initialize the Page Global Directory, the kernel uses the same code as in the
  previous case.
\item The \code{\_\_pa} macro is used to convert a linear address starting from
  \code{PAGE\_OFFSET} to the corresponding physical address, while the \code{\_\_va} macro
  does the reverse.
\item \code{ZONE\_DMA} - Contains page frames of memory below 16 MB
\item \code{ZONE\_NORMAL} - Contains page frames of memory at and above 16 MB and below
  896 MB
\item \code{ZONE\_HIGHMEM} - Contains page frames of memory at and above 896 MB
\end{itemize}

\begin{frame}{High Memory}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=.9\textwidth]{highmem}
    }
    \mode<article>{
      \includegraphics[width=.5\textwidth]{highmem}
    }
  \end{center}
\end{frame}

\begin{itemize}
\item \href{http://linux-mm.org/HighMemory}{Coping with HighMemory}
  \begin{itemize}
  \item Memory above the physical address of 896MB are temporarily mapped into kernel
    virtual memory whenever the kernel needs to access that memory.
  \item Data which the kernel frequently needs to access is allocated in the lower 896MB
    of memory (\code{ZONE\_NORMAL}) and can be immediately accessed by the kernel (see
    Temporary mapping).
  \item Data which the kernel only needs to access occasionally, including page cache,
    process memory and page tables, are preferentially allocated from
    \code{ZONE\_HIGHMEM}.
  \item The system can have additional physical memory zones to deal with devices that can
    only perform DMA to a limited amount of physical memory, \code{ZONE\_DMA} and
    \code{ZONE\_DMA32}.
  \item Allocations and pageout pressure on the various memory zones need to be balanced
    (see Memory Balancing).
  \end{itemize}
\item (From comments in \href{High Memory In The Linux
    Kernel}{http://kerneltrap.org/node/2450}) \textbf{The whole 1\textsuperscript{st} GB
    of physical RAM is reserved for kernel use?} In fact, it is. The kernel has to have
  control over the whole memory. It's the kernel's job to allocate/deallocate RAM to
  processes.

  What the kernel does is, maps the entire available memory in its own space, so that it
  can access any memory region. It then gives out free pages to processes which need them.

  The userspace processes cannot of its own allocate a page to itself. It has to request
  the kernel to give it some memory area. Once the kernel has mapped a physical page in
  the process's space, it can use that extra memory.
\item (\emph{High Memory}, \cite[Sec 2.5]{gorman2004understanding}) To access physical
  memory between the range of 1GiB and 4GiB, the kernel temporarily maps pages from high
  memory into \code{ZONE\_NORMAL} with \code{kmap()}.

  \textbf{Why?} (\emph{Kernel Mappings of High-Memory Page Frames}, \cite[Sec
  8.1.6]{bovet2005understanding}) Page frames above the 896 MB boundary are not generally
  mapped in the 4\textsuperscript{th} GiB of the kernel linear address spaces, so the
  kernel is unable to directly access them. This implies that each page allocator function
  that returns the linear address of the assigned page frame doesn't work for high-memory
  page frames, that is, for page frames in the \code{ZONE\_HIGHMEM} memory zone.

  For instance, suppose that the kernel invoked
  \code{\_\_get\_free\_pages(GFP\_HIGHMEM,0)} to allocate a page frame in high memory. If
  the allocator assigned a page frame in high memory, \code{\_\_get\_free\_pages()} cannot
  return its linear address because it doesn't exist (there is no mapping between physical
  frame and virtual page); thus, the function returns NULL. In turn, the kernel cannot use
  the page frame; even worse, the page frame cannot be released because the kernel has
  lost track of it.

  Linux designers had to find some way to allow the kernel to exploit all the available
  RAM, up to the 64 GB supported by PAE. The approach adopted is the following:
  \begin{itemize}
  \item The allocation of high-memory page frames is done only through the
    \code{alloc\_pages()} function and its \code{alloc\_page()} shortcut. These functions
    do not return the linear address of the first allocated page frame, because if the
    page frame belongs to the high memory, such linear address simply does not
    exist. Instead, \emph{the functions return the linear address of the page descriptor
      of the first allocated page frame} (\emph{Page Descriptors},
    \cite[Sec~8.1.1]{bovet2005understanding}). These linear addresses always exist,
    because all page descriptors are allocated in low memory once and forever during the
    kernel initialization.
  \item Page frames in high memory that do not have a linear address cannot be accessed by
    the kernel. Therefore, part of the last 128 MB of the kernel linear address space is
    dedicated to mapping high-memory page frames. Of course, this kind of mapping is
    temporary, otherwise only 128 MB of high memory would be accessible. Instead, by
    recycling linear addresses the whole high memory can be accessed, although at
    different times.
  \end{itemize}
\item More about high memory:
  \begin{itemize}
  \item \emph{Page Table Setup}, \cite[Sec 1.8]{abhishek2002memory}
  \item
    \href{http://stackoverflow.com/questions/4528568/how-does-the-linux-kernel-manage-less-than-1gb-physical-memory}{Stackoverflow:
      How does the linux kernel manage less than 1GB physical memory?}
  \item \url{http://www.cs.usfca.edu/~cruse/cs635/lesson04.ppt}
  \item \url{http://ilinuxkernel.com/?p=1013}
  \end{itemize}
\end{itemize}

\begin{frame}{When RAM Size Is More Than 4096MB (PAE)}
  \begin{block}{A 3-level paging model is used}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=.7\textwidth]{pae2}
      }
      \mode<article>{
        \includegraphics[width=.5\textwidth]{pae2}
      }
    \end{center}
  \end{block}
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      PGDir&PUD&PMD&PT&OFFSET\\\hline
      2&0&9&9&12\\\hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \begin{block}{The PGDir is initialized by a cycle equivalent to the following:}
    \begin{center}
      \mode<beamer>{
        \includegraphics[width=\textwidth]{pgdir-init-pae1}
      }
      \mode<article>{
        \includegraphics[width=\textwidth]{pgdir-init-pae2}
      }
    \end{center}
  \end{block}
\end{frame}

\begin{itemize}
\item \emph{Final kernel Page Table when RAM size is more than 4096 MB},
  \cite[Sec 2.5.5.4]{bovet2005understanding}
\item this code can be used for both PAE and no-PAE situation. That's why the \code{for}
  loop
  \begin{center}
    \code{for (; i<PTRS\_PER\_PGD; ++i, ++pgd)}
  \end{center}
  is used when \code{i=3, PTRS\_PER\_PGD=4}.
\item \code{pgd\_index(address)} returns the index of a PGDir entry
  \begin{center}
    \code{\#define pgd\_index(address) (((address) >> PGDIR\_SHIFT) \& (PTRS\_PER\_PGD-1))}
  \end{center}
  \begin{itemize}
  \item[$\Rightarrow$] \code{(C0000000 >> 30) \& (4 - 1)} = 3
  \end{itemize}
  When PAE is enabled, there are 4 entries in \code{PGDir}. The first 3 entries are for
  user linear address space. The 4\textsuperscript{th} entry is for kernel space.
\item \code{\#define set\_pgd(pgdptr, pgdval) set\_pud((pud\_t *)(pgdptr), (pud\_t) { pgdval })}
  puds are folded into pgds so this doesn't get actually called, but the define is needed
  for a generic inline function.
  \begin{center}
    \code{set\_pgd(swapper\_pg\_dir + i, \_\_pgd(\_\_pa(empty\_zero\_page) + 0x001));}
  \end{center}
  The kernel initializes the first three entries in the \code{PGDir} corresponding to the
  user linear address space with the address of an empty page (\code{empty\_zero\_page}).

  Line \href{http://lxr.linux.no/linux+v2.6.11/arch/i386/kernel/head.S#L417}{417} in
  \code{arch/i386/kernel/head.S}:
  \begin{center}
    \includegraphics[width=.3\textwidth]{empty-zero-page}
  \end{center}
\item The 4\textsuperscript{th} entry is initialized with the address of a \code{pmd}
  allocated by invoking \code{alloc\_bootmem\allowbreak\_low\_pages()}. There are 512
  entries in a \code{pmd},
  \begin{itemize}
  \item the first 448 entries are filled with the physical address of the first 896MB
    of RAM.
  \item the last 64 entries are reserved for noncontiguous memory allocation (
    \emph{Noncontiguous Memory Area Management}, \cite[Sec 8.3]{bovet2005understanding})
  \end{itemize}
\end{itemize}

\subsection{Fix-Mapped Linear Addresses}
\label{sec:fix-mapped-linear}

\begin{frame}{Division Of The Kernel Address Space}{ --- On IA-32 Systems}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{kernel-addr-space}
    }
    \mode<article>{
      \includegraphics[width=.7\textwidth]{kernel-addr-space}
    }
  \end{center}
  \begin{itemize}
  \item Virtually contiguous memory areas that are \emph{not} contiguous in physical
    memory can be reserved in the vmalloc area.
  \item \emph{Persistent mappings} are used for persistent kernel mapping of highmem page frames.
  \item \emph{Fixmaps} are virtual address space entries associated with a fixed but
    freely selectable page in physical address space.
  \end{itemize}
\end{frame}

\begin{itemize}
\item \emph{Architecture-Specific Setup}, \cite[Sec 3.4.2]{mauerer2008professional}
  \begin{description}
  \item[\texttt{VMALLOC\_OFFSET}] 8MB. (p178) This gap acts as a safeguard against any
    kernel faults. If out of bound addresses are accessed (these are unintentional
    accesses to memory areas that are no longer physically present), access fails and an
    exception is generated to report the error. If the vmalloc area were to immediately
    follow the direct mappings, access would be successful and the error would not be
    noticed. There should be no need for this additional safeguard in stable operation,
    but it is useful when developing new kernel features that are not yet mature.
  \item[Fixmaps] (p180) The advantage of fixmap addresses is that at compilation time, the
    address acts like a constant whose physical address is assigned when the kernel is
    booted. Addresses of this kind can be de-referenced faster than when normal pointers
    are used. The kernel also ensures that the page table entries of fixmaps are not
    flushed from the TLB during a context switch so that access is always made via fast
    cache memory.
  \end{description}
\item \emph{Fixmaps}, \cite[Sec 1.8.3]{abhishek2002memory}
\end{itemize}

% \subsection{Handling the Hardware Cache and the TLB}
% \label{sec:handl-hardw-cache}

\begin{center}
  \includegraphics[width=1.5\textwidth,angle=270]{big-pic}
\end{center}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "mem-addressing-a"
%%% End: 
