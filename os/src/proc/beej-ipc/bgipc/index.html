<!-- HTML generated by Beej's bgconv Python script -->

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Beej's Guide to Unix IPC</title>
<link rel="stylesheet" href="bgipc.css" type="text/css">
</head>

<body bgcolor="#ffffff">



<h1 class="guidetitle">Beej's Guide to Unix IPC</h1>



    <p/><b class="guidetitleauthor">Brian "Beej Jorgensen" Hall</b><br/>

    <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>




<p/><span class="guideversion">Version 1.1.2</span><br/>

<span class="guidedate">December 15, 2010</span><br/>


<p><small class="guidecopyright">Copyright &#xA9; 2010  Brian "Beej Jorgensen" Hall</small></p>


    

    

<hr class="mainsectbreak"/>
<h2 class="sect1title">Contents</h2><hr class="mainsecthr"/>
<dl>
<dt>1. <a href="#intro">Intro</a></dt>
<dd>1.1. <a href="#audience">Audience</a></dd>
<dd>1.2. <a href="#platform">Platform and Compiler</a></dd>
<dd>1.3. <a href="#homepage">Official Homepage</a></dd>
<dd>1.4. <a href="#emailpolicy">Email Policy</a></dd>
<dd>1.5. <a href="#mirroring">Mirroring</a></dd>
<dd>1.6. <a href="#xlate">Note for Translators</a></dd>
<dd>1.7. <a href="#copyright">Copyright and Distribution</a></dd>
<p><dt>2. <a href="#fork">A <b><tt class="func">fork()</tt></b> Primer</a></dt>
<dd>2.1. <a href="#forkperil">"Seek ye the Gorge of Eternal Peril"</a></dd>
<dd>2.2. <a href="#forkbutton">"I'm mentally prepared!  Give me <i>The Button</i>!"</a></dd>
<dd>2.3. <a href="#forksum">Summary</a></dd>
<p><dt>3. <a href="#signals">Signals</a></dt>
<dd>3.1. <a href="#catchsig">Catching Signals for Fun and Profit!</a></dd>
<dd>3.2. <a href="#handlerok">The Handler is not Omnipotent</a></dd>
<dd>3.3. <a href="#signalwrong">What about <b><tt class="func">signal()</tt></b></a></dd>
<dd>3.4. <a href="#signalpop">Some signals to make you popular</a></dd>
<dd>3.5. <a href="#siggloss">What I have Glossed Over</a></dd>
<p><dt>4. <a href="#pipes">Pipes</a></dt>
<dd>4.1. <a href="#pipesclean">"These pipes are clean!"</a></dd>
<dd>4.2. <a href="#pipefork"><b><tt class="func">fork()</tt></b> and <b><tt class="func">pipe()</tt></b>—you have the
power!</a></dd>
<dd>4.3. <a href="#pipequest">The search for Pipe as we know it</a></dd>
<dd>4.4. <a href="#pipesum">Summary</a></dd>
<p><dt>5. <a href="#fifos">FIFOs</a></dt>
<dd>5.1. <a href="#fifonew">A New FIFO is Born</a></dd>
<dd>5.2. <a href="#fifopc">Producers and Consumers</a></dd>
<dd>5.3. <a href="#fifondelay"><tt class="const">O_NDELAY</tt>!  I'm UNSTOPPABLE!</a></dd>
<dd>5.4. <a href="#fifoconc">Concluding Notes</a></dd>
<p><dt>6. <a href="#flocking">File Locking</a></dt>
<dd>6.1. <a href="#flockset">Setting a lock</a></dd>
<dd>6.2. <a href="#flockclear">Clearing a lock</a></dd>
<dd>6.3. <a href="#flockdemo">A demo program</a></dd>
<dd>6.4. <a href="#flocksum">Summary</a></dd>
<p><dt>7. <a href="#mq">Message Queues</a></dt>
<dd>7.1. <a href="#mqwhere">Where's my queue?</a></dd>
<dd>7.2. <a href="#mqftok">"Are you the Key Master?"</a></dd>
<dd>7.3. <a href="#mqsend">Sending to the queue</a></dd>
<dd>7.4. <a href="#mqrece">Receiving from the queue</a></dd>
<dd>7.5. <a href="#mqdest">Destroying a message queue</a></dd>
<dd>7.6. <a href="#mqsamp">Sample programs, anyone?</a></dd>
<dd>7.7. <a href="#mqsum">Summary</a></dd>
<p><dt>8. <a href="#semaphores">Semaphores</a></dt>
<dd>8.1. <a href="#semgrab">Grabbing some semaphores</a></dd>
<dd>8.2. <a href="#semctl">Controlling your semaphores with <b><tt class="func">semctl()</tt></b></a></dd>
<dd>8.3. <a href="#semop"><tt class="tt">semop()</tt>: Atomic power!</a></dd>
<dd>8.4. <a href="#semdest">Destroying a semaphore</a></dd>
<dd>8.5. <a href="#semsamp">Sample programs</a></dd>
<dd>8.6. <a href="#semsum">Summary</a></dd>
<p><dt>9. <a href="#shm">Shared Memory Segments</a></dt>
<dd>9.1. <a href="#shmcreat">Creating the segment and connecting</a></dd>
<dd>9.2. <a href="#shmat">Attach me—getting a pointer to the segment</a></dd>
<dd>9.3. <a href="#shmrw">Reading and Writing</a></dd>
<dd>9.4. <a href="#shmdet">Detaching from and deleting segments</a></dd>
<dd>9.5. <a href="#shmcon">Concurrency</a></dd>
<dd>9.6. <a href="#shmsam">Sample code</a></dd>
<p><dt>10. <a href="#mmap">Memory Mapped Files</a></dt>
<dd>10.1. <a href="#mmmaker">Mapmaker</a></dd>
<dd>10.2. <a href="#mmunmap">Unmapping the file</a></dd>
<dd>10.3. <a href="#mmconcur">Concurrency, again?!</a></dd>
<dd>10.4. <a href="#mmsamp">A simple sample</a></dd>
<dd>10.5. <a href="#mmsum">Summary</a></dd>
<p><dt>11. <a href="#unixsock">Unix Sockets</a></dt>
<dd>11.1. <a href="#unixsockover">Overview</a></dd>
<dd>11.2. <a href="#unixsockserv">What to do to be a Server</a></dd>
<dd>11.3. <a href="#sockclient">What to do to be a client</a></dd>
<dd>11.4. <a href="#socketpair"><tt class="tt">socketpair()</tt>—quick full-duplex pipes</a></dd>
<p><dt>12. <a href="#references">More IPC Resources</a></dt>
<dd>12.1. <a href="#refbooks">Books</a></dd>
<dd>12.2. <a href="#onlineref">Other online documentation</a></dd>
<dd>12.3. <a href="#manpages">Linux man pages</a></dd>
<p></dl><p>










<hr class="mainsectbreak"/><h2 class="sect1title">1. <a name="intro">Intro</a></h2><hr class="mainsecthr"/>


<p>You know what's easy?  <b><tt class="func">fork()</tt></b> is easy.  You can fork off
new processes all day and have them deal with individual chunks of a
problem in parallel.  Of course, its easiest if the processes don't have
to communicate with one another while they're running and can just sit
there doing their own thing.</p>

<p>However, when you start <b><tt class="func">fork()</tt></b>'ing processes, you
immediately start to think of the neat multi-user things you could do if
the processes could talk to each other easily.  So you try making a
global array and then <b><tt class="func">fork()</tt></b>'ing to see if it is shared.
(That is, see if both the child and parent process use the same array.)
Soon, of course, you find that the child process has its own copy of the
array and the parent is oblivious to whatever changes the child makes to
it.</p>

<p>How do you get these guys to talk to one another, share data
structures, and be generally amicable?  This document discusses several
methods of <i>Interprocess Communication</i> (IPC) that can
accomplish this, some of which are better suited to certain tasks than
others.</p>






<h3 class="sect2title">1.1. <a name="audience">Audience</a></h3>


<p>If you know C or C++ and are pretty good using a Unix environment (or
other POSIXey environment that supports these system calls) these
documents are for you.  If you aren't that good, well, don't sweat
it—you'll be able to figure it out.  I make the assumption,
however, that you have a fair smattering of C programming
experience.</p>

<p>As with <a href="http://beej.us/guide/bgnet/" target="_blank">Beej's Guide to Network Programming
Using Internet Sockets</a>, these documents are meant to springboard
the aforementioned user into the realm of IPC by delivering a concise
overview of various IPC techniques.  This is not the definitive set of
documents that cover this subject, by any means.  Like I said, it is
designed to simply give you a foothold in this, the exciting world of
IPC.</p>








<h3 class="sect2title">1.2. <a name="platform">Platform and Compiler</a></h3>


<p>The examples in this document were compiled under Linux using
<b class="com">gcc</b>.  They should compile anywhere a good Unix compiler is
available.</p>








<h3 class="sect2title">1.3. <a name="homepage">Official Homepage</a></h3>


<p>This official location of this document is
<tt class="tt"><a href="http://beej.us/guide/bgipc/" target="_blank">http://beej.us/guide/bgipc/</a></tt>.</p>








<h3 class="sect2title">1.4. <a name="emailpolicy">Email Policy</a></h3>


<p>I'm generally available to help out with email questions so feel free to write in, but I can't guarantee a
response.  I lead a pretty busy life and there are times when I just
can't answer a question you have.  When that's the case, I usually just
delete the message.  It's nothing personal; I just won't ever have the
time to give the detailed answer you require.</p>

<p>As a rule, the more complex the question, the less likely I am to
respond.  If you can narrow down your question before mailing it and be
sure to include any pertinent information (like platform, compiler,
error messages you're getting, and anything else you think might help me
troubleshoot), you're much more likely to get a response.  For more
pointers, read ESR's document, <a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank">How To Ask
Questions The Smart Way</a>.</p>

<p>If you don't get a response, hack on it some more, try to find the
answer, and if it's still elusive, then write me again with the
information you've found and hopefully it will be enough for me to help
out.</p>

<p>Now that I've badgered you about how to write and not write me, I'd
just like to let you know that I <i>fully</i> appreciate all the
praise the guide has received over the years.  It's a real morale boost,
and it gladdens me to hear that it is being used for good! <tt>:-)</tt>
Thank you!</p>









<h3 class="sect2title">1.5. <a name="mirroring">Mirroring</a></h3>


<p>You are more than welcome to mirror this site,
whether publicly or
privately.  If you publicly mirror the site and want me to link to it
from the main page, drop me a line at <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>.</p>









<h3 class="sect2title">1.6. <a name="xlate">Note for Translators</a></h3>


<p>If you want to translate the guide into
another language, write me at <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt> and I'll link to
your translation from the main page. Feel free to add your name and
contact info to the translation.</p>

<p>Please note the license restrictions in the Copyright and
Distribution section, below.</p>

<p>Sorry, but due to space constraints, I cannot host the
translations myself.</p>








<h3 class="sect2title">1.7. <a name="copyright">Copyright and Distribution</a></h3>


<p>Beej's Guide to Network Programming is Copyright &#xA9; 2010
Brian "Beej Jorgensen" Hall.</p>

<p>With specific exceptions for source code and translations, below,
this work is licensed under the Creative Commons Attribution-
Noncommercial- No Derivative Works 3.0 License. To view a copy of this
license, visit <tt class="tt"><a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">http://creativecommons.org/licenses/by-nc-nd/3.0/</a></tt> or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105,
USA.</p>

<p>One specific exception to the "No Derivative Works" portion of the
license is as follows: this guide may be freely translated into any
language, provided the translation is accurate, and the guide is
reprinted in its entirety.  The same license restrictions apply to the
translation as to the original guide.  The translation may also include
the name and contact information for the translator.</p>

<p>The C source code presented in this document is hereby granted to the
public domain, and is completely free of any license restriction.</p>

<p>Educators are freely encouraged to recommend or supply copies of this
guide to their students.</p>

<p>Contact <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt> for more information.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">2. <a name="fork">A <b><tt class="titlefunc">fork()</tt></b> Primer</a></h2><hr class="mainsecthr"/>


<p>"Fork", aside from being one of those words that begins to appear
very strange after you've typed it repeatedly, refers to the way Unix
creates new processes.  This document gives a quick and dirty
<b><tt class="func">fork()</tt></b> primer, since use of that system call will pop up in
other IPC documents.  If you already know all about <b><tt class="func">fork()</tt></b>,
you might as well skip this document.</p>







<h3 class="sect2title">2.1. <a name="forkperil">"Seek ye the Gorge of Eternal Peril"</a></h3>


<p><b><tt class="func">fork()</tt></b> can be thought of as a ticket to power.  Power
can sometimes be thought of as a ticket to destruction.  Therefore, you
should be careful while messing with <b><tt class="func">fork()</tt></b> on your system,
especially while people are cranking their nearly-late semester projects
and are ready to nuke the first organism that brings the system to a
halt.  It's not that you should never play with <b><tt class="func">fork()</tt></b>, you
just have to be cautious.  It's kind of like sword-swallowing; if you're
careful, you won't disembowel yourself.</p>

<p>Since you're still here, I suppose I'd better deliver the goods.
Like I said, <b><tt class="func">fork()</tt></b> is how Unix starts new processes.
Basically, how it works is this: the parent process (the one that
already exists) <b><tt class="func">fork()</tt></b>'s a child process (the new one).
The child process gets a <i>copy</i> of the parent's data.
<i>Voila!</i> You have two processes where there was only
one!</p>

<p>Of course, there are all kinds of gotchas you must deal with when
<b><tt class="func">fork()</tt></b>ing processes or else your sysadmin will get irate with
you when you fill of the system process table and they have to punch the
reset button on the machine.</p>

<p>First of all, you should know something of process behavior under
Unix.  When a process dies, it doesn't really go away completely.  It's
dead, so it's no longer running, but a small remnant is waiting around
for the parent process to pick up.  This remnant contains the return
value from the child process and some other goop.  So after a parent
process <b><tt class="func">fork()</tt></b>s a child process, it must
<b><tt class="func">wait()</tt></b> (or <b><tt class="func">waitpid()</tt></b>) for that child process
to exit.  It is this act of <b><tt class="func">wait()</tt></b>ing that allows all
remnants of the child to vanish.</p>

<p>Naturally, there is an exception to the above rule: the parent can
ignore the <tt class="const">SIGCHLD</tt> signal (<tt class="const">SIGCLD</tt> on some
older systems) and then it won't have to <b><tt class="func">wait()</tt></b>.  This can
be done (on systems that support it) like this:</p>

<pre class="code"> main()
{
    signal(SIGCHLD, SIG_IGN);  /* now I don't have to wait()! */
    .
    .
    fork();fork();fork();  /* Rabbits, rabbits, rabbits! */</pre>


<p>Now, when a child process dies and has not been <b><tt class="func">wait()</tt></b>ed
on, it will usually show up in a <b class="com">ps</b> listing as
"<tt class="tt">&lt;defunct&gt;</tt>".  It will remain this way until the parent
<b><tt class="func">wait()</tt></b>s on it, or it is dealt with as mentioned below.</p>

<p>Now there is another rule you must learn: when the parent dies before
it <b><tt class="func">wait()</tt></b>s for the child (assuming it is not ignoring
<tt class="const">SIGCHLD</tt>), the child is reparented to the <b class="com">init</b>
process (PID 1).  This is not a problem if the child is still living
well and under control.  However, if the child is already defunct, we're
in a bit of a bind.  See, the original parent can no longer
<b><tt class="func">wait()</tt></b>, since it's dead.  So how does <b class="com">init</b> know
to <b><tt class="func">wait()</tt></b> for these <i>zombie processes</i>?</p>

<p>The answer: it's magic!  Well, on some systems, <b class="com">init</b>
periodically destroys all the defunct processes it owns.  On other
systems, it outright refuses to become the parent of any defunct
processes, instead destroying them immediately.  If you're using one of
the former systems, you could easily write a loop that fills up the
process table with defunct processes owned by <b class="com">init</b>.  Wouldn't
that make your sysadmin happy?</p>

<p>Your mission: make sure your parent process either ignores
<tt class="const">SIGHCLD</tt>, or <b><tt class="func">wait()</tt></b>s for all the children it
<b><tt class="func">fork()</tt></b>s.  Well, you don't <i>always</i> have to do that
(like if you're starting a daemon or something), but you code with
caution if you're a <b><tt class="func">fork()</tt></b> novice.  Otherwise, feel free to
blast off into the stratosphere.</p>

<p>To summerize: children become defunct until the parent
<b><tt class="func">wait()</tt></b>s, unless the parent is ignoring
<tt class="const">SIGCHLD</tt>.  Furthermore, children (living or defunct) whose
parents die without <b><tt class="func">wait()</tt></b>ing for them (again assuming the
parent is not ignoring <tt class="const">SIGCHLD</tt>) become children of the
<b class="com">init</b> process, which deals with them heavy-handedly.</p>









<h3 class="sect2title">2.2. <a name="forkbutton">"I'm mentally prepared!  Give me <i>The Button</i>!"</a></h3>


<p>Right!  Here's an <a href="http://beej.us/guide/bgipc/examples/fork1.c" target="_blank">example</a> of
how to use <b><tt class="func">fork()</tt></b>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

int main(void)
{
    pid_t pid;
    int rv;

    switch(pid = fork()) {
    case -1:
        perror("fork");  /* something went wrong */
        exit(1);         /* parent exits */

    case 0:
        printf(" CHILD: This is the child process!\n");
        printf(" CHILD: My PID is %d\n", getpid());
        printf(" CHILD: My parent's PID is %d\n", getppid());
        printf(" CHILD: Enter my exit status (make it small): ");
        scanf(" %d", &amp;rv);
        printf(" CHILD: I'm outta here!\n");
        exit(rv);

    default:
        printf("PARENT: This is the parent process!\n");
        printf("PARENT: My PID is %d\n", getpid());
        printf("PARENT: My child's PID is %d\n", pid);
        printf("PARENT: I'm now waiting for my child to exit()...\n");
        wait(&amp;rv);
        printf("PARENT: My child's exit status is: %d\n", WEXITSTATUS(rv));
        printf("PARENT: I'm outta here!\n");
    }

    return 0;
}</pre>


<p>There is a ton of stuff to note from this example, so we'll just
start from the top, shall we?</p>

<p><i><tt class="var">pid_t</tt></i> is the generic process type.  Under Unix, this is a
<nobr><tt class="type">short</tt></nobr>.  So, I call <b><tt class="func">fork()</tt></b> and save the return
value in the <i><tt class="var">pid</tt></i> variable.  <b><tt class="func">fork()</tt></b> is easy,
since it can only return three things:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="15%%"><p><tt class="const">0</tt></p></td>

<td valign="top" align="left" width="85%%"><p>If it returns <tt class="const">0</tt>, you are the child
process.  You can get the parent's PID by calling
<b><tt class="func">getppid()</tt></b>.  Of course, you can get your own PID by calling
<b><tt class="func">getpid()</tt></b>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><tt class="const">-1</tt>:</p></td>

<td valign="top" align="left"><p>If it returns <tt class="const">-1</tt>, something went wrong, and no
child was created.  Use <b><tt class="func">perror()</tt></b> to see what happened.
You've probably filled the process table—if you turn around
you'll see your sysadmin coming at you with a fireaxe.</p></td>
</tr>


<tr><td valign="top" align="left"><p>else:</p></td>

<td valign="top" align="left"><p>Any other value returned by <b><tt class="func">fork()</tt></b> means that you're
the parent and the value returned is the PID of your child.  This is the
only way to get the PID of your child, since there is no
<b><tt class="func">getcpid()</tt></b> call (obviously due to the one-to-many
relationship between parents and children.)</p></td>
</tr>


</table></center>


<p>When the child finally calls <b><tt class="func">exit()</tt></b>, the return value
passed will arrive at the parent when it <b><tt class="func">wait()</tt></b>s.  As you
can see from the <b><tt class="func">wait()</tt></b> call, there's some weirdness coming
into play when we print the return value.  What's this
<tt class="const">WEXITSTATUS()</tt> stuff, anyway?  Well, that is a macro that
extracts the child's actual return value from the value
<b><tt class="func">wait()</tt></b> returns.  Yes, there is more information buried in
that <nobr><tt class="type">int</tt></nobr>.  I'll let you look it up on your own.</p>

<p>"How," you ask, "does <b><tt class="func">wait()</tt></b> know which process to wait
for?  I mean, since the parent can have multiple children, which one
does <b><tt class="func">wait()</tt></b> actually wait for?"  The answer is simple, my
friends: it waits for whichever one happens to exit first.  If you must,
you can specify exactly which child to wait for by calling
<b><tt class="func">waitpid()</tt></b> with your child's PID as an argument.</p>

<p>Another interesting thing to note from the above example is that both
parent and child use the <i><tt class="var">rv</tt></i> variable.  Does this mean that it
is shared between the processes?  <i>NO!</i>  If it was, I wouldn't
have written all this IPC stuff.  <i>Each process has its own copy of
all variables.</i>  There is a lot of other stuff that is copied, too,
but you'll have to read the <b class="com">man</b> page to see what.</p>

<p>A final note about the above program: I used a switch statement to
handle the <b><tt class="func">fork()</tt></b>, and that's not exactly typical.  Most
often you'll see an <b><tt class="func">if</tt></b> statement there; sometimes
it's as short as:</p>

<pre class="code">if (!fork()) {
        printf("I'm the child!\n");
        exit(0);
    } else {
        printf("I'm the parent!\n");
        wait(NULL);
    }</pre>


<p>Oh yeah—the above example also demonstrates how to
<b><tt class="func">wait()</tt></b> if you don't care what the return value of the child
is: you just call it with <tt class="const">NULL</tt> as the argument.</p>









<h3 class="sect2title">2.3. <a name="forksum">Summary</a></h3>


<p>Now you know all about the mighty <b><tt class="func">fork()</tt></b> function!  It's
more useful that a wet bag of worms in most computationally intensive
situations, and you can amaze your friends at parties.  Additionally, it
can help make you more attractive to members of the opposite sex, unless
you're male.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">3. <a name="signals">Signals</a></h2><hr class="mainsecthr"/>


<p>There is a sometimes useful method for one process to bug another:
signals.  Basically, one process can "raise" a signal and have it
delivered to another process.  The destination process's signal handler
(just a function) is invoked and the process can handle it.</p>

<p>The devil's in the details, of course, and in actuality what you are
permitted to do safely inside your signal hander is rather limited.
Nevertheless, signals provide a useful service.</p>

<p>For example, one process might want to stop another one, and this
can be done by sending the signal <tt class="const">SIGSTOP</tt> to that
process.  To continue, the process has to receive signal
<tt class="const">SIGCONT</tt>.  How does the process know to do this when it
receives a certain signal?  Well, many signals are predefined and the
process has a default signal handler to deal with it.</p>

<p>A default handler?  Yes.  Take <tt class="const">SIGINT</tt> for example.
This is the interrupt signal that a process receives when the user hits
<tt class="tt">^C</tt>.  The default signal handler for <tt class="const">SIGINT</tt>
causes the process to exit!  Sound familiar?  Well, as you can imagine,
you can override the <tt class="const">SIGINT</tt> to do whatever you want (or
nothing at all!)  You could have your process <b><tt class="func">printf()</tt></b>
"Interrupt?!  No way, Jose!" and go about its merry business.</p>

<p>So now you know that you can have your process respond to just about
any signal in just about any way you want.  Naturally, there are
exceptions because otherwise it would be too easy to understand.  Take
the ever popular <tt class="const">SIGKILL</tt>, signal #9.  Have you ever typed
<nobr>"<b class="com">kill -9 <i>nnnn</i></b>"</nobr> to kill a runaway
process?  You were sending it <tt class="const">SIGKILL</tt>.  Now you might
also remember that no process can get out of a <nobr>"<b class="com">kill
-9</b>",</nobr> and you would be correct.  <tt class="const">SIGKILL</tt> is
one of the signals you <b class="com">can't</b> add your own signal handler for.
The aforementioned <tt class="const">SIGSTOP</tt> is also in this category.</p>

<p>(Aside: you often use the Unix "<b class="com">kill</b>" command without
specifying a signal to send...so what signal is it?  The answer:
<tt class="const">SIGTERM</tt>.  You can write your own handler for
<tt class="const">SIGTERM</tt> so your process won't respond to a regular
"<b class="com">kill</b>", and the user must then use "<b class="com">kill -9</b>" to
destroy the process.)</p>

<p>Are all the signals predefined?  What if you want to send a signal
that has significance that only you understand to a process?  There are
two signals that aren't reserved: <tt class="const">SIGUSR1</tt> and
<tt class="const">SIGUSER2</tt>.  You are free to use these for whatever you
want and handle them in whatever way you choose.  (For example, my cd
player program might respond to <tt class="const">SIGUSR1</tt> by advancing to
the next track.  In this way, I could control it from the command line
by typing <nobr>"<b class="com">kill -SIGUSR1 <i><tt class="var">nnnn</tt></i></b>".)</nobr></p>




<h3 class="sect2title">3.1. <a name="catchsig">Catching Signals for Fun and Profit!</a></h3>


<p>As you can guess the Unix "kill" command is one way to send signals
to a process.  By sheer unbelievable coincidence, there is a system call
called <b><tt class="func">kill()</tt></b> which does the same thing.  It takes for its
argument a signal number (as defined in <i><tt class="var">signal.h</tt></i>) and a
process ID.  Also, there is a library routine called
<b><tt class="func">raise()</tt></b> which can be used to raise a signal within the same
process.</p>

<p>The burning question remains: how do you catch a speeding
<tt class="const">SIGTERM</tt>?  You need to call <b><tt class="func">sigaction()</tt></b> and
tell it all the gritty details about which signal you want to catch and
which function you want to call to handle it.</p>

<p>Here's the <b><tt class="func">sigaction()</tt></b> breakdown:</p>

<pre class="code">int sigaction(int <i><tt class="var em1">sig</tt></i>, const struct sigaction *<i><tt class="var em1">act</tt></i>,
              struct sigaction *<i><tt class="var em1">oact</tt></i>);</pre>


<p>The first parameter, <i><tt class="var">sig</tt></i> is which signal to catch.
This can be (probably "should" be) a symbolic name from
<i><tt class="var">signal.h</tt></i> along the lines of <tt class="const">SIGINT</tt>.  That's
the easy bit.</p>

<p>The next field, <i><tt class="var">act</tt></i> is a pointer to a <nobr><tt class="type">struct
sigaction</tt></nobr> which has a bunch of fields that you can fill in to
control the behavior of the signal handler.  (A pointer to the signal
handler function itself included in the <nobr><tt class="type">struct</tt></nobr>.)</p>

<p>Lastly <i><tt class="var">oact</tt></i> can be <tt class="const">NULL</tt>, but if not, it
returns the <i>old</i> signal handler information that was in place
before. This is useful if you want to restore the previous signal
handler at a later time.</p>

<p>We'll focus on these three fields in the <nobr><tt class="type">struct
sigaction</tt></nobr>:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="25%%"><b><u>Signal</u></b></td>
<td valign="top" align="left" width="70%%"><b><u>Description</u></b></td>
</tr>

<tr><td valign="top" align="left"><nobr><tt class="type">sa_handler</tt></nobr></td>
<td valign="top" align="left">The signal handler function (or <tt class="const">SIG_IGN</tt> to ignore the signal)</td>
</tr>

<tr><td valign="top" align="left"><nobr><tt class="type">sa_mask</tt></nobr></td>
<td valign="top" align="left">A set of signals to block while this one is being handled</td>
</tr>

<tr><td valign="top" align="left"><nobr><tt class="type">sa_flags</tt></nobr></td>
<td valign="top" align="left">Flags to modify the behavior of the handler, or <tt class="const">0</tt></td>
</tr>

</table></center>


<p>What about that <nobr><tt class="type">sa_mask</tt></nobr> field?  When you're handling a
signal, you might want to block other signals from being delivered, and
you can do this by adding them to the <nobr><tt class="type">sa_mask</tt></nobr>
It's a "set", which means you can do normal set operations to manipulate
them: <b><tt class="func">sigemptyset()</tt></b>, <b><tt class="func">sigfillset()</tt></b>,
<b><tt class="func">sigaddset()</tt></b>, <b><tt class="func">sigdelset()</tt></b>, and
<b><tt class="func">sigismember()</tt></b>.  In this example, we'll just clear the set
and not block any other signals.</p>

<p>Examples always help!  Here's one that handled <tt class="const">SIGINT</tt>,
which can be delivered by hitting <tt class="tt">^C</tt>, called <i><tt class="var"><a href="http://beej.us/guide/bgipc/examples/sigint.c" target="_blank">sigint.c</a></tt></i>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;

void sigint_handler(int sig)
{
    write(0, "Ahhh! SIGINT!\n", 14);
}

int main(void)
{
    void sigint_handler(int sig); /* prototype */
    char s[200];
    struct sigaction sa;

    sa.sa_handler = sigint_handler;
    sa.sa_flags = 0; // or SA_RESTART
    sigemptyset(&amp;sa.sa_mask);

    if (sigaction(SIGINT, &amp;sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    printf("Enter a string:\n");

    if (fgets(s, sizeof s, stdin) == NULL)
        perror("fgets");
    else 
        printf("You entered: %s\n", s);

    return 0;
}</pre>


<p>This program has two functions: <b><tt class="func">main()</tt></b> which sets up the
signal handler (using the <b><tt class="func">sigaction()</tt></b> call), and
<b><tt class="func">sigint_handler()</tt></b> which is the signal handler, itself.</p>

<p>What happens when you run it?  If you are in the midst of entering a
string and you hit <tt class="tt">^C</tt>, the call to <b><tt class="func">gets()</tt></b> fails
and sets the global variable <i><tt class="var">errno</tt></i> to <tt class="const">EINTR</tt>.
Additionally, <b><tt class="func">sigint_handler()</tt></b> is called and does its
routine, so you actually see:</p>

<pre class="screen">Enter a string:
<b>the quick brown fox jum^C</b>Ahhh! SIGINT!
fgets: Interrupted system call</pre>


<p>And then it exits.  Hey—what kind of handler is this, if it
just exits anyway?</p>

<p>Well, we have a couple things at play, here. First, you'll notice
that the signal handler was called, because it printed "Ahhh! SIGINT!"
But then <b><tt class="func">fgets()</tt></b> returns an error, namely
<tt class="const">EINTR</tt>, or "Interrupted system call".  See, some system
calls can be interrupted by signals, and when this happens, they return
an error.  You might see code like this (sometimes cited as an excusable
use of <tt class="tt">goto</tt>):</p>

<pre class="code">
restart:
    if (some_system_call() == -1) {
        if (errno == EINTR) goto restart;
        perror("some_system_call");
        exit(1);
    }</pre>


<p>Instead of using <tt class="tt">goto</tt> like that, you might be able to set
your <nobr><tt class="type">sa_flags</tt></nobr> to include <tt class="const">SA_RESTART</tt>.  For
example, if we change our <tt class="const">SIGINT</tt> handler code to look
like this:</p>

<pre class="code">    sa.sa_flags = SA_RESTART;</pre>


<p>Then our run looks more like this:</p>

<pre class="screen">Enter a string:
<b>Hello^C</b>Ahhh! SIGINT!
<b>Er, hello!^C</b>Ahhh! SIGINT!
<b>This time fer sure!</b>
You entered: This time fer sure!</pre>


<p>Some system calls are interruptible, and some can be restarted.  It's
system dependent.</p>





<h3 class="sect2title">3.2. <a name="handlerok">The Handler is not Omnipotent</a></h3>


<p>You have to be careful when you make function calls in your signal
handler. Those functions must be "async safe", so they can be called
without invoking undefined behavior.</p>

<p>You might be curious, for instance, why my signal handler, above,
called <b><tt class="func">write()</tt></b> to output the message instead of
<b><tt class="func">printf()</tt></b>. Well, the answer is that POSIX says that
<b><tt class="func">write()</tt></b> is async-safe (so is safe to call from within the
handler), while <b><tt class="func">printf()</tt></b> is not.</p>

<p>The library functions and system calls that are async-safe and can be
called from within your signal handlers are (breath):</p>

<p><b><tt class="func">_Exit()</tt></b>, <b><tt class="func">_exit()</tt></b>, <b><tt class="func">abort()</tt></b>,
<b><tt class="func">accept()</tt></b>, <b><tt class="func">access()</tt></b>, <b><tt class="func">aio_error()</tt></b>,
<b><tt class="func">aio_return()</tt></b>, <b><tt class="func">aio_suspend()</tt></b>,
<b><tt class="func">alarm()</tt></b>, <b><tt class="func">bind()</tt></b>, <b><tt class="func">cfgetispeed()</tt></b>,
<b><tt class="func">cfgetospeed()</tt></b>, <b><tt class="func">cfsetispeed()</tt></b>,
<b><tt class="func">cfsetospeed()</tt></b>, <b><tt class="func">chdir()</tt></b>, <b><tt class="func">chmod()</tt></b>,
<b><tt class="func">chown()</tt></b>, <b><tt class="func">clock_gettime()</tt></b>,
<b><tt class="func">close()</tt></b>, <b><tt class="func">connect()</tt></b>, <b><tt class="func">creat()</tt></b>,
<b><tt class="func">dup()</tt></b>, <b><tt class="func">dup2()</tt></b>, <b><tt class="func">execle()</tt></b>,
<b><tt class="func">execve()</tt></b>, <b><tt class="func">fchmod()</tt></b>, <b><tt class="func">fchown()</tt></b>,
<b><tt class="func">fcntl()</tt></b>, <b><tt class="func">fdatasync()</tt></b>, <b><tt class="func">fork()</tt></b>,
<b><tt class="func">fpathconf()</tt></b>, <b><tt class="func">fstat()</tt></b>, <b><tt class="func">fsync()</tt></b>,
<b><tt class="func">ftruncate()</tt></b>, <b><tt class="func">getegid()</tt></b>,
<b><tt class="func">geteuid()</tt></b>, <b><tt class="func">getgid()</tt></b>, <b><tt class="func">getgroups()</tt></b>,
<b><tt class="func">getpeername()</tt></b>, <b><tt class="func">getpgrp()</tt></b>,
<b><tt class="func">getpid()</tt></b>, <b><tt class="func">getppid()</tt></b>,
<b><tt class="func">getsockname()</tt></b>, <b><tt class="func">getsockopt()</tt></b>,
<b><tt class="func">getuid()</tt></b>, <b><tt class="func">kill()</tt></b>, <b><tt class="func">link()</tt></b>,
<b><tt class="func">listen()</tt></b>, <b><tt class="func">lseek()</tt></b>, <b><tt class="func">lstat()</tt></b>,
<b><tt class="func">mkdir()</tt></b>, <b><tt class="func">mkfifo()</tt></b>, <b><tt class="func">open()</tt></b>,
<b><tt class="func">pathconf()</tt></b>, <b><tt class="func">pause()</tt></b>, <b><tt class="func">pipe()</tt></b>,
<b><tt class="func">poll()</tt></b>, <b><tt class="func">posix_trace_event()</tt></b>,
<b><tt class="func">pselect()</tt></b>, <b><tt class="func">raise()</tt></b>, <b><tt class="func">read()</tt></b>,
<b><tt class="func">readlink()</tt></b>, <b><tt class="func">recv()</tt></b>, <b><tt class="func">recvfrom()</tt></b>,
<b><tt class="func">recvmsg()</tt></b>, <b><tt class="func">rename()</tt></b>, <b><tt class="func">rmdir()</tt></b>,
<b><tt class="func">select()</tt></b>, <b><tt class="func">sem_post()</tt></b>, <b><tt class="func">send()</tt></b>,
<b><tt class="func">sendmsg()</tt></b>, <b><tt class="func">sendto()</tt></b>, <b><tt class="func">setgid()</tt></b>,
<b><tt class="func">setpgid()</tt></b>, <b><tt class="func">setsid()</tt></b>,
<b><tt class="func">setsockopt()</tt></b>, <b><tt class="func">setuid()</tt></b>,
<b><tt class="func">shutdown()</tt></b>, <b><tt class="func">sigaction()</tt></b>,
<b><tt class="func">sigaddset()</tt></b>, <b><tt class="func">sigdelset()</tt></b>,
<b><tt class="func">sigemptyset()</tt></b>, <b><tt class="func">sigfillset()</tt></b>,
<b><tt class="func">sigismember()</tt></b>, <b><tt class="func">sleep()</tt></b>, <b><tt class="func">signal()</tt></b>,
<b><tt class="func">sigpause()</tt></b>, <b><tt class="func">sigpending()</tt></b>,
<b><tt class="func">sigprocmask()</tt></b>, <b><tt class="func">sigqueue()</tt></b>,
<b><tt class="func">sigset()</tt></b>, <b><tt class="func">sigsuspend()</tt></b>,
<b><tt class="func">sockatmark()</tt></b>, <b><tt class="func">socket()</tt></b>,
<b><tt class="func">socketpair()</tt></b>, <b><tt class="func">stat()</tt></b>, <b><tt class="func">symlink()</tt></b>,
<b><tt class="func">sysconf()</tt></b>, <b><tt class="func">tcdrain()</tt></b>, <b><tt class="func">tcflow()</tt></b>,
<b><tt class="func">tcflush()</tt></b>, <b><tt class="func">tcgetattr()</tt></b>,
<b><tt class="func">tcgetpgrp()</tt></b>, <b><tt class="func">tcsendbreak()</tt></b>,
<b><tt class="func">tcsetattr()</tt></b>, <b><tt class="func">tcsetpgrp()</tt></b>, <b><tt class="func">time()</tt></b>,
<b><tt class="func">timer_getoverrun()</tt></b>, <b><tt class="func">timer_gettime()</tt></b>,
<b><tt class="func">timer_settime()</tt></b>, <b><tt class="func">times()</tt></b>,
<b><tt class="func">umask()</tt></b>, <b><tt class="func">uname()</tt></b>, <b><tt class="func">unlink()</tt></b>,
<b><tt class="func">utime()</tt></b>, <b><tt class="func">wait()</tt></b>, <b><tt class="func">waitpid()</tt></b>, and
<b><tt class="func">write()</tt></b>.</p>

<p>Of course, you can call your own functions from within your signal
handler (as long they don't call any non-async-safe functions.)</p>

<p>But wait—there's more!</p>

<p>You also cannot safely alter any shared (e.g. global) data, with one
notable exception: variables that are declared to be of storage class
and type <nobr><tt class="type">volatile sig_atomic_t</tt></nobr>.</p>

<p>Here's an example that handles <tt class="const">SIGUSR1</tt> by setting a
global flag, which is then examined in the main loop to see if the
handler was called.  This is <i><tt class="var"><a href="http://beej.us/guide/bgipc/examples/sigusr.c" target="_blank">sigusr.c</a></tt></i>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;

volatile sig_atomic_t got_usr1;

void sigusr1_handler(int sig)
{
    got_usr1 = 1;
}

int main(void)
{
    struct sigaction sa;

    got_usr1 = 0;

    sa.sa_handler = sigusr1_handler;
    sa.sa_flags = 0;
    sigemptyset(&amp;sa.sa_mask);

    if (sigaction(SIGUSR1, &amp;sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    while (!got_usr1) {
        printf("PID %d: working hard...\n", getpid());
        sleep(1);
    }

    printf("Done in by SIGUSR1!\n");

    return 0;
}</pre>


<p>Fire it it up in one window, and then use the <b class="com">kill -USR1</b> in
another window to kill it.  The <i><tt class="var">sigusr</tt></i> program
conveniently prints out its process ID so you can pass it to
<b class="com">kill</b>:</p>

<pre class="screen">$ <b>sigusr</b>
PID 5023: working hard...
PID 5023: working hard...
PID 5023: working hard...</pre>


<p>Then in the other window, send it the signal
<tt class="const">SIGUSR1</tt>:</p>

<pre class="screen">$ <b>kill -USR1 5023</b></pre>


<p>And the program should respond:</p>

<pre class="screen">PID 5023: working hard...
PID 5023: working hard...
Done in by SIGUSR1!</pre>


<p>(And the response should be immediate even if <b><tt class="func">sleep()</tt></b>
has just been called—<b><tt class="func">sleep()</tt></b> gets interrupted by
signals.)</p>

 




<h3 class="sect2title">3.3. <a name="signalwrong">What about <b><tt class="titlefunc">signal()</tt></b></a></h3>


<p>ANSI-C defines a function called <b><tt class="func">signal()</tt></b> that can be used to
catch signals.  It's not as reliable or as full-featured as
<b><tt class="func">sigaction()</tt></b>, so use of <b><tt class="func">signal()</tt></b>is generally
discouraged.</p>






<h3 class="sect2title">3.4. <a name="signalpop">Some signals to make you popular</a></h3>


<p>Here is a list of signals you (most likely) have at your
disposal:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="30%%"><b><u>Signal</u></b></td>
<td valign="top" align="left" width="70%%"><b><u>Description</u></b></td>
</tr>

<tr><td valign="top" align="left">SIGABRT</td>
<td valign="top" align="left">Process abort signal.</td>
</tr>

<tr><td valign="top" align="left">SIGALRM</td>
<td valign="top" align="left">Alarm clock.</td>
</tr>

<tr><td valign="top" align="left">SIGFPE</td>
<td valign="top" align="left">Erroneous arithmetic operation.</td>
</tr>

<tr><td valign="top" align="left">SIGHUP</td>
<td valign="top" align="left">Hangup.</td>
</tr>

<tr><td valign="top" align="left">SIGILL</td>
<td valign="top" align="left">Illegal instruction.</td>
</tr>

<tr><td valign="top" align="left">SIGINT</td>
<td valign="top" align="left">Terminal interrupt signal.</td>
</tr>

<tr><td valign="top" align="left">SIGKILL</td>
<td valign="top" align="left">Kill (cannot be caught or ignored).</td>
</tr>

<tr><td valign="top" align="left">SIGPIPE</td>
<td valign="top" align="left">Write on a pipe with no one to read it.</td>
</tr>

<tr><td valign="top" align="left">SIGQUIT</td>
<td valign="top" align="left">Terminal quit signal.</td>
</tr>

<tr><td valign="top" align="left">SIGSEGV</td>
<td valign="top" align="left">Invalid memory reference.</td>
</tr>

<tr><td valign="top" align="left">SIGTERM</td>
<td valign="top" align="left">Termination signal.</td>
</tr>

<tr><td valign="top" align="left">SIGUSR1</td>
<td valign="top" align="left">User-defined signal 1.</td>
</tr>

<tr><td valign="top" align="left">SIGUSR2</td>
<td valign="top" align="left">User-defined signal 2.</td>
</tr>

<tr><td valign="top" align="left">SIGCHLD</td>
<td valign="top" align="left">Child process terminated or stopped.</td>
</tr>

<tr><td valign="top" align="left">SIGCONT</td>
<td valign="top" align="left">Continue executing, if stopped.</td>
</tr>

<tr><td valign="top" align="left">SIGSTOP</td>
<td valign="top" align="left">Stop executing (cannot be caught or ignored).</td>
</tr>

<tr><td valign="top" align="left">SIGTSTP</td>
<td valign="top" align="left">Terminal stop signal.</td>
</tr>

<tr><td valign="top" align="left">SIGTTIN</td>
<td valign="top" align="left">Background process attempting read.</td>
</tr>

<tr><td valign="top" align="left">SIGTTOU</td>
<td valign="top" align="left">Background process attempting write.</td>
</tr>

<tr><td valign="top" align="left">SIGBUS</td>
<td valign="top" align="left">Bus error.</td>
</tr>

<tr><td valign="top" align="left">SIGPOLL</td>
<td valign="top" align="left">Pollable event.</td>
</tr>

<tr><td valign="top" align="left">SIGPROF</td>
<td valign="top" align="left">Profiling timer expired.</td>
</tr>

<tr><td valign="top" align="left">SIGSYS</td>
<td valign="top" align="left">Bad system call.</td>
</tr>

<tr><td valign="top" align="left">SIGTRAP</td>
<td valign="top" align="left">Trace/breakpoint trap.</td>
</tr>

<tr><td valign="top" align="left">SIGURG</td>
<td valign="top" align="left">High bandwidth data is available at a socket.</td>
</tr>

<tr><td valign="top" align="left">SIGVTALRM</td>
<td valign="top" align="left">Virtual timer expired.</td>
</tr>

<tr><td valign="top" align="left">SIGXCPU</td>
<td valign="top" align="left">CPU time limit exceeded.</td>
</tr>

<tr><td valign="top" align="left">SIGXFSZ</td>
<td valign="top" align="left">File size limit exceeded.</td>
</tr>

</table></center>


<p>Each signal has its own default signal handler, the behavior of which
is defined in your local man pages.</p>






<h3 class="sect2title">3.5. <a name="siggloss">What I have Glossed Over</a></h3>


<p>Nearly all of it.  There are tons of flags, realtime signals, mixing
signals with threads, masking signals, <b><tt class="func">longjmp()</tt></b> and
signals, and more.</p>

<p>Of course, this is just a "getting started" guide, but in a last-ditch
effort to give you more information, here is a list of man pages with more
information:</p>

<p>Handling signals:
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigaction.html" target="_blank"><b><tt class="func">sigaction()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigwait.html" target="_blank"><b><tt class="func">sigwait()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigwaitinfo.html" target="_blank"><b><tt class="func">sigwaitinfo()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigtimedwait.html" target="_blank"><b><tt class="func">sigtimedwait()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigsuspend.html" target="_blank"><b><tt class="func">sigsuspend()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigpending.html" target="_blank"><b><tt class="func">sigpending()</tt></b></a></p>

<p>Delivering signals:
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/kill.html" target="_blank"><b><tt class="func">kill()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/raise.html" target="_blank"><b><tt class="func">raise()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigqueue.html" target="_blank"><b><tt class="func">sigqueue()</tt></b></a></p>

<p>Set operations:
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigemptyset.html" target="_blank"><b><tt class="func">sigemptyset()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigfillset.html" target="_blank"><b><tt class="func">sigfillset()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigaddset.html" target="_blank"><b><tt class="func">sigaddset()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigdelset.html" target="_blank"><b><tt class="func">sigdelset()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigismember.html" target="_blank"><b><tt class="func">sigismember()</tt></b></a></p>

<p>Other:
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigprocmask.html" target="_blank"><b><tt class="func">sigprocmask()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigaltstack.html" target="_blank"><b><tt class="func">sigaltstack()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/siginterrupt.html" target="_blank"><b><tt class="func">siginterrupt()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/sigsetjmp.html" target="_blank"><b><tt class="func">sigsetjmp()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/siglongjmp.html" target="_blank"><b><tt class="func">siglongjmp()</tt></b></a>
<a href="http://www.opengroup.org/onlinepubs/007908775/xsh/signal.html" target="_blank"><b><tt class="func">signal()</tt></b></a></p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">4. <a name="pipes">Pipes</a></h2><hr class="mainsecthr"/>


<p>There is no form of IPC that is simpler than pipes.  Implemented on
every flavor of Unix, <b><tt class="func">pipe()</tt></b> and <b><tt class="func"><a href="#fork">fork()</a></tt></b> make up the functionality behind the
"<b class="com">|</b>" in <nobr>"<b class="com">ls | more</b>".</nobr>  They are
marginally useful for cool things, but are a good way to learn about
basic methods of IPC.</p>

<p>Since they're so very very easy, I shant spent much time on them.
We'll just have some examples and stuff.</p>



<h3 class="sect2title">4.1. <a name="pipesclean">"These pipes are clean!"</a></h3>


<p>Wait!  Not so fast.  I might need to define a "file descriptor" at
this point.  Let me put it this way: you know about "<nobr><tt class="type">FILE*</tt></nobr>"
from <i><tt class="var">stdio.h</tt></i>, right?  You know how you have all those nice
functions like <b><tt class="func">fopen()</tt></b>, <b><tt class="func">fclose()</tt></b>,
<b><tt class="func">fwrite()</tt></b>, and so on?  Well, those  are actually high level
functions that are implemented using <i>file descriptors</i>, which
use system calls such as <b><tt class="func">open()</tt></b>, <b><tt class="func">creat()</tt></b>,
<b><tt class="func">close()</tt></b>, and <b><tt class="func">write()</tt></b>.  File descriptors are
simply <nobr><tt class="type">ints</tt></nobr> that are analogous to <nobr><tt class="type">FILE*</tt></nobr>'s in
<i><tt class="var">stdio.h</tt></i>.</p>

<p>For example, <i><tt class="var">stdin</tt></i> is file descriptor "0",
<i><tt class="var">stdout</tt></i> is "1", and <i><tt class="var">stderr</tt></i> is "2".  Likewise, any
files you open using <b><tt class="func">fopen()</tt></b> get their own file descriptor,
although this detail is hidden from you.  (This file descriptor can be
retrived from the <nobr><tt class="type">FILE*</tt></nobr> by using the <b><tt class="func">fileno()</tt></b>
macro from <i><tt class="var">stdio.h</tt></i>.)</p>

<center>
<div><img src="pipe1-96-4.149.png" alt="[pipe diagram 1]"/></div>

<p><b>How a pipe is organized.</b></p>
</center>


<p>Basically, a call to the <b><tt class="func">pipe()</tt></b> function returns a pair
of file descriptors.  One of these descriptors is connected to the write
end of the pipe, and the other is connected to the read end.  Anything
can be written to the pipe, and read from the other end in the order it
came in.  On many systems, pipes will fill up after you write about 10K
to them without reading anything out.</p>

<p>As a <a href="http://beej.us/guide/bgipc/examples/pipe1.c" target="_blank">useless example</a>, the
following program creates, writes to, and reads from a pipe.</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    int pfds[2];
    char buf[30];

    if (pipe(pfds) == -1) {
        perror("pipe");
        exit(1);
    }

    printf("writing to file descriptor #%d\n", pfds[1]);
    write(pfds[1], "test", 5);
    printf("reading from file descriptor #%d\n", pfds[0]);
    read(pfds[0], buf, 5);
    printf("read \"%s\"\n", buf);

    return 0;
}</pre>


<p>As you can see, <b><tt class="func">pipe()</tt></b> takes an array of two
<nobr><tt class="type">int</tt></nobr>s as an argument.  Assuming no errors, it connects two
file descriptors and returns them in the array.  The first element of
the array is the reading-end of the pipe, the second is the writing
end.</p>






<h3 class="sect2title">4.2. <a name="pipefork"><b><tt class="titlefunc">fork()</tt></b> and <b><tt class="titlefunc">pipe()</tt></b>—you have the
power!</a></h3>


<p>From the above example, it's pretty hard to see how these would even
be useful.  Well, since this is an IPC document, let's put a
<b><tt class="func">fork()</tt></b> in the mix and see what happens.  Pretend that you
are a top federal agent assigned to get a child process to send the word
"test" to the parent.  Not very glamorous, but no one ever said computer
science would be the X-Files, Mulder.</p>

<p>First, we'll have the parent make a pipe.  Secondly, we'll
<b><tt class="func">fork()</tt></b>.  Now, the <b><tt class="func">fork()</tt></b> man page tells us
that the child will receive a copy of all the parent's file descriptors,
and this includes a copy of the pipe's file descriptors.
<i>Alors</i>, the child will be able to send stuff to the
write-end of the pipe, and the parent will get it off the read-end.
<a href="http://beej.us/guide/bgipc/examples/pipe2.c" target="_blank">Like this</a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    int pfds[2];
    char buf[30];

    pipe(pfds);

    if (!fork()) {
        printf(" CHILD: writing to the pipe\n");
        write(pfds[1], "test", 5);
        printf(" CHILD: exiting\n");
        exit(0);
    } else {
        printf("PARENT: reading from pipe\n");
        read(pfds[0], buf, 5);
        printf("PARENT: read \"%s\"\n", buf);
        wait(NULL);
    }

    return 0;
}</pre>


<p>Please note, your programs should have a lot more error checking than
mine do.  I leave it out on occasion to help keep things clear.</p>

<p>Anyway, this example is just like the previous one, except now we
<b><tt class="func">fork()</tt></b> of a new process and have it write to the pipe,
while the parent reads from it.  The resultant output will be something
similar to the following:</p>

<pre class="screen">PARENT: reading from pipe
 CHILD: writing to the pipe
 CHILD: exiting
PARENT: read "test"</pre>


<p>In this case, the parent tried to read from the pipe before the child
writes to it.  When this happens, the parent is said to
<i>block</i>, or sleep, until data arrives to be read.  It seems
that the parent tried to read, went to sleep, the child wrote and
exited, and the parent woke up and read the data.</p>

<p>Hurrah!!  You've just don't some interprocess communication!  That
was dreadfully simple, huh?  I'll bet you are still thinking that there
aren't many uses for <b><tt class="func">pipe()</tt></b> and, well, you're probably
right.  The other forms of IPC are generally more useful and are often
more exotic.</p>





<h3 class="sect2title">4.3. <a name="pipequest">The search for Pipe as we know it</a></h3>


<p>In an effort to make you think that pipes are actually reasonable
beasts, I'll give you an example of using <b><tt class="func">pipe()</tt></b> in a more
familiar situation.  The challenge: implement "<nobr><b class="com">ls | wc
-l</b></nobr>" in C.</p>

<p>This requires usage of a couple more functions you may never have
heard of: <b><tt class="func">exec()</tt></b> and <b><tt class="func">dup()</tt></b>.  The
<b><tt class="func">exec()</tt></b> family of functions replaces the currently running
process with whichever one is passed to <b><tt class="func">exec()</tt></b>.  This is
the function that we will use to run <b class="com">ls</b> and <nobr><b class="com">wc
-l</b></nobr>.  <b><tt class="func">dup()</tt></b> takes an open file descriptor and
makes a clone (a duplicate) of it.  This is how we will connect the
standard output of the <b class="com">ls</b> to the standard input of
<b class="com">wc</b>.  See, stdout of <b class="com">ls</b> flows into the pipe, and
the stdin of <b class="com">wc</b> flows in from the pipe.  The pipe fits right
there in the middle!</p>

<p>Anyway, <a href="http://beej.us/guide/bgipc/examples/pipe3.c" target="_blank">here is the code</a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    int pfds[2];

    pipe(pfds);

    if (!fork()) {
        close(1);       /* close normal stdout */
        dup(pfds[1]);   /* make stdout same as pfds[1] */
        close(pfds[0]); /* we don't need this */
        execlp("ls", "ls", NULL);
    } else {
        close(0);       /* close normal stdin */
        dup(pfds[0]);   /* make stdin same as pfds[0] */
        close(pfds[1]); /* we don't need this */
        execlp("wc", "wc", "-l", NULL);
    }

    return 0;
}</pre>


<p>I'm going to make another note about the
<b><tt class="func">close()</tt></b>/<b><tt class="func">dup()</tt></b> combination since it's pretty
weird.  <b><tt class="func">close(1)</tt></b> frees up file descriptor 1 (standard
output).  <b><tt class="func">dup(pfds[1])</tt></b> makes a copy of the write-end of the
pipe in the first available file descriptor, which is "1", since we just
closed that.  In this way, anything that <b class="com">ls</b> writes to
standard output (file descriptor 1) will instead go to
<i><tt class="var">pfds[1]</tt></i> (the write end of the pipe).  The <b class="com">wc</b>
section of code works the same way, except in reverse.</p>





<h3 class="sect2title">4.4. <a name="pipesum">Summary</a></h3>


<p>There aren't many of these for such a simple topic.  In fact, there
are nearly just about none.  Probably the best use for pipes is the one
you're most accustomed to: sending the standard output of one command to
the standard input of another.  For other uses, it's pretty limiting and
there are often other IPC techniques that work better.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">5. <a name="fifos">FIFOs</a></h2><hr class="mainsecthr"/>


<p>A FIFO ("First In, First Out", pronounced "Fy-Foh") is sometimes
known as a <i>named pipe</i>.  That is, it's like a <a href="#pipes">pipe</a>, except that it has a name!  In this case, the
name is that of a file that multiple processes can <b><tt class="func">open()</tt></b>
and read and write to.</p>

<p>This latter aspect of FIFOs is designed to let them get around one of
the shortcomings of normal pipes: you can't grab one end of a normal
pipe that was created by an unrelated process.  See, if I run two
individual copies of a program, they can both call <b><tt class="func">pipe()</tt></b>
all they want and still not be able to speak to one another.  (This is
because you must <b><tt class="func">pipe()</tt></b>, then <b><tt class="func">fork()</tt></b> to get a
child process that can communicate to the parent via the pipe.)  With
FIFOs, though, each unrelated process can simply <b><tt class="func">open()</tt></b> the
pipe and transfer data through it.</p>




<h3 class="sect2title">5.1. <a name="fifonew">A New FIFO is Born</a></h3>


<p>Since the FIFO is actually a file on disk, you have to do some
fancy-schmancy stuff to create it.  It's not that hard.  You just have
to call <b><tt class="func">mknod()</tt></b> with the proper arguments.  Here is a
<b><tt class="func">mknod()</tt></b> call that creates a FIFO:</p>

<pre class="code">mknod("myfifo", S_IFIFO | 0644 , 0);</pre>


<p>In the above example, the FIFO file will be called
"<i><tt class="var">myfifo</tt></i>".  The second argument is the creation mode, which
is used to tell <b><tt class="func">mknod()</tt></b> to make a FIFO (the
<tt class="const">S_IFIFO</tt> part of the OR) and sets access permissions to
that file (octal 644, or <tt class="tt">rw-r--r--</tt>) which can also be set by
ORing together macros from <i><tt class="var">sys/stat.h</tt></i>.  This permission is
just like the one you'd set using the <b class="com">chmod</b> command.
Finally, a device number is passed.  This is ignored when creating a
FIFO, so you can put anything you want in there.</p>

<p>(An aside: a FIFO can also be created from the command line using the
Unix <b class="com">mknod</b> command.)</p>





<h3 class="sect2title">5.2. <a name="fifopc">Producers and Consumers</a></h3>


<p>Once the FIFO has been created, a process can start up and open it
for reading or writing using the standard <b><tt class="func">open()</tt></b> system
call.</p>

<p>Since the process is easier to understand once you get some code in
your belly, I'll present here two programs which will send data through
a FIFO.  One is <i><tt class="var">speak.c</tt></i> which sends data through the FIFO,
and the other is called <i><tt class="var">tick.c</tt></i>, as it sucks data out of the
FIFO.</p>

<p>Here is <i><tt class="var"><a href="http://beej.us/guide/bgipc/examples/speak.c" target="_blank">speak.c</a></tt></i>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

#define FIFO_NAME "american_maid"

int main(void)
{
    char s[300];
    int num, fd;

    mknod(FIFO_NAME, S_IFIFO | 0666, 0);

    printf("waiting for readers...\n");
    fd = open(FIFO_NAME, O_WRONLY);
    printf("got a reader--type some stuff\n");

    while (gets(s), !feof(stdin)) {
        if ((num = write(fd, s, strlen(s))) == -1)
            perror("write");
        else
            printf("speak: wrote %d bytes\n", num);
    }

    return 0;
}</pre>


<p>What <b class="com">speak</b> does is create the FIFO, then try to
<b><tt class="func">open()</tt></b> it.  Now, what will happen is that the
<b><tt class="func">open()</tt></b> call will <i>block</i> until some other process
opens the other end of the pipe for reading.  (There is a way around
this—see <a href="#fifondelay"><tt class="const">O_NDELAY</tt></a>,
below.)  That process is <i><tt class="var"><a href="http://beej.us/guide/bgipc/examples/tick.c" target="_blank">tick.c</a></tt></i>, shown here:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

#define FIFO_NAME "american_maid"

int main(void)
{
    char s[300];
    int num, fd;

    mknod(FIFO_NAME, S_IFIFO | 0666, 0);

    printf("waiting for writers...\n");
    fd = open(FIFO_NAME, O_RDONLY);
    printf("got a writer\n");

    do {
        if ((num = read(fd, s, 300)) == -1)
            perror("read");
        else {
            s[num] = '\0';
            printf("tick: read %d bytes: \"%s\"\n", num, s);
        }
    } while (num &gt; 0);

    return 0;
}</pre>


<p> Like <i><tt class="var">speak.c</tt></i>, <b class="com">tick</b> will block on the
<b><tt class="func">open()</tt></b> if there is no one writing to the FIFO.  As soon as
someone opens the FIFO for writing, <b class="com">tick</b> will spring to
life.</p>

<p>Try it!  Start <b class="com">speak</b> and it will block until you start
<b class="com">tick</b> in another window.  (Conversely, if you start
<b class="com">tick</b>, it will block until you start <b class="com">speak</b> in
another window.)  Type away in the <b class="com">speak</b> window and
<b class="com">tick</b> will suck it all up.</p>

<p>Now, break out of <b class="com">speak</b>.  Notice what happens: the
<b><tt class="func">read()</tt></b> in <b class="com">tick</b> returns 0, signifying EOF.  In
this way, the reader can tell when all writers have closed their
connection to the FIFO.  "What?" you ask "There can be multiple writers
to the same pipe?"  Sure!  That can be very useful, you know.  Perhaps
I'll show you later in the document how this can be exploited.</p>

<p>But for now, lets finish this topic by seeing what happens when you
break out of <b class="com">tick</b> while <b class="com">speak</b> is running.
"Broken Pipe"!  What does this mean?  Well, what has happened is that
when all readers for a FIFO close and the writer is still open, the
writer will receiver the signal SIGPIPE the next time it tries to
<b><tt class="func">write()</tt></b>.  The default signal handler for this signal prints
"Broken Pipe" and exits.  Of course, you can handle this more gracefully
by catching SIGPIPE through the <b><tt class="func">signal()</tt></b> call.</p>

<p>Finally, what happens if you have multiple readers?  Well, strange
things happen.  Sometimes one of the readers get everything.  Sometimes
it alternates between readers.  Why do you want to have multiple
readers, anyway?</p>





<h3 class="sect2title">5.3. <a name="fifondelay"><tt class="const">O_NDELAY</tt>!  I'm UNSTOPPABLE!</a></h3>


<p>Earlier, I mentioned that you could get around the blocking
<b><tt class="func">open()</tt></b> call if there was no corresponding reader or writer.
The way to do this is to call <b><tt class="func">open()</tt></b> with the
<tt class="const">O_NDELAY</tt> flag set in the mode argument:</p>

<pre class="code">fd = open(FIFO_NAME, O_RDONLY | <b>O_NDELAY</b>);</pre>


<p>This will cause <b><tt class="func">open()</tt></b> to return <tt class="const">-1</tt> if
there are no processes that have the file open for reading.</p>

<p>Likewise, you can open the reader process using the
<tt class="const">O_NDELAY</tt> flag, but this has a different effect: all
attempts to <b><tt class="func">read()</tt></b> from the pipe will simply return
<tt class="const">0</tt> bytes read if there is no data in the pipe.  (That is,
the <b><tt class="func">read()</tt></b> will no longer block until there is some data in
the pipe.)  Note that you can no longer tell if <b><tt class="func">read()</tt></b> is
returning <tt class="const">0</tt> because there is no data in the pipe, or
because the writer has exited.  This is the price of power, but my
suggestion is to try to stick with blocking whenever possible.</p>







<h3 class="sect2title">5.4. <a name="fifoconc">Concluding Notes</a></h3>


<p>Having the name of the pipe right there on disk sure makes it easier,
doesn't it?  Unrelated processes can communicate via pipes!  (This is an
ability you will find yourself wishing for if you use normal pipes for
too long.)  Still, though, the functionality of pipes might not be quite
what you need for your applications.  <a href="#mq">Message
queues</a> might be more your speed, if your system supports
them.</p>



  







<hr class="mainsectbreak"/><h2 class="sect1title">6. <a name="flocking">File Locking</a></h2><hr class="mainsecthr"/>


<p>File locking provides a very simple yet incredibly useful mechanism
for coordinating file accesses.  Before I begin to lay out the details,
let me fill you in on some file locking secrets:</p>

<p>There are two types of locking mechanisms: mandatory and advisory.
Mandatory systems will actually prevent <b><tt class="func">read()</tt></b>s and
<b><tt class="func">write()</tt></b>s to file.  Several Unix systems support them.
Nevertheless, I'm going to ignore them throughout this document,
preferring instead to talk solely about advisory locks.  With an
advisory lock system, processes can still read and write from a file
while it's locked.  Useless?  Not quite, since there is a way for a
process to check for the existence of a lock before a read or write.
See, it's a kind of <i>cooperative</i> locking system.  This is
easily sufficient for almost all cases where file locking is
necessary.</p>

<p>Since that's out of the way, whenever I refer to a lock from now on
in this document, I'm referring to advisory locks.  So there.</p>

<p>Now, let me break down the concept of a lock a little bit more.
There are two types of (advisory!) locks: read locks and write locks
(also referred to as shared locks and exclusive locks, respectively.)
The way read locks work is that they don't interfere with other read
locks.  For instance, multiple processes can have a file locked for
reading at the same.  However, when a process has an write lock on a
file, no other process can activate either a read or write lock until it
is relinquished.  One easy way to think of this is that there can be
multiple readers simultaneously, but there can only be one writer at a
time.</p>

<p>One last thing before beginning: there are many ways to lock files in
Unix systems.  System V likes <b><tt class="func">lockf()</tt></b>, which, personally, I
think sucks.  Better systems support <b><tt class="func">flock()</tt></b> which offers
better control over the lock, but still lacks in certain ways.  For
portability and for completeness, I'll be talking about how to lock
files using <b><tt class="func">fcntl()</tt></b>.  I encourage you, though, to use one
of the higher-level <b><tt class="func">flock()</tt></b>-style functions if it suits
your needs, but I want to portably demonstrate the full range of power
you have at your fingertips.  (If your System V Unix doesn't support the
POSIX-y <b><tt class="func">fcntl()</tt></b>, you'll have to reconcile the following
information with your <b><tt class="func">lockf()</tt></b> man page.)</p>



<h3 class="sect2title">6.1. <a name="flockset">Setting a lock</a></h3>


<p>The <b><tt class="func">fcntl()</tt></b> function does just about everything on the
planet, but we'll just use it for file locking.  Setting the lock
consists of filling out a <nobr><nobr><tt class="type">struct flock</tt></nobr></nobr>
(declared in <i><tt class="var">fcntl.h</tt></i>) that describes the type of lock
needed, <b><tt class="func">open()</tt></b>ing the file with the matching mode, and
calling <b><tt class="func">fcntl()</tt></b> with the proper arguments, <i>comme
ça</i>:</p>

<pre class="code">struct flock fl;
int fd;
    
fl.l_type   = F_WRLCK;  /* F_RDLCK, F_WRLCK, F_UNLCK    */
fl.l_whence = SEEK_SET; /* SEEK_SET, SEEK_CUR, SEEK_END */
fl.l_start  = 0;        /* Offset from l_whence         */
fl.l_len    = 0;        /* length, 0 = to EOF           */
fl.l_pid    = getpid(); /* our PID                      */

fd = open("filename", O_WRONLY);

fcntl(fd, F_SETLKW, &amp;fl);  /* F_GETLK, F_SETLK, F_SETLKW */</pre>


<p>What just happened?  Let's start with the <nobr><nobr><tt class="type">struct
flock</tt></nobr></nobr> since the fields in it are used to
<i>describe</i> the locking action taking place.  Here are some
field definitions:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="20%%"><i><tt class="var">l_type</tt></i></td>

<td valign="top" align="left" width="80%%">This is where you signify the type of lock you want to set.  It's
either <tt class="const">F_RDLCK</tt>, <tt class="const">F_WRLCK</tt>, or
<tt class="const">F_UNLCK</tt> if you want to set a read lock, write lock, or
clear the lock, respectively.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">l_whence</tt></i></td>

<td valign="top" align="left">This field determines where the <i><tt class="var">l_start</tt></i> field starts from
(it's like an offset for the offset).  It can be either
<tt class="const">SEEK_SET</tt>, <tt class="const">SEEK_CUR</tt>, or
<tt class="const">SEEK_END</tt>, for beginning of file, current file position,
or end of file.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">l_start</tt></i></td>

<td valign="top" align="left">This is the starting offset in bytes of the lock, relative to
<i><tt class="var">l_whence</tt></i>.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">l_len</tt></i></td>

<td valign="top" align="left">This is the length of the lock region in bytes (which starts from
<i><tt class="var">l_start</tt></i> which is relative to <i><tt class="var">l_whence</tt></i>.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">l_pid</tt></i></td>

<td valign="top" align="left">The process ID of the process dealing with the lock.  Use
<b><tt class="func">getpid()</tt></b> to get this.</td>
</tr>


</table></center>


<p>In our example, we told it make a lock of type <tt class="const">F_WRLCK</tt>
(a write lock), starting relative to <tt class="const">SEEK_SET</tt> (the
beginning of the file), offset <tt class="const">0</tt>, length <tt class="const">0</tt>
(a zero value means "lock to end-of-file), with the PID set to
<b><tt class="func">getpid()</tt></b>.</p>

<p>The next step is to <b><tt class="func">open()</tt></b> the file, since
<b><tt class="func">flock()</tt></b> needs a file descriptor of the file that's being
locked.  Note that when you open the file, you need to open it in the
same <i>mode</i> as you have specified in the lock, as shown in the
table, below.  If you open the file in the wrong mode for a given lock
type, <b><tt class="func">fcntl()</tt></b> will return <tt class="const">-1</tt> and
<i><tt class="var">errno</tt></i> will be set to <tt class="const">EBADF</tt>.</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="30%%"><b><u><i><tt class="var">l_type</tt></i></u></b></td>
<td valign="top" align="left" width="70%%"><b><u>mode</u></b></td>
</tr>

<tr><td valign="top" align="left"><tt class="const">F_RDLCK</tt></td>

<td valign="top" align="left"><tt class="const">O_RDONLY</tt> or <tt class="const">O_RDWR</tt></td>
</tr>


<tr><td valign="top" align="left"><tt class="const">F_WRLCK</tt></td>

<td valign="top" align="left"><tt class="const">O_WRONLY</tt> or <tt class="const">O_RDWR</tt></td>
</tr>


</table></center>



<p>Finally, the call to <b><tt class="func">fcntl()</tt></b> actually sets, clears, or
gets the lock.  See, the second argument (the <i><tt class="var">cmd</tt></i>) to
<b><tt class="func">fcntl()</tt></b> tells it what to do with the data passed to it in
the <nobr><nobr><tt class="type">struct flock</tt></nobr></nobr>.  The following list
summarizes what each <b><tt class="func">fcntl()</tt></b> <i><tt class="var">cmd</tt></i> does:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="15%%"><tt class="const">F_SETLKW</tt></td>

<td valign="top" align="left" width="85%%">This argument tells <b><tt class="func">fcntl()</tt></b> to attempt to
obtain the lock requested in the <nobr><nobr><tt class="type">struct flock</tt></nobr></nobr>
structure.  If the lock cannot be obtained (since someone else has it
locked already), <b><tt class="func">fcntl()</tt></b> will wait (block) until the lock
has cleared, then will set it itself.  This is a very useful command.  I
use it all the time.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">F_SETLK</tt></td>

<td valign="top" align="left">This function is almost identical to <tt class="const">F_SETLKW</tt>.  The
only difference is that this one will not wait if it cannot obtain a
lock.  It will return immediately with <tt class="const">-1</tt>.  This function
can be used to clear a lock by setting the <i><tt class="var">l_type</tt></i> field in
the <nobr><nobr><tt class="type">struct flock</tt></nobr></nobr> to
<tt class="const">F_UNLCK</tt>.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">F_GETLK</tt></td>

<td valign="top" align="left">If you want to only check to see if there is a lock, but don't want
to set one, you can use this command.  It looks through all the file
locks until it finds one that conflicts with the lock you specified in
the <nobr><nobr><tt class="type">struct flock</tt></nobr></nobr>.  It then copies the
conflicting lock's information into the <nobr><tt class="type">struct</tt></nobr> and returns
it to you.  If it can't find a conflicting lock, <b><tt class="func">fcntl()</tt></b>
returns the <nobr><tt class="type">struct</tt></nobr> as you passed it, except it sets the
<i><tt class="var">l_type</tt></i> field to <tt class="const">F_UNLCK</tt>.</td>
</tr>


</table></center>


<p>In our above example, we call <b><tt class="func">fcntl()</tt></b> with
<tt class="const">F_SETLKW</tt> as the argument, so it blocks until it can set
the lock, then sets it and continues.</p>





<h3 class="sect2title">6.2. <a name="flockclear">Clearing a lock</a></h3>


<p>Whew!  After all the locking stuff up there, it's time for something
easy: unlocking!  Actually, this is a piece of cake in comparison.  I'll
just reuse that first example and add the code to unlock it at the
end:</p>

<pre class="code">
struct flock fl;
int fd;

fl.l_type   = F_WRLCK;  /* F_RDLCK, F_WRLCK, F_UNLCK    */
fl.l_whence = SEEK_SET; /* SEEK_SET, SEEK_CUR, SEEK_END */
fl.l_start  = 0;        /* Offset from l_whence         */
fl.l_len    = 0;        /* length, 0 = to EOF           */
fl.l_pid    = getpid(); /* our PID                      */

fd = open("filename", O_WRONLY);  /* get the file descriptor */
fcntl(fd, F_SETLKW, &amp;fl);  /* set the lock, waiting if necessary */
.
.
.
fl.l_type   = <b>F_UNLCK</b>;  /* tell it to unlock the region */
fcntl(fd, F_SETLK, &amp;fl); /* set the region to unlocked */</pre>


<p>Now, I left the old locking code in there for high contrast, but you
can tell that I just changed the <i><tt class="var">l_type</tt></i> field to
<tt class="const">F_UNLCK</tt> (leaving the others completely unchanged!) and
called <b><tt class="func">fcntl()</tt></b> with <tt class="const">F_SETLK</tt> as the command.
Easy!</p>





<h3 class="sect2title">6.3. <a name="flockdemo">A demo program</a></h3>


<p>Here, I will include a demo program, <i><tt class="var">lockdemo.c</tt></i>, that
waits for the user to hit return, then locks its own source, waits for
another return, then unlocks it.  By running this program in two (or
more) windows, you can see how programs interact while waiting for
locks.</p>

<p>Basically, usage is this: if you run <b class="com">lockdemo</b> with no
command line arguments, it tries to grab a write lock
(<tt class="const">F_WRLCK</tt>) on its source (<i><tt class="var">lockdemo.c</tt></i>).  If
you start it with any command line arguments at all, it tries to get a
read lock (<tt class="const">F_RDLCK</tt>) on it.</p>

<p><a href="http://beej.us/guide/bgipc/examples/lockdemo.c" target="_blank">Here's the source</a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[])
{
                    /* l_type   l_whence  l_start  l_len  l_pid   */
    struct flock fl = {F_WRLCK, SEEK_SET,   0,      0,     0 };
    int fd;

    fl.l_pid = getpid();

    if (argc &gt; 1) 
        fl.l_type = F_RDLCK;

    if ((fd = open("lockdemo.c", O_RDWR)) == -1) {
        perror("open");
        exit(1);
    }

    printf("Press &lt;RETURN&gt; to try to get lock: ");
    getchar();
    printf("Trying to get lock...");

    if (fcntl(fd, F_SETLKW, &amp;fl) == -1) {
        perror("fcntl");
        exit(1);
    }

    printf("got lock\n");
    printf("Press &lt;RETURN&gt; to release lock: ");
    getchar();

    fl.l_type = F_UNLCK;  /* set to unlock same region */

    if (fcntl(fd, F_SETLK, &amp;fl) == -1) {
        perror("fcntl");
        exit(1);
    }

    printf("Unlocked.\n");

    close(fd);

    return 0;
}</pre>


<p>Compile that puppy up and start messing with it in a couple windows.
Notice that when one <b class="com">lockdemo</b> has a read lock, other
instances of the program can get their own read locks with no problem.
It's only when a write lock is obtained that other processes can't get a
lock of any kind.</p>

<p>Another thing to notice is that you can't get a write lock if there
are any read locks on the same region of the file.  The process waiting
to get the write lock will wait until all the read locks are cleared.
One upshot of this is that you can keep piling on read locks (because a
read lock doesn't stop other processes from getting read locks) and any
processes waiting for a write lock will sit there and starve.  There
isn't a rule anywhere that keeps you from adding more read locks if
there is a process waiting for a write lock.  You must be careful.</p>

<p>Practically, though, you will probably mostly be using write locks to
guarantee exclusive access to a file for a short amount of time while
it's being updated; that is the most common use of locks as far as I've
seen.  And I've seen them all...well, I've seen one...a small one...a
picture—well, I've heard about them.</p>





<h3 class="sect2title">6.4. <a name="flocksum">Summary</a></h3>


<p>Locks rule.  Sometimes, though, you might need more control over your
processes in a producer-consumer situation.  For this reason, if no
other, you should see the document on System V <a href="#semaphores">semaphores</a> if your system supports such a
beast.  They provide a more extensive and at least equally function
equivalent to file locks.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">7. <a name="mq">Message Queues</a></h2><hr class="mainsecthr"/>


<p>Those people who brought us System V have seen fit to include some
IPC goodies that have been implemented on various platforms (including
Linux, of course.)  This document describes the usage and functionality
of the extremely groovy System V Message Queues!</p>

<p>As usual, I want to spew some overview at you before getting into the
nitty-gritty.  A message queue works kind of like a <a href="#fifos">FIFO</a>, but supports some additional functionality.
Generally, see, messages are taken off the queue in the order they are
put on.  Specifically, however, there are ways to pull certain messages
out of the queue before they reach the front.  It's like cutting in
line.  (Incidentally, don't try to cut in line while visiting the Great
America amusement park in Silicon Valley, as you can be arrested for it.
They take cutting <i>very</i> seriously down there.)</p>

<p>In terms of usage, a process can create a new message queue, or it can
connect to an existing one.  In this, the latter, way two processes can
exchange information through the same message queue.  Score.</p>

<p>One more thing about System V IPC: when you create a message queue,
it doesn't go away until you destroy it.  All the processes that have
ever used it can quit, but the queue will still exist.  A good practice
is to use the <b class="com">ipcs</b> command to check if any of your unused
message queues are just floating around out there.  You can destroy them
with the <b class="com">ipcrm</b> command, which is preferable to getting a
visit from the sysadmin telling you that you've grabbed every available
message queue on the system.</p>




<h3 class="sect2title">7.1. <a name="mqwhere">Where's my queue?</a></h3>


<p>Let's get something going!  First of all, you want to connect to a
queue, or create it if it doesn't exist.  The call to accomplish this is
the <b><tt class="func">msgget()</tt></b> system call:</p>

<pre class="code">int msgget(key_t <i><tt class="var em1">key</tt></i>, int <i><tt class="var em1">msgflg</tt></i>);</pre>


<p><b><tt class="func">msgget()</tt></b> returns the message queue ID on success, or
<tt class="const">-1</tt> on failure (and it sets <i><tt class="var">errno</tt></i>, of
course.)</p>

<p>The arguments are a little weird, but can be understood with a little
brow-beating.  The first, <i><tt class="var">key</tt></i> is a system-wide unique
identifier describing the queue you want to connect to (or create).
Every other process that wants to connect to this queue will have to use
the same <i><tt class="var">key</tt></i>.</p>

<p>The other argument, <i><tt class="var">msgflg</tt></i> tells <b><tt class="func">msgget()</tt></b>
what to do with queue in question.  To create a queue, this field must
be set equal to <tt class="const">IPC_CREAT</tt> bit-wise OR'd with the
permissions for this queue.  (The queue permissions are the same as
standard file permissions—queues take on the user-id and group-id
of the program that created them.)</p>

<p>A sample call is given in the following section.</p>





<h3 class="sect2title">7.2. <a name="mqftok">"Are you the Key Master?"</a></h3>


<p>What about this <i><tt class="var">key</tt></i> nonsense?  How do we create one?
Well, since the type <nobr><tt class="type">key_t</tt></nobr> is actually just a
<nobr><tt class="type">long</tt></nobr>, you can use any number you want.  But what if you
hard-code the number and some other unrelated program hardcodes the same
number but wants another queue?  The solution is to use the
<b><tt class="func">ftok()</tt></b> function which generates a key from two
arguments:</p>

<pre class="code">key_t ftok(const char *<i><tt class="var em1">path</tt></i>, int <i><tt class="var em1">id</tt></i>);</pre>


<p>Ok, this is getting weird.  Basically, <i><tt class="var">path</tt></i> just has
to be a file that this process can read.  The other argument,
<i><tt class="var">id</tt></i> is usually just set to some arbitrary char, like 'A'.
The <b><tt class="func">ftok()</tt></b> function uses information about the named file
(like inode number, etc.) and the <i><tt class="var">id</tt></i> to generate a
probably-unique <i><tt class="var">key</tt></i> for <b><tt class="func">msgget()</tt></b>.  Programs
that want to use the same queue must generate the same
<i><tt class="var">key</tt></i>, so they must pass the same parameters to
<b><tt class="func">ftok()</tt></b>.</p>

<p>Finally, it's time to make the call:</p>

<pre class="code">
#include &lt;sys/msg.h&gt;

key = ftok("/home/beej/somefile", 'b');
msqid = msgget(key, 0666 | IPC_CREAT);
</pre>


<p>In the above example, I set the permissions on the queue to
<tt class="tt">666</tt> (or <tt class="tt">rw-rw-rw-</tt>, if that makes more sense to you).
And now we have <i><tt class="var">msqid</tt></i> which will be used to send and receive
messages from the queue.</p>





<h3 class="sect2title">7.3. <a name="mqsend">Sending to the queue</a></h3>


<p>Once you've connected to the message queue using <b><tt class="func">msgget()</tt></b>,
you are ready to send and receive messages.  First, the sending:</p>

<p>Each message is made up of two parts, which are defined in the template
structure <nobr><tt class="type">struct msgbuf</tt></nobr>, as defined in
<i><tt class="var">sys/msg.h</tt></i>:</p>

<pre class="code">struct msgbuf {
    long mtype;
    char mtext[1];
};</pre>


<p>The field <i><tt class="var">mtype</tt></i> is used later when retrieving messages
from the queue, and can be set to any positive number.  <i><tt class="var">mtext</tt></i>
is the data this will be added to the queue.</p>

<p>"What?!  You can only put one byte arrays onto a message queue?!
Worthless!!"  Well, not exactly.  You can use any structure you want to
put messages on the queue, as long as the first element is a long.  For
instance, we could use this structure to store all kinds of goodies:</p>

<pre class="code">struct pirate_msgbuf {
    long mtype;  /* must be positive */
    struct pirate_info {
        char name[30];
        char ship_type;
        int notoriety;
        int cruelty;
        int booty_value;
    } info;
};</pre>


<p>Ok, so how do we pass this information to a message queue?  The answer
is simple, my friends: just use <b><tt class="func">msgsnd()</tt></b>:</p>

<pre class="code">int msgsnd(int <i><tt class="var em1">msqid</tt></i>, const void *<i><tt class="var em1">msgp</tt></i>,
           size_t <i><tt class="var em1">msgsz</tt></i>, int <i><tt class="var em1">msgflg</tt></i>);</pre>


<p><i><tt class="var">msqid</tt></i> is the message queue identifier returned by
<b><tt class="func">msgget()</tt></b>.  The pointer <i><tt class="var">msgp</tt></i> is a pointer to
the data you want to put on the queue.  <i><tt class="var">msgsz</tt></i> is the size
in bytes of the data to add to the queue (not counting the size of the
<i><tt class="var">mtype</tt></i> member).  Finally, <i><tt class="var">msgflg</tt></i> allows you to
set some optional flag parameters, which we'll ignore for now by setting
it to <tt class="const">0</tt>.</p>

<p>When to get the size of the data to send, just subtract the
<b><tt class="func">sizeof(long)</tt></b> (the <i><tt class="var">mtype</tt></i>) from the
<b><tt class="func">sizeof()</tt></b> the whole message buffer structure:</p>

<pre class="code">struct cheese_msgbuf {
    long mtype;
    char name[20];
    int type;
    float yumminess;
};

/* calculate the size of the data to send: */

int size = sizeof(struct cheese_msgbuf) - sizeof(long);</pre>


<p>(Or if the payload is a simple <nobr><tt class="type">char[]</tt></nobr>, you can use the
length of the data as the message size.)</p>

<p>And here is a code snippet that shows one of our pirate structures
being added to the message queue:</p>

<pre class="code">#include &lt;sys/msg.h&gt;
#include &lt;stddef.h&gt;

key_t key;
int msqid;
struct pirate_msgbuf pmb = {2, { "L'Olonais", 'S', 80, 10, 12035 } };

key = ftok("/home/beej/somefile", 'b');
msqid = msgget(key, 0666 | IPC_CREAT);

/* stick him on the queue */
msgsnd(msqid, &amp;pmb, sizeof(struct pirate_msgbuf) - sizeof(long), 0);</pre>


<p>Aside from remembering to error-check the return values from all
these functions, this is all there is to it.  Oh, yeah: note that I
arbitrarily set the <i><tt class="var">mtype</tt></i> field to <tt class="const">2</tt> up there.
That'll be important in the next section.</p>





<h3 class="sect2title">7.4. <a name="mqrece">Receiving from the queue</a></h3>


<p>Now that we have the dreaded pirate <a href="http://beej.us/pirates/pirate_view.php?file=lolonais.jpg" target="_blank">Francis
L'Olonais</a> stuck in our message queue, how do we get him out?  As
you can imagine, there is a counterpart to <b><tt class="func">msgsnd()</tt></b>: it is
<b><tt class="func">msgrcv()</tt></b>.  How imaginative.</p>

<p>A call to <b><tt class="func">msgrcv()</tt></b> that would do it looks something like
this:</p>

<pre class="code">#include &lt;sys/msg.h&gt;
#include &lt;stddef.h&gt;

key_t key;
int msqid;
struct pirate_msgbuf pmb; /* where L'Olonais is to be kept */

key = ftok("/home/beej/somefile", 'b');
msqid = msgget(key, 0666 | IPC_CREAT);

/* get him off the queue! */
msgrcv(msqid, &amp;pmb, sizeof(struct pirate_msgbuf) - sizeof(long), 2, 0);</pre>


<p>There is something new to note in the <b><tt class="func">msgrcv()</tt></b> call: the
<tt class="const">2</tt>!  What does it mean?  Here's the synopsis of the
call:</p>

<pre class="code">
int msgrcv(int <i><tt class="var em1">msqid</tt></i>, void *<i><tt class="var em1">msgp</tt></i>, size_t <i><tt class="var em1">msgsz</tt></i>,
           long <i><tt class="var em1">msgtyp</tt></i>, int <i><tt class="var em1">msgflg</tt></i>);</pre>


<p>The <tt class="const">2</tt> we specified in the call is the requested
<i><tt class="var">msgtyp</tt></i>.  Recall that we set the <i><tt class="var">mtype</tt></i>
arbitrarily to <tt class="const">2</tt> in the <b><tt class="func">msgsnd()</tt></b> section of
this document, so that will be the one that is retrieved from the
queue.</p>

<p>Actually, the behavior of <b><tt class="func">msgrcv()</tt></b> can be modified
drastically by choosing a <i><tt class="var">msgtyp</tt></i> that is positive,
negative, or zero:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="20%%"><b><u><i><tt class="var">msgtyp</tt></i></u></b></td>

<td valign="top" align="left" width="80%%"><b><u>Effect on <b><tt class="func">msgrcv()</tt></b></u></b></td>
</tr>


<tr><td valign="top" align="left">Zero</td>

<td valign="top" align="left">Retrieve the next message on the queue, regardless of its
<i><tt class="var">mtype</tt></i>.</td>
</tr>


<tr><td valign="top" align="left">Positive</td>

<td valign="top" align="left">Get the next message with an <i><tt class="var">mtype</tt></i>
<i>equal to</i> the specified <i><tt class="var">msgtyp</tt></i>.</td>
</tr>


<tr><td valign="top" align="left">Negative</td>

<td valign="top" align="left">Retrieve the first message on the queue whose <i><tt class="var">mtype</tt></i> field
is less than or equal to the absolute value of the <i><tt class="var">msgtyp</tt></i>
argument.</td>
</tr>


</table></center>



<p>So, what will often be the case is that you'll simply want the next
message on the queue, no matter what <i><tt class="var">mtype</tt></i> it is.  As such,
you'd set the <i><tt class="var">msgtyp</tt></i> parameter to <tt class="const">0</tt>.</p>





<h3 class="sect2title">7.5. <a name="mqdest">Destroying a message queue</a></h3>


<p>There comes a time when you have to destroy a message queue.  Like I
said before, they will stick around until you explicitly remove them; it
is important that you do this so you don't waste system resources.  Ok,
so you've been using this message queue all day, and it's getting old.
You want to obliterate it.  There are two ways:</p>

<ol>

<li>Use the Unix command <b class="com">ipcs</b> to get a list of defined
message queues, then use the command <b class="com">ipcrm</b> to delete the
queue.</li>


<li>Write a program to do it for you.</li>


</ol>


<p>Often, the latter choice is the most appropriate, since you might
want your program to clean up the queue at some time or another.  To do
this requires the introduction of another function:
<b><tt class="func">msgctl()</tt></b>.</p>

<p>The synopsis of <b><tt class="func">msgctl()</tt></b> is:</p>

<pre class="code">int msgctl(int <i><tt class="var em1">msqid</tt></i>, int <i><tt class="var em1">cmd</tt></i>,
           struct msqid_ds *<i><tt class="var em1">buf</tt></i>);</pre>


<p>Of course, <i><tt class="var">msqid</tt></i> is the queue identifier obtained from
<b><tt class="func">msgget()</tt></b>.  The important argument is <i><tt class="var">cmd</tt></i>
which tells <b><tt class="func">msgctl()</tt></b> how to behave.  It can be a variety of
things, but we're only going to talk about <tt class="const">IPC_RMID</tt>,
which is used to remove the message queue.  The <i><tt class="var">buf</tt></i>
argument can be set to <tt class="const">NULL</tt> for the purposes of
<tt class="const">IPC_RMID</tt>.</p>

<p>Say that we have the queue we created above to hold the pirates.  You
can destroy that queue by issuing the following call:</p>

<pre class="code">#include &lt;sys/msg.h&gt;
.
.
msgctl(msqid, IPC_RMID, NULL);</pre>


<p>And the message queue is no more.</p>









<h3 class="sect2title">7.6. <a name="mqsamp">Sample programs, anyone?</a></h3>


<p>For the sake of completeness, I'll include a brace of programs that
will communicate using message queues.  The first, <i><tt class="var">kirk.c</tt></i>
adds messages to the message queue, and <i><tt class="var">spock.c</tt></i> retrieves
them.</p>

<p>Here is the source for <a href="http://beej.us/guide/bgipc/examples/kirk.c" target="_blank">kirk.c</a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

struct my_msgbuf {
    long mtype;
    char mtext[200];
};

int main(void)
{
    struct my_msgbuf buf;
    int msqid;
    key_t key;

    if ((key = ftok("kirk.c", 'B')) == -1) {
        perror("ftok");
        exit(1);
    }

    if ((msqid = msgget(key, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
    
    printf("Enter lines of text, ^D to quit:\n");

    buf.mtype = 1; /* we don't really care in this case */

    while(fgets(buf.mtext, sizeof buf.mtext, stdin) != NULL) {
        int len = strlen(buf.mtext);

        /* ditch newline at end, if it exists */
        if (buf.mtext[len-1] == '\n') buf.mtext[len-1] = '\0';

        if (msgsnd(msqid, &amp;buf, len+1, 0) == -1) /* +1 for '\0' */
            perror("msgsnd");
    }

    if (msgctl(msqid, IPC_RMID, NULL) == -1) {
        perror("msgctl");
        exit(1);
    }

    return 0;
}</pre>


<p>The way <b class="com">kirk</b> works is that it allows you to enter lines of
text.  Each line is bundled into a message and added to the message
queue.  The message queue is then read by <b class="com">spock</b>.</p>

<p>Here is the source for <a href="http://beej.us/guide/bgipc/examples/spock.c" target="_blank">spock.c</a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

struct my_msgbuf {
    long mtype;
    char mtext[200];
};

int main(void)
{
    struct my_msgbuf buf;
    int msqid;
    key_t key;

    if ((key = ftok("kirk.c", 'B')) == -1) {  /* same key as kirk.c */
        perror("ftok");
        exit(1);
    }

    if ((msqid = msgget(key, 0644)) == -1) { /* connect to the queue */
        perror("msgget");
        exit(1);
    }
    
    printf("spock: ready to receive messages, captain.\n");

    for(;;) { /* Spock never quits! */
        if (msgrcv(msqid, &amp;buf, sizeof(buf.mtext), 0, 0) == -1) {
            perror("msgrcv");
            exit(1);
        }
        printf("spock: \"%s\"\n", buf.mtext);
    }

    return 0;
}</pre>


<p>Notice that <b class="com">spock</b>, in the call to <b><tt class="func">msgget()</tt></b>,
doesn't include the <tt class="const">IPC_CREAT</tt> option.  We've left it up
to <b class="com">kirk</b> to create the message queue, and <b class="com">spock</b>
will return an error if he hasn't done so.</p>

<p>Notice what happens when you're running both in separate windows and
you kill one or the other.  Also try running two copies of
<b class="com">kirk</b> or two copies of <b class="com">spock</b> to get an idea of what
happens when you have two readers or two writers.  Another interesting
demonstration is to run <b class="com">kirk</b>, enter a bunch of messages, then
run <b class="com">spock</b> and see it retrieve all the messages in one swoop.
Just messing around with these toy programs will help you gain an
understanding of what is really going on.</p>





<h3 class="sect2title">7.7. <a name="mqsum">Summary</a></h3>


<p>There is more to message queues than this short tutorial can present.
Be sure to look in the man pages to see what else you can do, especially
in the area of <b><tt class="func">msgctl()</tt></b>.  Also, there are more options you
can pass to other functions to control how <b><tt class="func">msgsnd()</tt></b> and
<b><tt class="func">msgrcv()</tt></b> handle if the queue is full or empty,
respectively.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">8. <a name="semaphores">Semaphores</a></h2><hr class="mainsecthr"/>


<p>Remember <a href="#flocking">file locking</a>?  Well, semaphores
can be thought of as really generic advisory locking mechanisms.  You
can use them to control access to files, <a href="#shm">shared
memory</a>, and, well, just about anything you want.  The basic
functionality of a semaphore is that you can either set it, check it, or
wait until it clears then set it ("test-n-set").  No matter how complex
the stuff that follows gets, remember those three operations.</p>

<p>This document will provide an overview of semaphore functionality,
and will end with a program that uses semaphores to control access to a
file.  (This task, admittedly, could easily be handled with file
locking, but it makes a good example since it's easier to wrap your head
around than, say, shared memory.)</p>







<h3 class="sect2title">8.1. <a name="semgrab">Grabbing some semaphores</a></h3>


<p>With System V IPC, you don't grab single semaphores; you grab
<i>sets</i> of semaphores.  You can, of course, grab a semaphore set
that only has one semaphore in it, but the point is you can have a whole
slew of semaphores just by creating a single semaphore set.</p>

<p>How do you create the semaphore set?  It's done with a call to
<b><tt class="func">semget()</tt></b>, which returns the semaphore id (hereafter referred to
as the <i><tt class="var">semid</tt></i>):</p>

<pre class="code">#include &lt;sys/sem.h&gt;

int semget(key_t <i><tt class="var em1">key</tt></i>, int <i><tt class="var em1">nsems</tt></i>, int <i><tt class="var em1">semflg</tt></i>);</pre>


<p>What's the <i><tt class="var">key</tt></i>?  It's a unique identifier that is used
by different processes to identify this semaphore set.  (This
<i><tt class="var">key</tt></i> will be generated using <b><tt class="func">ftok()</tt></b>,
described in the <a href="#mqftok">Message Queues section</a>.)</p>

<p>The next argument, <i><tt class="var">nsems</tt></i>, is (you guessed it!) the
number of semaphores in this semaphore set.  The exact number is system
dependent, but it's probably between 500 and 2000.  If you're needing
more (greedy wretch!), just get another semaphore set.</p>

<p>Finally, there's the <i><tt class="var">semflg</tt></i> argument.  This tells
<b><tt class="func">semget()</tt></b> what the permissions should be on the new semaphore
set, whether you're creating a new set or just want to connect to an
existing one, and other things that you can look up.  For creating a new
set, you can bit-wise or the access permissions with
<tt class="const">IPC_CREAT</tt>.</p>

<p>Here's an example call that generates the <i><tt class="var">key</tt></i> with
<b><tt class="func">ftok()</tt></b> and creates a 10 semaphore set, with 666
(<tt class="tt">rw-rw-rw-</tt>) permissions:</p>

<pre class="code">#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;

key_t key;
int semid;

key = ftok("/home/beej/somefile", 'E');
semid = semget(key, 10, 0666 | IPC_CREAT);</pre>


<p>Congrats!  You've created a new semaphore set!  After running the
program you can check it out with the <b class="com">ipcs</b> command.  (Don't
forget to remove it when you're done with it with <b class="com">ipcrm</b>!)</p>

<p>Wait!  Warning!  <i>¡Advertencia! ¡No pongas las
manos en la tolva!</i>  (That's the only Spanish I learned while
working at Pizza Hut in 1990.  It was printed on the dough roller.)
Look here:</p>

<p>When you first create some semaphores, they're all uninitialized; it
takes another call to mark them as free (namely to <b><tt class="func">semop()</tt></b>
or <b><tt class="func">semctl()</tt></b>—see the following sections.) What does
this mean?  Well, it means that creation of a semaphore is not
<i>atomic</i> (in other words, it's not a one-step process).  If two
processes are trying to create, initialize, and use a semaphore at the
same time, a race condition might develop.</p>

<p>One way to get around this difficulty is by having a single init
process that creates and initializes the semaphore long before the
main processes begin to run.  The main processes just access it, but
never create nor destroy it.</p>

<p>Stevens refers to this problem as the semaphore's "fatal flaw".  He
solves it by creating the semaphore set with the <tt class="const">IPC_EXCL</tt>
flag.  If process 1 creates it first, process 2 will return an error on
the call (with <i><tt class="var">errno</tt></i> set to <tt class="const">EEXIST</tt>.)  At that
point, process 2 will have to wait until the semaphore is initialized by
process 1.  How can it tell?  Turns out, it can repeatedly call
<b><tt class="func">semctl()</tt></b> with the <tt class="const">IPC_STAT</tt> flag, and look at
the <i><tt class="var">sem_otime</tt></i> member of the returned <nobr><tt class="type">struct
semid_ds</tt></nobr> structure.  If that's non-zero, it means process 1 has
performed an operation on the semaphore with <b><tt class="func">semop()</tt></b>,
presumably to initialize it.</p>

<p>For an example of this, see the demonstration program <a href="#semsamp"><i><tt class="var">semdemo.c</tt></i></a>, below, in which I
generally reimplement <a href="http://www.kohala.com/start/unpv22e/unpv22e.html" target="_blank">Stevens' code</a>.</p>

<p>In the meantime, let's hop to the next section and take a look at how
to initialize our freshly-minted semaphores.</p>









<h3 class="sect2title">8.2. <a name="semctl">Controlling your semaphores with <b><tt class="titlefunc">semctl()</tt></b></a></h3>


<p>Once you have created your semaphore sets, you have to initialize
them to a positive value to show that the resource is available to use.
The function <b><tt class="func">semctl()</tt></b> allows you to do atomic value changes
to individual semaphores or complete sets of semaphores.</p>

<pre class="code">int semctl(int <i><tt class="var em1">semid</tt></i>, int <i><tt class="var em1">semnum</tt></i>,
           int <i><tt class="var em1">cmd</tt></i>, ... /*<i><tt class="var em1">arg</tt></i>*/);</pre>


<p><i><tt class="var">semid</tt></i> is the semaphore set id that you get from your
call to <b><tt class="func">semget()</tt></b>, earlier.  <i><tt class="var">semnum</tt></i> is the ID
of the semaphore that you wish to manipulate the value of. 
<i><tt class="var">cmd</tt></i> is what you wish to do with the semaphore in
question.  The last "argument", "<i><tt class="var">arg</tt></i>", if required, needs
to be a <nobr><tt class="type">union semun</tt></nobr>, which will be defined by you in your
code to be one of these:</p>

<pre class="code">union semun {
    int val;               /* used for SETVAL only */
    struct semid_ds *buf;  /* used for IPC_STAT and IPC_SET */
    ushort *array;         /* used for GETALL and SETALL */
};</pre>


<p>The various fields in the <nobr><tt class="type">union semun</tt></nobr> are used depending
on the value of the <i><tt class="var">cmd</tt></i> parameter to
<b><tt class="func">setctl()</tt></b> (a partial list follows—see your local man
page for more):</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="20%%"><i><tt class="var"><b><u>cmd</u></b></tt></i></td>

<td valign="top" align="left" width="80%%"><b><u>Effect</u></b></td>
</tr>


<tr><td valign="top" align="left"><tt class="const">SETVAL</tt></td>

<td valign="top" align="left">Set the value of the specified semaphore to the value in the
<i><tt class="var">val</tt></i> member of the passed-in <nobr><tt class="type">union
semun</tt></nobr>.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">GETVAL</tt></td>

<td valign="top" align="left">Return the value of the given semaphore.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">SETALL</tt></td>

<td valign="top" align="left">Set the values of all the semaphores in the set to the values in the
array pointed to by the <i><tt class="var">array</tt></i> member of the passed-in
<nobr><tt class="type">union semun</tt></nobr>.  The <i><tt class="var">semnum</tt></i> parameter to
<b><tt class="func">semctl()</tt></b> isn't used.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">GETALL</tt></td>

<td valign="top" align="left">Gets the values of all the semaphores in the set and stores them in
the array pointed to by the <i><tt class="var">array</tt></i> member of the passed-in
<nobr><tt class="type">union semun</tt></nobr>.  The <i><tt class="var">semnum</tt></i> parameter to
<b><tt class="func">semctl()</tt></b> isn't used.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">IPC_RMID</tt></td>

<td valign="top" align="left">Remove the specified semaphore set from the system.  The
<i><tt class="var">semnum</tt></i> parameter is ignored.</td>
</tr>


<tr><td valign="top" align="left"><tt class="const">IPC_STAT</tt></td>

<td valign="top" align="left">Load status information about the semaphore set into the
<nobr><tt class="type">struct semid_ds</tt></nobr> structure pointed to by the <i><tt class="var">buf</tt></i>
member of the <nobr><tt class="type">union semun</tt></nobr>.</td>
</tr>


</table></center>


<p>For the curious, here are the contents of the <nobr><tt class="type">struct
semid_ds</tt></nobr> that is used in the <nobr><tt class="type">union semun</tt></nobr>:</p>

<pre class="code">struct semid_ds {
    struct ipc_perm sem_perm;  /* Ownership and permissions
    time_t          sem_otime; /* Last semop time */
    time_t          sem_ctime; /* Last change time */
    unsigned short  sem_nsems; /* No. of semaphores in set */
};</pre>


<p>We'll use that <i><tt class="var">sem_otime</tt></i> member later on when we write our
<b><tt class="func">initsem()</tt></b> in the sample code, below.</p>









<h3 class="sect2title">8.3. <a name="semop"><tt class="tt">semop()</tt>: Atomic power!</a></h3>


<p>All operations that set, get, or test-n-set a semaphore use the
<b><tt class="func">semop()</tt></b> system call.  This system call is general purpose,
and its functionality is dictated by a structure that is passed to it,
<nobr><nobr><tt class="type">struct sembuf</tt></nobr></nobr>:</p>

<pre class="code">/* Warning!  Members might not be in this order! */

struct sembuf {
    ushort sem_num;
    short sem_op;
    short sem_flg;
};</pre>


<p>Of course, <i><tt class="var">sem_num</tt></i> is the number of the semaphore in the
set that you want to manipulate.  Then, <i><tt class="var">sem_op</tt></i> is what you
want to do with that semaphore.  This takes on different meanings,
depending on whether <i><tt class="var">sem_op</tt></i> is positive, negative, or zero,
as shown in the following table:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="15%%"><b><u><i><tt class="var">sem_op</tt></i></u></b></td>

<td valign="top" align="left" width="85%%"><b><u>What happens</u></b></td>
</tr>


<tr><td valign="top" align="left">Negative</td>

<td valign="top" align="left">Allocate resources.  Block the calling process until the value of
the semaphore is greater than or equal to the absolute value of
<i><tt class="var">sem_op</tt></i>.  (That is, wait until enough resources have been
freed by other processes for this one to allocate.)  Then add
(effectively subtract, since it's negative) the value of
<i><tt class="var">sem_op</tt></i> to the semaphore's value.</td>
</tr>


<tr><td valign="top" align="left">Positive</td>

<td valign="top" align="left">Release resources.  The value of <i><tt class="var">sem_op</tt></i> is added to
the semaphore's value.</td>
</tr>


<tr><td valign="top" align="left">Zero</td>

<td valign="top" align="left">This process will wait until the semaphore in question reaches
0.</td>
</tr>


</table></center>



<p>So, basically, what you do is load up a <nobr><nobr><tt class="type">struct
sembuf</tt></nobr></nobr> with whatever values you want, then call
<b><tt class="func">semop()</tt></b>, like this:</p>

<pre class="code">int semop(int <i><tt class="var em1">semid</tt></i>, struct sembuf *<i><tt class="var em1">sops</tt></i>,
          unsigned int <i><tt class="var em1">nsops</tt></i>);</pre>


<p>The <i><tt class="var">semid</tt></i> argument is the number obtained from the
call to <b><tt class="func">semget()</tt></b>.  Next is <i><tt class="var">sops</tt></i>, which is a
pointer to the <nobr><nobr><tt class="type">struct sembuf</tt></nobr></nobr> that you filled
with your semaphore commands.  If you want, though, you can make an
array of <nobr><nobr><tt class="type">struct sembuf</tt></nobr></nobr>s in order to do a whole
bunch of semaphore operations at the same time.  The way
<b><tt class="func">semop()</tt></b> knows that you're doing this is the
<i><tt class="var">nsop</tt></i> argument, which tells how many <nobr><nobr><tt class="type">struct
sembuf</tt></nobr></nobr>s you're sending it.  If you only have one, well,
put <tt class="const">1</tt> as this argument.</p>

<p>One field in the <nobr><nobr><tt class="type">struct sembuf</tt></nobr></nobr> that I
haven't mentioned is the <i><tt class="var">sem_flg</tt></i> field which allows the
program to specify flags the further modify the effects of the
<b><tt class="func">semop()</tt></b> call.</p>

<p>One of these flags is <tt class="const">IPC_NOWAIT</tt> which, as the name
suggests, causes the call to <b><tt class="func">semop()</tt></b> to return with error
<tt class="const">EAGAIN</tt> if it encounters a situation where it would
normally block.  This is good for situations where you might want to
"poll" to see if you can allocate a resource.</p>

<p>Another very useful flag is the <tt class="const">SEM_UNDO</tt> flag.  This
causes <b><tt class="func">semop()</tt></b> to record, in a way, the change made to the
semaphore.  When the program exits, the kernel will automatically undo
all changes that were marked with the <tt class="const">SEM_UNDO</tt> flag.  Of
course, your program should do its best to deallocate any resources it
marks using the semaphore, but sometimes this isn't possible when your
program gets a <tt class="const">SIGKILL</tt> or some other awful crash
happens.</p>









<h3 class="sect2title">8.4. <a name="semdest">Destroying a semaphore</a></h3>


<p>There are two ways to get rid of a semaphore: one is to use the Unix
command <b class="com">ipcrm</b>.  The other is through a call to
<b><tt class="func">semctl()</tt></b> with the <i><tt class="var">cmd</tt></i> set to
<tt class="const">IPC_RMID</tt>.</p>

<p>Basically, you want to call <b><tt class="func">semctl()</tt></b> and set
<i><tt class="var">semid</tt></i> to the semaphore ID you want to axe.  The
<i><tt class="var">cmd</tt></i> should be set to <tt class="const">IPC_RMID</tt>, which tells
<b><tt class="func">semctl()</tt></b> to remove this semaphore set.  The parameter
<i><tt class="var">semnum</tt></i> has no meaning in the <tt class="const">IPC_RMID</tt>
context and can just be set to zero.</p>

<p>Here's an example call to torch a semaphore set:</p>

<pre class="code">int semid; 
.
.
semid = semget(...);
.
.
semctl(semid, 0, IPC_RMID);</pre>


<p>Easy peasy.</p>









<h3 class="sect2title">8.5. <a name="semsamp">Sample programs</a></h3>


<p>There are two of them.  The first, <i><tt class="var">semdemo.c</tt></i>, creates
the semaphore if necessary, and performs some pretend file locking on it
in a demo very much like that in the <a href="#flocking">File
Locking</a> document.  The second program, <i><tt class="var">semrm.c</tt></i> is
used to destroy the semaphore (again, <b class="com">ipcrm</b> could be used to
accomplish this.)</p>

<p>The idea is to run run <i><tt class="var">semdemo.c</tt></i> in a few windows and
see how all the processes interact.  When you're done, use
<i><tt class="var">semrm.c</tt></i> to remove the semaphore.  You could also try
removing the semaphore while running <i><tt class="var">semdemo.c</tt></i> just to see
what kinds of errors are generated.</p>

<p>Here's <a href="http://beej.us/guide/bgipc/examples/semdemo.c" target="_blank"><i><tt class="var">semdemo.c</tt></i></a>, including a
function named <b><tt class="func">initsem()</tt></b> that gets around the semaphore
race conditions, Stevens-style:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;

#define MAX_RETRIES 10

union semun {
    int val;
    struct semid_ds *buf;
    ushort *array;
};

/*
** initsem() -- more-than-inspired by W. Richard Stevens' UNIX Network
** Programming 2nd edition, volume 2, lockvsem.c, page 295.
*/
int initsem(key_t key, int nsems)  /* key from ftok() */
{
    int i;
    union semun arg;
    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);

    if (semid &gt;= 0) { /* we got it first */
        sb.sem_op = 1; sb.sem_flg = 0;
        arg.val = 1;

        printf("press return\n"); getchar();

        for(sb.sem_num = 0; sb.sem_num &lt; nsems; sb.sem_num++) { 
            /* do a semop() to "free" the semaphores. */
            /* this sets the sem_otime field, as needed below. */
            if (semop(semid, &amp;sb, 1) == -1) {
                int e = errno;
                semctl(semid, 0, IPC_RMID); /* clean up */
                errno = e;
                return -1; /* error, check errno */
            }
        }

    } else if (errno == EEXIST) { /* someone else got it first */
        int ready = 0;

        semid = semget(key, nsems, 0); /* get the id */
        if (semid &lt; 0) return semid; /* error, check errno */

        /* wait for other process to initialize the semaphore: */
        arg.buf = &amp;buf;
        for(i = 0; i &lt; MAX_RETRIES &amp;&amp; !ready; i++) {
            semctl(semid, nsems-1, IPC_STAT, arg);
            if (arg.buf-&gt;sem_otime != 0) {
                ready = 1;
            } else {
                sleep(1);
            }
        }
        if (!ready) {
            errno = ETIME;
            return -1;
        }
    } else {
        return semid; /* error, check errno */
    }

    return semid;
}

int main(void)
{
    key_t key;
    int semid;
    struct sembuf sb;
    
    sb.sem_num = 0;
    sb.sem_op = -1;  /* set to allocate resource */
    sb.sem_flg = SEM_UNDO;

    if ((key = ftok("semdemo.c", 'J')) == -1) {
        perror("ftok");
        exit(1);
    }

    /* grab the semaphore set created by seminit.c: */
    if ((semid = initsem(key, 1)) == -1) {
        perror("initsem");
        exit(1);
    }

    printf("Press return to lock: ");
    getchar();
    printf("Trying to lock...\n");

    if (semop(semid, &amp;sb, 1) == -1) {
        perror("semop");
        exit(1);
    }

    printf("Locked.\n");
    printf("Press return to unlock: ");
    getchar();

    sb.sem_op = 1; /* free resource */
    if (semop(semid, &amp;sb, 1) == -1) {
        perror("semop");
        exit(1);
    }

    printf("Unlocked\n");

    return 0;
}</pre>


<p>Here's <a href="http://beej.us/guide/bgipc/examples/semrm.c" target="_blank"><i><tt class="var">semrm.c</tt></i></a>
for removing the semaphore when you're done:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;

int main(void)
{
    key_t key;
    int semid;
    union semun arg;

    if ((key = ftok("semdemo.c", 'J')) == -1) {
        perror("ftok");
        exit(1);
    }

    /* grab the semaphore set created by seminit.c: */
    if ((semid = semget(key, 1, 0)) == -1) {
        perror("semget");
        exit(1);
    }

    /* remove it: */
    if (semctl(semid, 0, IPC_RMID, arg) == -1) {
        perror("semctl");
        exit(1);
    }

    return 0;
}</pre>


<p>Isn't that fun!  I'm sure you'll give up Quake just to play with this
semaphore stuff all day long!</p>









<h3 class="sect2title">8.6. <a name="semsum">Summary</a></h3>


<p>I might have understated the usefulness of semaphores.  I assure you,
they're very very very useful in a concurrency situation.  They're often
faster than regular file locks, too.  Also, you can use them on other
things that aren't files, such as <a href="#shm">Shared Memory
Segments</a>!  In fact, it is sometimes hard to live without them,
quite frankly.</p>

<p>Whenever you have multiple processes running through a critical
section of code, man, you need semaphores.  You have zillions of
them—you might as well use 'em.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">9. <a name="shm">Shared Memory Segments</a></h2><hr class="mainsecthr"/>


<p>The cool thing about shared memory segments is that they are what
they sound like: a segment of memory that is shared between processes.
I mean, think of the potential of this!  You could allocate a block a
player information for a multi-player game and have each process access
it at will!  Fun, fun, fun.</p>

<p>There are, as usual, more gotchas to watch out for, but it's all
pretty easy in the long run.  See, you just connect to the shared memory
segment, and get a pointer to the memory.  You can read and write to
this pointer and all changes you make will be visible to everyone else
connected to the segment.  There is nothing simpler.  Well, there is,
actually, but I was just trying to make you more comfortable.</p>



<h3 class="sect2title">9.1. <a name="shmcreat">Creating the segment and connecting</a></h3>


<p>Similarly to other forms of System V IPC, a shared memory segment is
created and connected to via the <b><tt class="func">shmget()</tt></b> call:</p>

<pre class="code">int shmget(key_t <i><tt class="var em1">key</tt></i>, size_t <i><tt class="var em1">size</tt></i>,
           int <i><tt class="var em1">shmflg</tt></i>);</pre>


<p>Upon successful completion, <b><tt class="func">shmget()</tt></b> returns an
identifier for the shared memory segment.  The <i><tt class="var">key</tt></i>
argument should be created the same was as shown in the <a href="#mqftok">Message Queues</a> document, using <b><tt class="func">ftok()</tt></b>.
The next argument, <i><tt class="var">size</tt></i>, is the size in bytes of the
shared memory segment.  Finally, the <i><tt class="var">shmflg</tt></i> should be set
to the permissions of the segment bitwise-ORd with
<tt class="const">IPC_CREAT</tt> if you want to create the segment, but can be
<tt class="const">0</tt> otherwise.  (It doesn't hurt to specify
<tt class="const">IPC_CREAT</tt> every time—it will simply connect you if
the segment already exists.)</p>

<p>Here's an example call that creates a 1K segment with <tt class="tt">644</tt>
permissions (<tt class="tt">rw-r--r--</tt>):</p>

<pre class="code">key_t key;
int shmid;

key = ftok("/home/beej/somefile3", 'R');
shmid = shmget(key, 1024, 0644 | IPC_CREAT);</pre>


<p>But how do you get a pointer to that data from the <i><tt class="var">shmid</tt></i>
handle?  The answer is in the call <b><tt class="func">shmat()</tt></b>, in the
following section.</p>





<h3 class="sect2title">9.2. <a name="shmat">Attach me—getting a pointer to the segment</a></h3>


<p>Before you can use a shared memory segment, you have to attach yourself
to it using the <b><tt class="func">shmat()</tt></b> call:</p>

<pre class="code">void *shmat(int <i><tt class="var em1">shmid</tt></i>, void *<i><tt class="var em1">shmaddr</tt></i>, int <i><tt class="var em1">shmflg</tt></i>);</pre>


<p>What does it all mean?  Well, <i><tt class="var">shmid</tt></i> is the shared
memory ID you got from the call to <b><tt class="func">shmget()</tt></b>.  Next is
<i><tt class="var">shmaddr</tt></i>, which you can use to tell <b><tt class="func">shmat()</tt></b>
which specific address to use but you should just set it to
<tt class="const">0</tt> and let the OS choose the address for you.  Finally,
the <i><tt class="var">shmflg</tt></i> can be set to <tt class="const">SHM_RDONLY</tt> if you
only want to read from it, <tt class="const">0</tt> otherwise.</p>

<p>Here's a more complete example of how to get a pointer to a shared
memory segment:</p>

<pre class="code">key_t key;
int shmid;
char *data;

key = ftok("/home/beej/somefile3", 'R');
shmid = shmget(key, 1024, 0644 | IPC_CREAT);
data = shmat(shmid, (void *)0, 0);</pre>


<p>And <i>bammo</i>!  You have the pointer to the shared memory
segment!  Notice that <b><tt class="func">shmat()</tt></b> returns a <nobr><tt class="type">void</tt></nobr>
pointer, and we're treating it, in this case, as a <nobr><tt class="type">char</tt></nobr>
pointer.  You can treat is as anything you like, depending on what kind
of data you have in there.  Pointers to arrays of structures are just as
acceptable as anything else.</p>

<p>Also, it's interesting to note that <b><tt class="func">shmat()</tt></b> returns
<tt class="const">-1</tt> on failure.  But how do you get <tt class="const">-1</tt> in a
<nobr><tt class="type">void</tt></nobr> pointer?  Just do a cast during the comparison to
check for errors:</p>

<pre class="code">data = shmat(shmid, (void *)0, 0);
if (data == (char *)(-1))
    perror("shmat");</pre>


<p>All you have to do now is change the data it points to normal
pointer-style. There are some samples in the next section.</p>





<h3 class="sect2title">9.3. <a name="shmrw">Reading and Writing</a></h3>


<p>Lets say you have the <i><tt class="var">data</tt></i> pointer from the above example.
It is a <nobr><tt class="type">char</tt></nobr> pointer, so we'll be reading and writing chars
from it.  Furthermore, for the sake of simplicity, lets say the 1K
shared memory segment contains a null-terminated string.</p>

<p>It couldn't be easier.  Since it's just a string in there, we can
print it like this:</p>

<pre class="code">printf("shared contents: %s\n", data);</pre>


<p>And we could store something in it as easily as this:</p>

<pre class="code">printf("Enter a string: ");
gets(data);</pre>


<p>Of course, like I said earlier, you can have other data in there
besides just <nobr><tt class="type">char</tt></nobr>s.  I'm just using them as an example.
I'll just make the assumption that you're familiar enough with pointers
in C that you'll be able to deal with whatever kind of data you stick in
there.</p>





<h3 class="sect2title">9.4. <a name="shmdet">Detaching from and deleting segments</a></h3>


<p>When you're done with the shared memory segment, your program should
detach itself from it using the <b><tt class="func">shmdt()</tt></b> call:</p>

<pre class="code">int shmdt(void *<i><tt class="var em1">shmaddr</tt></i>);</pre>


<p>The only argument, <i><tt class="var">shmaddr</tt></i>, is the address you got
from <b><tt class="func">shmat()</tt></b>.  The function returns <tt class="const">-1</tt> on
error, <tt class="const">0</tt> on success.</p>

<p>When you detach from the segment, it isn't destroyed.  Nor is it
removed when <i>everyone</i> detaches from it.  You have to
specifically destroy it using a call to <b><tt class="func">shmctl()</tt></b>, similar
to the control calls for the other System V IPC functions:</p>

<pre class="code">shmctl(shmid, IPC_RMID, NULL);</pre>


<p>The above call deletes the shared memory segment, assuming no one
else is attached to it.  The <b><tt class="func">shmctl()</tt></b> function does a lot
more than this, though, and it worth looking into.  (On your own, of
course, since this is only an overview!)</p>

<p>As always, you can destroy the shared memory segment from the command
line using the <b class="com">ipcrm</b> Unix command.  Also, be sure that you
don't leave any usused shared memory segments sitting around wasting
system resources.  All the System V IPC objects you own can be viewed
using the <b class="com">ipcs</b> command.</p>





<h3 class="sect2title">9.5. <a name="shmcon">Concurrency</a></h3>


<p>What are concurrency issues?  Well, since you have multiple processes
modifying the shared memory segment, it is possible that certain errors
could crop up when updates to the segment occur simultaneously.  This
<i>concurrent</i> access is almost always a problem when you have
multiple writers to a shared object.</p>

<p>The way to get around this is to use <a href="#semaphores">Semaphores</a> to lock the shared memory segment
while a process is writing to it.  (Sometimes the lock will encompass
both a read an write to the shared memory, depending on what you're
doing.)</p>

<p>A true discussion of concurrency is beyond the scope of this paper,
and you might want to check out the <a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29" target="_blank">Wikipedia
article on the matter</a>.  I'll just leave it with this: if you
start getting weird inconsistencies in your shared data when you connect
two or more processes to it, you could very well have a concurrency
problem.</p>





<h3 class="sect2title">9.6. <a name="shmsam">Sample code</a></h3>


<p>Now that I've primed you on all the dangers of concurrent access to a
shared memory segment without using semaphores, I'll show you a demo
that does just that.  Since this isn't a mission-critical application,
and it's unlikely that you'll be accessing the shared data at the same
time as any other process, I'll just leave the semaphores out for the
sake of simplicity.</p>

<p>This program does one of two things: if you run it with no command
line parameters, it prints the contents of the shared memory segment.
If you give it one command line parameter, it stores that parameter in
the shared memory segment.</p>

<p>Here's the code for <a href="http://beej.us/guide/bgipc/examples/shmdemo.c" target="_blank">shmdemo.c</a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

#define SHM_SIZE 1024  /* make it a 1K shared memory segment */

int main(int argc, char *argv[])
{
    key_t key;
    int shmid;
    char *data;
    int mode;

    if (argc &gt; 2) {
        fprintf(stderr, "usage: shmdemo [data_to_write]\n");
        exit(1);
    }

    /* make the key: */
    if ((key = ftok("shmdemo.c", 'R')) == -1) {
        perror("ftok");
        exit(1);
    }

    /* connect to (and possibly create) the segment: */
    if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) {
        perror("shmget");
        exit(1);
    }

    /* attach to the segment to get a pointer to it: */
    data = shmat(shmid, (void *)0, 0);
    if (data == (char *)(-1)) {
        perror("shmat");
        exit(1);
    }

    /* read or modify the segment, based on the command line: */
    if (argc == 2) {
        printf("writing to segment: \"%s\"\n", argv[1]);
        strncpy(data, argv[1], SHM_SIZE);
    } else
        printf("segment contains: \"%s\"\n", data);

    /* detach from the segment: */
    if (shmdt(data) == -1) {
        perror("shmdt");
        exit(1);
    }

    return 0;
}</pre>


<p>More commonly, a process will attach to the segment and run for a bit
while other programs are changing and reading the shared segment.  It's
neat to watch one process update the segment and see the changes appear
to other processes.  Again, for simplicity, the sample code doesn't do
that, but you can see how the data is shared between independent
processes.</p>

<p>Also, there's no code in here for removing the segment—be sure
to do that when you're done messing with it.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">10. <a name="mmap">Memory Mapped Files</a></h2><hr class="mainsecthr"/>


<p>There comes a time when you want to read and write to and from files
so that the information is shared between processes.  Think of it this
way: two processes both open the same file and both read and write from
it, thus sharing the information.  The problem is, sometimes it's a pain
to do all those <b><tt class="func">fseek()</tt></b>s and stuff to get around.  Wouldn't
it be easier if you could just map a section of the file to memory, and
get a pointer to it?  Then you could simply use pointer arithmetic to
get (and set) data in the file.</p>

<p>Well, this is exactly what a memory mapped file is.  And it's really
easy to use, too.  A few simple calls, mixed with a few simple rules,
and you're mapping like a mad-person.</p>



<h3 class="sect2title">10.1. <a name="mmmaker">Mapmaker</a></h3>


<p>Before mapping a file to memory, you need to get a file descriptor
for it by using the <b><tt class="func">open()</tt></b> system call:</p>

<pre class="code">int fd;

fd = open("mapdemofile", O_RDWR);</pre>


<p>In this example, we've opened the file for read/write access.  You
can open it in whatever mode you want, but it has to match the mode
specified in the <i><tt class="var">prot</tt></i> parameter to the
<b><tt class="func">mmap()</tt></b> call, below.</p>

<p>To memory map a file, you use the <b><tt class="func">mmap()</tt></b> system call,
which is defined as follows:</p>

<pre class="code">void *mmap(void *<i><tt class="var em1">addr</tt></i>, size_t <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">prot</tt></i>,
           int <i><tt class="var em1">flags</tt></i>, int <i><tt class="var em1">fildes</tt></i>, off_t <i><tt class="var em1">off</tt></i>);</pre>


<p>What a slew of parameters!  Here they are, one at a time:</p>


<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="15%%"><i><tt class="var">addr</tt></i></td>

<td valign="top" align="left" width="85%%">This is the address we want the file mapped into.  The
best way to use this is to set it to <tt class="const">(caddr_t)0</tt> and let
the OS choose it for you.  If you tell it to use an address the OS
doesn't like (for instance, if it's not a multiple of the virtual memory
page size), it'll give you an error.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">len</tt></i></td>

<td valign="top" align="left">This parameter is the length of the data we want to map into memory.
This can be any length you want.  (Aside: if <i><tt class="var">len</tt></i> not a
multiple of the virtual memory page size, you will get a blocksize that
is rounded up to that size.  The extra bytes will be 0, and any changes
you make to them will not modify the file.)</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">prot</tt></i></td>

<td valign="top" align="left">The "protection" argument allows you to specify what kind of access
this process has to the memory mapped region.  This can be a bitwise-ORd
mixture of the following values: <tt class="const">PROT_READ</tt>,
<tt class="const">PROT_WRITE</tt>, and <tt class="const">PROT_EXEC</tt>, for read,
write, and execute permissions, respectively.  The value specified here
must be equivalent to the mode specified in the <b><tt class="func">open()</tt></b>
system call that is used to get the file descriptor.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">flags</tt></i></td>

<td valign="top" align="left">There are just miscellaneous flags that can be set for the system
call.  You'll want to set it to <tt class="const">MAP_SHARED</tt> if you're
planning to share your changes to the file with other processes, or
<tt class="const">MAP_PRIVATE</tt> otherwise.  If you set it to the latter, your
process will get a copy of the mapped region, so any changes you make to
it will not be reflected in the original file—thus, other
processes will not be able to see them.  We won't talk about
<tt class="const">MAP_PRIVATE</tt> here at all, since it doesn't have much to do
with IPC.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">fildes</tt></i></td>

<td valign="top" align="left">This is where you put that file descriptor you opened
earlier.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">off</tt></i></td>

<td valign="top" align="left">This is the offset in the file that you want to start mapping from.
A restriction: this <i>must</i> be a multiple of the virtual memory
page size.  This page size can be obtained with a call to
<b><tt class="func">getpagesize()</tt></b>.</td>
</tr>


</table></center>


<p>As for return values, as you might have guessed, <b><tt class="func">mmap()</tt></b>
returns <tt class="const">-1</tt> on error, and sets <i><tt class="var">errno</tt></i>.
Otherwise, it returns a pointer to the start of the mapped data.</p>

<p>Anyway, without any further ado, we'll do a short demo that maps the
second "page" of a file into memory.  First we'll <b><tt class="func">open()</tt></b> it
to get the file descriptor, then we'll use <b><tt class="func">getpagesize()</tt></b> to
get the size of a virtual memory page and use this value for both the
<i><tt class="var">len</tt></i> and the <i><tt class="var">off</tt></i>.  In this way, we'll start
mapping at the second page, and map for one page's length.  (On my Linux
box, the page size is 4K.)</p>

<pre class="code">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;

int fd, pagesize;
char *data;

fd = open("foo", O_RDONLY);
pagesize = getpagesize();
data = mmap((caddr_t)0, pagesize, PROT_READ, MAP_SHARED, fd,
pagesize);</pre>

  
<p>Once this code stretch has run, you can access the first byte of the
mapped section of file using <i><tt class="var">data[0]</tt></i>.  Notice there's a lot
of type conversion going on here.  For instance, <b><tt class="func">mmap()</tt></b>
returns <nobr><tt class="type">caddr_t</tt></nobr>, but we treat it as a <nobr><tt class="type">char*</tt></nobr>.
Well, the fact is that <nobr><tt class="type">caddr_t</tt></nobr> usually is defined to be a
<nobr><tt class="type">char*</tt></nobr>, so everything's fine.</p>

<p>Also notice that we've mapped the file <tt class="const">PROT_READ</tt> so we
have read-only access.  Any attempt to write to the data
(<nobr><nobr><tt class="type">data[0] = 'B'</tt></nobr></nobr>, for example) will cause a
segmentation violation.  Open the file <tt class="const">O_RDWR</tt> with
<i><tt class="var">prot</tt></i> set to <tt class="const">PROT_READ|PROT_WRITE</tt> if you
want read-write access to the data.</p>





<h3 class="sect2title">10.2. <a name="mmunmap">Unmapping the file</a></h3>


<p>There is, of course, a <b><tt class="func">munmap()</tt></b> function to un-memory map a
file:</p>

<pre class="code">int munmap(caddr_t <i><tt class="var em1">addr</tt></i>, size_t <i><tt class="var em1">len</tt></i>);</pre>


<p>This simply unmaps the region pointed to by <i><tt class="var">addr</tt></i>
(returned from <b><tt class="func">mmap()</tt></b>) with length <i><tt class="var">len</tt></i> (same
as the <i><tt class="var">len</tt></i> passed to <b><tt class="func">mmap()</tt></b>).
<b><tt class="func">munmap()</tt></b> returns <tt class="const">-1</tt> on error and sets the
<tt class="tt">errno</tt> variable.</p>

<p>Once you've unmapped a file, any attempts to access the data through
the old pointer will result in a segmentation fault.  You have been
warned!</p>

<p>A final note: the file will automatically unmap if your program
exits, of course.</p>





<h3 class="sect2title">10.3. <a name="mmconcur">Concurrency, again?!</a></h3>


<p>If you have multiple processes manipulating the data in the same file
concurrently, you could be in for troubles.  You might have to <a href="#flocking">lock the file</a> or use <a href="#semaphores">semaphores</a> to regulate access to the file while
a process messes with it.  Look at the <a href="#shmcon">Shared
Memory</a> document for a (very little bit) more concurrency
information.</p>






<h3 class="sect2title">10.4. <a name="mmsamp">A simple sample</a></h3>


<p>Well, it's code time again.  I've got here a demo program that maps its
own source to memory and prints the byte that's found at whatever offset
you specify on the command line.</p>

<p>The program restricts the offsets you can specify to the range 0
through the file length.  The file length is obtained through a call to
<b><tt class="func">stat()</tt></b> which you might not have seen before.  It returns a
structure full of file info, one field of which is the size in bytes.
Easy enough.</p>

<p>Here is the source for <i><tt class="var"><a href="http://beej.us/guide/bgipc/examples/mmapdemo.c" target="_blank">mmapdemo.c</a></tt></i>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
    int fd, offset;
    char *data;
    struct stat sbuf;

    if (argc != 2) {
        fprintf(stderr, "usage: mmapdemo offset\n");
        exit(1);
    }

    if ((fd = open("mmapdemo.c", O_RDONLY)) == -1) {
        perror("open");
        exit(1);
    }

    if (stat("mmapdemo.c", &amp;sbuf) == -1) {
        perror("stat");
        exit(1);
    }

    offset = atoi(argv[1]);
    if (offset &lt; 0 || offset &gt; sbuf.st_size-1) {
        fprintf(stderr, "mmapdemo: offset must be in the range 0-%d\n", \
                                                              sbuf.st_size-1);
        exit(1);
    }
    
    data = mmap((caddr_t)0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0)) \
                                                           == (caddr_t)(-1)) {
    if (data == (caddr_t)(-1)) {
        perror("mmap");
        exit(1);
    }

    printf("byte at offset %d is '%c'\n", offset, data[offset]);

    return 0;
}</pre>


<p>That's all there is to it.  Compile that sucker up and run it with
some command line like:</p>

<pre class="screen">$ mmapdemo 30
byte at offset 30 is 'e'</pre>


<p>I'll leave it up to you to write some really cool programs using this
system call.</p>





<h3 class="sect2title">10.5. <a name="mmsum">Summary</a></h3>


<p>Memory mapped files can be very useful, especially on systems that
don't support shared memory segments.  In fact, the two are very similar
in most respects.  (Memory mapped files are committed to disk, too, so
this could even be an advantage, yes?)  With file locking or semaphores,
data in a memory mapped file can easily be shared between multiple
processes.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">11. <a name="unixsock">Unix Sockets</a></h2><hr class="mainsecthr"/>


<p>Remember <a href="#fifos">FIFOs</a>?  Remember how they can
only send data in one direction, just like a <a href="#pipes">Pipes</a>?  Wouldn't it be grand if you could send
data in both directions like you can with a socket?</p>

<p>Well, hope no longer, because the answer is here: Unix Domain Sockets!
In case you're still wondering what a socket is, well, it's a two-way
communications pipe, which can be used to communicate in a wide variety
of <i>domains</i>.  One of the most common domains sockets communicate
over is the Internet, but we won't discuss that here.  We will, however,
be talking about sockets in the Unix domain; that is, sockets that can
be used between processes on the same Unix system.</p>

<p>Unix sockets use many of the same function calls that Internet
sockets do, and I won't be describing all of the calls I use in detail
within this document.  If the description of a certain call is too vague
(or if you just want to learn more about Internet sockets anyway), I
arbitrarily suggest <i><a href="http://beej.us/guide/bgnet/" target="_blank">Beej's Guide to
Network Programming using Internet Sockets</a></i>.  I know
the author personally.</p>



<h3 class="sect2title">11.1. <a name="unixsockover">Overview</a></h3>


<p>Like I said before, Unix sockets are just like two-way FIFOs.
However, all data communication will be taking place through the sockets
interface, instead of through the file interface.  Although Unix sockets
are a special file in the file system (just like FIFOs), you won't be
using <b><tt class="func">open()</tt></b> and <b><tt class="func">read()</tt></b>—you'll be using
<b><tt class="func">socket()</tt></b>, <b><tt class="func">bind()</tt></b>, <b><tt class="func">recv()</tt></b>,
etc.</p>

<p>When programming with sockets, you'll usually create server and
client programs.  The server will sit listening for incoming connections
from clients and handle them.  This is very similar to the situation
that exists with Internet sockets, but with some fine differences.</p>

<p>For instance, when describing which Unix socket you want to use (that
is, the path to the special file that is the socket), you use a
<nobr><nobr><tt class="type">struct sockaddr_un</tt></nobr></nobr>, which has the following
fields:</p>

<pre class="code">struct sockaddr_un {
    unsigned short sun_family;  /* AF_UNIX */
    char sun_path[108];
}</pre>


<p>This is the structure you will be passing to the <b><tt class="func">bind()</tt></b>
function, which associates a socket descriptor (a file descriptor) with
a certain file (the name for which is in the <i><tt class="var">sun_path</tt></i>
field).</p>





<h3 class="sect2title">11.2. <a name="unixsockserv">What to do to be a Server</a></h3>


<p>Without going into too much detail, I'll outline the steps a server
program usually has to go through to do it's thing.  While I'm at it,
I'll be trying to implement an "echo server" which just echos back
everything it gets on the socket.</p>

<p>Here are the server steps:</p>

<ol>

<li><p><b>Call <b><tt class="func">socket()</tt></b>:</b>  A call to
<b><tt class="func">socket()</tt></b> with the proper arguments creates the Unix
socket:</p>

<pre class="code">unsigned int s, s2;
struct sockaddr_un local, remote;
int len;

s = socket(AF_UNIX, SOCK_STREAM, 0);</pre>


<p>The second argument, <tt class="const">SOCK_STREAM</tt>, tells
<b><tt class="func">socket()</tt></b> to create a stream socket.  Yes, datagram sockets
(<tt class="const">SOCK_DGRAM</tt>) are supported in the Unix domain, but I'm
only going to cover stream sockets here.  For the curious, see <a href="http://beej.us/guide/bgnet/" target="_blank">Beej's Guide to Network Programming</a> for a good
description of unconnected datagram sockets that applies perfectly well
to Unix sockets.  The only thing that changes is that you're now using a
<nobr><nobr><tt class="type">struct sockaddr_<b>un</b></tt></nobr></nobr> instead of a
<nobr><nobr><tt class="type">struct sockaddr_<b>in</b></tt></nobr></nobr>.</p>

<p>One more note: all these calls return <tt class="const">-1</tt> on error and
set the global variable <i><tt class="var">errno</tt></i> to reflect whatever went wrong.
Be sure to do your error checking.</p>
</li>


<li><p><b>Call <b><tt class="func">bind()</tt></b>:</b>  You got a socket descriptor
from the call to <b><tt class="func">socket()</tt></b>, now you want to bind that to an
address in the Unix domain.  (That address, as I said before, is a
special file on disk.)</p>

<pre class="code">local.sun_family = AF_UNIX;  /* local is declared before socket() ^ */
strcpy(local.sun_path, "/home/beej/mysocket");
unlink(local.sun_path);
len = strlen(local.sun_path) + sizeof(local.sun_family);
bind(s, (struct sockaddr *)&amp;local, len);</pre>


<p>This associates the socket descriptor "<i><tt class="var">s</tt></i>" with the Unix
socket address "<tt class="tt">/home/beej/mysocket</tt>".  Notice that we called
<b><tt class="func">unlink()</tt></b> before <b><tt class="func">bind()</tt></b> to remove the socket if
it already exists.  You will get an <tt class="tt">EINVAL</tt> error if the file is
already there.</p>
</li>


<li><p><b>Call <b><tt class="func">listen()</tt></b>:</b>  This instructs the socket to
listen for incoming connections from client programs:</p>

<pre class="code">listen(s, 5);</pre>


<p>The second argument, <tt class="const">5</tt>, is the number of incoming
connections that can be queued before you call <b><tt class="func">accept()</tt></b>,
below.  If there are this many connections waiting to be accepted,
additional clients will generate the error
<tt class="const">ECONNREFUSED</tt>.</p>

</li>


<li><p><b>Call <b><tt class="func">accept()</tt></b>:</b>  This will accept a connection
from a client.  This function returns <i>another socket
descriptor</i>!  The old descriptor is still listening for new
connections, but this new one is connected to the client:</p>

<pre class="code">len = sizeof(struct sockaddr_un);
s2 = accept(s, &amp;remote, &amp;len);</pre>


<p>When <b><tt class="func">accept()</tt></b> returns, the <i><tt class="var">remote</tt></i> variable
will be filled with the remote side's <nobr><nobr><tt class="type">struct
sockaddr_un</tt></nobr></nobr>, and <i><tt class="var">len</tt></i> will be set to its length.
The descriptor <i><tt class="var">s2</tt></i> is connected to the client, and is ready
for <b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b>, as described in the
<a href="http://beej.us/guide/bgnet/" target="_blank">Network Programming Guide</a>.</p>
</li>


<li><p><b>Handle the connection and loop back to
<b><tt class="func">accept()</tt></b>:</b> Usually you'll want to communicate to the
client here (we'll just echo back everything it sends us), close the
connection, then <b><tt class="func">accept()</tt></b> a new one.</p>

<pre class="code">while (len = recv(s2, &amp;buf, 100, 0), len &gt; 0)
    send(s2, &amp;buf, len, 0);

/* loop back to accept() from here */</pre>

</li>


<li><p><b>Close the connection:</b>  You can close the connection either
by calling <tt class="tt">close()</tt>, or by calling <a href="http://beej.us/guide/url/shutdownman" target="_blank"><b><tt class="func">shutdown()</tt></b></a>.</p>

</li>


</ol>


<p>With all that said, here is some source for an echoing server, <a href="http://beej.us/guide/bgipc/examples/echos.c" target="_blank"><i><tt class="var">echos.c</tt></i></a>.  All it does is wait for a
connection on a Unix socket (named, in this case, "echo_socket").</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

#define SOCK_PATH "echo_socket"

int main(void)
{
    int s, s2, t, len;
    struct sockaddr_un local, remote;
    char str[100];

    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    local.sun_family = AF_UNIX;
    strcpy(local.sun_path, SOCK_PATH);
    unlink(local.sun_path);
    len = strlen(local.sun_path) + sizeof(local.sun_family);
    if (bind(s, (struct sockaddr *)&amp;local, len) == -1) {
        perror("bind");
        exit(1);
    }

    if (listen(s, 5) == -1) {
        perror("listen");
        exit(1);
    }

    for(;;) {
        int done, n;
        printf("Waiting for a connection...\n");
        t = sizeof(remote);
        if ((s2 = accept(s, (struct sockaddr *)&amp;remote, &amp;t)) == -1) {
            perror("accept");
            exit(1);
        }

        printf("Connected.\n");

        done = 0;
        do {
            n = recv(s2, str, 100, 0);
            if (n &lt;= 0) {
                if (n &lt; 0) perror("recv");
                done = 1;
            }

            if (!done) 
                if (send(s2, str, n, 0) &lt; 0) {
                    perror("send");
                    done = 1;
                }
        } while (!done);

        close(s2);
    }

    return 0;
}</pre>


<p>As you can see, all the aforementioned steps are included in this
program: call <b><tt class="func">socket()</tt></b>, call <b><tt class="func">bind()</tt></b>, call
<b><tt class="func">listen()</tt></b>, call <b><tt class="func">accept()</tt></b>, and do some network
<b><tt class="func">send()</tt></b>s and <b><tt class="func">recv()</tt></b>s.</p>





<h3 class="sect2title">11.3. <a name="sockclient">What to do to be a client</a></h3>


<p>There needs to be a program to talk to the above server, right?
Except with the client, it's a lot easier because you don't have to do
any pesky <b><tt class="func">listen()</tt></b>ing or <b><tt class="func">accept()</tt></b>ing.  Here
are the steps:</p>

<ol>

<li>Call <b><tt class="func">socket()</tt></b> to get a Unix domain socket to communicate
through.</li>


<li>Set up a <nobr><nobr><tt class="type">struct sockaddr_un</tt></nobr></nobr> with the
remote address (where the server is listening) and call
<b><tt class="func">connect()</tt></b> with that as an argument</li>


<li>Assuming no errors, you're connected to the remote side!  Use
<b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b> to your heart's
content!</li>


</ol>


<p>How about code to talk to the echo server, above?  No sweat, friends,
here is <a href="http://beej.us/guide/bgipc/examples/echoc.c" target="_blank"><i><tt class="var">echoc.c</tt></i></a>:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

#define SOCK_PATH "echo_socket"

int main(void)
{
    int s, t, len;
    struct sockaddr_un remote;
    char str[100];

    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    printf("Trying to connect...\n");

    remote.sun_family = AF_UNIX;
    strcpy(remote.sun_path, SOCK_PATH);
    len = strlen(remote.sun_path) + sizeof(remote.sun_family);
    if (connect(s, (struct sockaddr *)&amp;remote, len) == -1) {
        perror("connect");
        exit(1);
    }

    printf("Connected.\n");

    while(printf("&gt; "), fgets(str, 100, stdin), !feof(stdin)) {
        if (send(s, str, strlen(str), 0) == -1) {
            perror("send");
            exit(1);
        }

        if ((t=recv(s, str, 100, 0)) &gt; 0) {
            str[t] = '\0';
            printf("echo&gt; %s", str);
        } else {
            if (t &lt; 0) perror("recv");
            else printf("Server closed connection\n");
            exit(1);
        }
    }

    close(s);

    return 0;
}</pre>


<p>In the client code, of course you'll notice that there are only a few
system calls used to set things up: <b><tt class="func">socket()</tt></b> and
<b><tt class="func">connect()</tt></b>.  Since the client isn't going to be
<b><tt class="func">accept()</tt></b>ing any incoming connections, there's no need for
it to <b><tt class="func">listen()</tt></b>.  Of course, the client still uses
<b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b> for transferring data.  That
about sums it up.</p>





<h3 class="sect2title">11.4. <a name="socketpair"><tt class="tt">socketpair()</tt>—quick full-duplex pipes</a></h3>


<p>What if you wanted a <a href="#pipes"><b><tt class="func">pipe()</tt></b></a>,
but you wanted to use a single pipe to send and recieve data from
<i>both sides</i>?  Since pipes are unidirectional (with exceptions
in SYSV), you can't do it!  There is a solution, though: use a Unix
domain socket, since they can handle bi-directional data.</p>

<p>What a pain, though!  Setting up all that code with
<b><tt class="func">listen()</tt></b> and <b><tt class="func">connect()</tt></b> and all that just to
pass data both ways!  But guess what!  You don't have to!</p>

<p>That's right, there's a beauty of a system call known as
<b><tt class="func">socketpair()</tt></b> this is nice enough to return to you a pair of
<i>already connected sockets</i>!  No extra work is needed on your
part; you can immediately use these socket descriptors for interprocess
communication.</p>

<p>For instance, lets set up two processes.  The first sends a
<nobr><tt class="type">char</tt></nobr> to the second, and the second changes the character to
uppercase and returns it.  Here is some simple code to do just that,
called <i><tt class="var"><a href="http://beej.us/guide/bgipc/examples/spair.c" target="_blank">spair.c</a></tt></i>
(with no error checking for clarity):</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int main(void)
{
    int sv[2]; /* the pair of socket descriptors */
    char buf; /* for data exchange between processes */

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1) {
        perror("socketpair");
        exit(1);
    }

    if (!fork()) {  /* child */
        read(sv[1], &amp;buf, 1);
        printf("child: read '%c'\n", buf);
        buf = toupper(buf);  /* make it uppercase */
        write(sv[1], &amp;buf, 1);
        printf("child: sent '%c'\n", buf);

    } else { /* parent */
        write(sv[0], "b", 1);
        printf("parent: sent 'b'\n");
        read(sv[0], &amp;buf, 1);
        printf("parent: read '%c'\n", buf);
        wait(NULL); /* wait for child to die */
    }

    return 0;
}</pre>


<p>Sure, it's an expensive way to change a character to uppercase, but
it's the fact that you have simple communication going on here that
really matters.</p>

<p>One more thing to notice is that <b><tt class="func">socketpair()</tt></b> takes both
a domain (<tt class="const">AF_UNIX</tt>) and socket type
(<tt class="const">SOCK_STREAM</tt>).  These can be any legal values at all,
depending on which routines in the kernel you want to handle your code,
and whether you want stream or datagram sockets.  I chose
<tt class="const">AF_UNIX</tt> sockets because this is a Unix sockets document
and they're a bit faster than <tt class="const">AF_INET</tt> sockets, I
hear.</p>

<p>Finally, you might be curious as to why I'm using
<b><tt class="func">write()</tt></b> and <b><tt class="func">read()</tt></b> instead of
<b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b>.  Well, in short, I was
being lazy.  See, by using these system calls, I don't have to enter the
<i><tt class="var">flags</tt></i> argument that <b><tt class="func">send()</tt></b> and
<b><tt class="func">recv()</tt></b> use, and I always set it to zero anyway.  Of course,
socket descriptors are just file descriptors like any other, so they
respond just fine to many file manipulation system calls.</p>



 







<hr class="mainsectbreak"/><h2 class="sect1title">12. <a name="references">More IPC Resources</a></h2><hr class="mainsecthr"/>




<h3 class="sect2title">12.1. <a name="refbooks">Books</a></h3>


<p>Here are some books that describe some of the procedures I've
discussed in this guide, as well as Unix details in specific:</p>



<p><i>Unix Network Programming, volumes 1-2</i> by W.
Richard Stevens.  Published by Prentice Hall.  ISBNs for volumes 1-2:
<a href="http://beej.us/guide/url/unixnet1" target="_blank">0131411551</a>,
<a href="http://beej.us/guide/url/unixnet2" target="_blank">0130810819</a>.
</p>


<p><i>Advanced Programming in the UNIX
Environment</i> by W. Richard Stevens.  Published by Addison
Wesley.  ISBN
<a href="http://beej.us/guide/url/advunix" target="_blank">0201433079</a>.
</p>


<p>Bach, Maurice J.  <i>The Design of the UNIX Operating
System</i>.  New Jersey: Prentice-Hall, 1986.  ISBN <a href="http://beej.us/guide/url/unixdesign" target="_blank">0132017997</a>.</p>








<h3 class="sect2title">12.2. <a name="onlineref">Other online documentation</a></h3>




<p><i><a href="http://www.kohala.com/start/unpv22e/unpv22e.html" target="_blank">UNIX Network Programming Volume
2 home page</a></i>—includes source code from Stevens'
superfine book</p>


<p><i><a href="http://tldp.org/LDP/lpg/node7.html" target="_blank">The Linux Programmer's
Guide</a></i>—in-depth section on IPC</p>


<p><i><a href="http://www.cs.cf.ac.uk/Dave/C/" target="_blank">UNIX System Calls and
Subroutines using C</a></i>—contains modest IPC
information</p>


<p><i><a href="http://tldp.org/LDP/tlk/ipc/ipc.html" target="_blank">The Linux
Kernel</a></i>—how the Linux kernel implements
IPC</p>












<h3 class="sect2title">12.3. <a name="manpages">Linux man pages</a></h3>


<p>There are Linux manual pages.  If you run another flavor of Unix,
please look at your own man pages, as these might not work on your
system.</p>

<p><a href="http://www.linuxmanpages.com/man2/accept.2.php" target="_blank"><b><tt class="func">accept()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/bind.2.php" target="_blank"><b><tt class="func">bind()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/connect.2.php" target="_blank"><b><tt class="func">connect()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/dup.2.php" target="_blank"><b><tt class="func">dup()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/exec.2.php" target="_blank"><b><tt class="func">exec()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/exit.2.php" target="_blank"><b><tt class="func">exit()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/fcntl.2.php" target="_blank"><b><tt class="func">fcntl()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man3/fileno.3.php" target="_blank"><b><tt class="func">fileno()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/fork.2.php" target="_blank"><b><tt class="func">fork()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man3/ftok.3.php" target="_blank"><b><tt class="func">ftok()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/getpagesize.2.php" target="_blank"><b><tt class="func">getpagesize()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man8/ipcrm.8.php" target="_blank"><b class="com">ipcrm</b></a>,
<a href="http://www.linuxmanpages.com/man8/ipcs.8.php" target="_blank"><b class="com">ipcs</b></a>,
<a href="http://www.linuxmanpages.com/man1/kill.1.php" target="_blank"><b class="com">kill</b></a>,
<a href="http://www.linuxmanpages.com/man2/kill.2.php" target="_blank"><b><tt class="func">kill()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/listen.2.php" target="_blank"><b><tt class="func">listen()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/lockf.2.php" target="_blank"><b><tt class="func">lockf()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/lseek.2.php" target="_blank"><b><tt class="func">lseek()</tt></b></a> (for the <i><tt class="var">l_whence</tt></i> field in <nobr><nobr><tt class="type">struct flock</tt></nobr></nobr>),
<a href="http://www.linuxmanpages.com/man1/mknod.1.php" target="_blank"><b class="com">mknod</b></a>,
<a href="http://www.linuxmanpages.com/man2/mknod.2.php" target="_blank"><b><tt class="func">mknod()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/mmap.2.php" target="_blank"><b><tt class="func">mmap()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/msgctl.2.php" target="_blank"><b><tt class="func">msgctl()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/msgget.2.php" target="_blank"><b><tt class="func">msgget()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/msgsnd.2.php" target="_blank"><b><tt class="func">msgsnd()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/munmap.2.php" target="_blank"><b><tt class="func">munmap()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/open.2.php" target="_blank"><b><tt class="func">open()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/pipe.2.php" target="_blank"><b><tt class="func">pipe()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man1/ps.1.php" target="_blank"><b class="com">ps</b></a>,
<a href="http://www.linuxmanpages.com/man3/raise.3.php" target="_blank"><b><tt class="func">raise()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/read.2.php" target="_blank"><b><tt class="func">read()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/recv.2.php" target="_blank"><b><tt class="func">recv()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/semctl.2.php" target="_blank"><b><tt class="func">semctl()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/semget.2.php" target="_blank"><b><tt class="func">semget()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/semop.2.php" target="_blank"><b><tt class="func">semop()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/send.2.php" target="_blank"><b><tt class="func">send()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/shmat.2.php" target="_blank"><b><tt class="func">shmat()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/shmctl.2.php" target="_blank"><b><tt class="func">shmctl()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/shmdt.2.php" target="_blank"><b><tt class="func">shmdt()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/shmget.2.php" target="_blank"><b><tt class="func">shmget()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/sigaction.2.php" target="_blank"><b><tt class="func">sigaction()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/signal.2.php" target="_blank"><b><tt class="func">signal()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man7/signal.7.php" target="_blank">signals</a>,
<a href="http://www.linuxmanpages.com/man2/sigpending.2.php" target="_blank"><b><tt class="func">sigpending()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/sigprocmask.2.php" target="_blank"><b><tt class="func">sigprocmask()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/sigsetops.2.php" target="_blank">sigsetops</a>,
<a href="http://www.linuxmanpages.com/man2/sigsuspend.2.php" target="_blank"><b><tt class="func">sigsuspend()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/socket.2.php" target="_blank"><b><tt class="func">socket()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/socketpair.2.php" target="_blank"><b><tt class="func">socketpair()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/stat.2.php" target="_blank"><b><tt class="func">stat()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/wait.2.php" target="_blank"><b><tt class="func">wait()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/waitpid.2.php" target="_blank"><b><tt class="func">waitpid()</tt></b></a>,
<a href="http://www.linuxmanpages.com/man2/write.2.php" target="_blank"><b><tt class="func">write()</tt></b></a>.</p>



 


</body>
</html>
