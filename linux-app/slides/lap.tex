\usepackage{wx672tut}

\newcommand{\unix}{{\fontspec{Purisa}{UNIX}}}
\newcommand{\emacs}{\includegraphics[width=1.2em]{emacs}}
\newcommand{\google}{\raisebox{-.2em}{\includegraphics[width=3em]{google}}}
\newcommand{\GG}{\textcolor{SkyBlue}{\nerd }}
\newcommand{\world}{\textcolor{SkyBlue}{\nerd }}
\newcommand{\pdf}{\textcolor{red}{\nerd }}%
\newcommand{\folder}{{\nerd }}%e5fe,e61e,e7a3,f07c
\newcommand{\git}{{\nerd }}%f1d2,f1d3
\newcommand{\github}{\nerd }
\newcommand{\moodle}{\includegraphics[width=1em]{moodle}}
\newcommand{\obook}{{\nerd }}%f212,f401,f405
\newcommand{\shell}{{\nerd }}%e795
\newcommand{\CMD}[1]{\texttt{\textcolor{Green}{\$} #1}}
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\vim}{{\nerd }}
\newcommand{\stackoverflow}{{\nerd }}%f16c, e710
\newcommand{\correct}{{\Large\textcolor{Green}{\nerd ✔}}}
\newcommand{\wrong}{\textcolor{red}{\nerd ✘}}
\newcommand{\Bad}{{\Large \textcolor{red}{\bad}}}
\newcommand{\Good}{{\Large \textcolor{Green}{\good}}}

% f421,f46e,f536

\addbibresource{ref.bib}

%\AtBeginPart{\frame{\partpage}}
\mode<beamer>{
  \AtBeginSection{\frame{\sectionpage}}
  \AtBeginSubsection{\frame{\subsectionpage}}
}

% \includeonlylecture{intro}
% \includeonlylecture{bash}

\title{GNU/Linux\\Application Programming}
\author{WANG Xiaolin\\%
  {\footnotesize\texttt{wx672ster+linux@gmail.com}}}

\begin{document}

\mode<article>{  
  \subtitle{Lecture Handouts}
  \maketitle
  \tableofcontents
    \nocite{matthew2008beginning, cooper10bash, raymond2003art, stevens2013advanced,
      Love:2007:LSP:1205435, Kerrisk:2010:LPI:1869911, Bryant2010computersystems}%
  \printbibliography[title={References}]}

\mode<beamer>{\frame{\titlepage}}

\begin{frame}<beamer>{Textbooks}
  \begin{refsection}
    \nocite{matthew2008beginning, cooper10bash, raymond2003art, stevens2013advanced,
      Love:2007:LSP:1205435, Kerrisk:2010:LPI:1869911, Bryant2010computersystems}%
    \printbibliography[heading=none]
  \end{refsection}
\end{frame}

\begin{frame}{Course Web Links}
  \begin{itemize}
  \item[\moodle] \url{https://cs6.swfu.edu.cn/moodle}
  \item[\pdf] \url{https://cs2.swfu.edu.cn/~wx672/lecture_notes/linux-app/slides/}
  \item[\folder] \url{https://cs2.swfu.edu.cn/~wx672/lecture_notes/linux-app/src/}
  \item[\obook] \url{https://cs3.swfu.edu.cn/tech}
  \end{itemize}
  \begin{block}{\texttt{/etc/hosts}}
    \ttfamily
    \begin{tabular}{ll}
      202.203.132.241&cs6.swfu.edu.cn\\      
      202.203.132.242&cs2.swfu.edu.cn\\
      202.203.132.245&cs3.swfu.edu.cn\\      
    \end{tabular}
  \end{block}
\end{frame}

\begin{frame}{Homework}
  \begin{block}{Weekly tech question}
    \begin{enumerate}
    \item What was I trying to do?
    \item How did I do it? (steps)
    \item The expected output? The real output?
    \item How did I try to solve it? (steps, books, web links)
    \item How many hours did I struggle?
    \end{enumerate}
  \end{block}
  \begin{itemize}
  \item[\Large\dejavu ✉] \alert{\ttfamily wx672ster+linux@gmail.com}
  \item[$\mathbb{E}$] Preferably in English
  \item[\stackoverflow] in
    \href{https://stackoverflow.com/questions/39199299/what-is-the-essential-difference-between-compound-command-and-normal-command-inlink}{stackoverflow}
    style
  \item[Or] simply show me the tech questions you asked on any website
  \end{itemize}  
\end{frame}

\lecture{start}{start}% \lecture[short name]{name}{label}
\section{Getting Started}
\label{sec:start}

\begin{frame}{Linux Commands}
  \begin{description}
  \item[Where to find them?] {\ttfamily /bin, /usr/bin, /usr/local/bin,\\\symbol{`~}/bin,
      \ldots}
    \begin{itemize}
    \item[\$] \texttt{echo \$PATH}
    \end{itemize}
  \item[How to find them?] \texttt{which, whereis, type}
  \end{description}
  \begin{block}{Command not found?}
    \begin{description}
    \item[First] double check your spelling
    \item[Then] try:{\ttfamily
      \begin{itemize}
      \item[\debian] aptitude search xxx
      \item[\debian] apt-cache search xxx
      \item[\debian] apt-file search xxx
      \item[\debian] sudo apt install packagename
      \item[\GG] \google~"linux command xxx"
      \end{itemize}}
    \end{description}
  \end{block}
\end{frame}

\begin{frame}{Text Editors}
  \begin{block}
    {\mode<beamer>{{{\Huge\vim}\,\quad{}vs.\quad{}{\LARGE\emacs}}}
    \mode<article>{{\vim\,\quad{}vs.\quad{}\emacs}}}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{vivsemacs} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{vivsemacs} }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Help Your Editor}
  \begin{block}{Suffix matters}\ttfamily
    \begin{itemize}
    \item[\$] vim \wrong
    \item[\$] vim hello \wrong
    \item[\$] vim hello.c  \correct
    \item[\$] vim hello.py \correct
    \item[\$] emacs \wrong
    \item[\$] emacs hello \wrong
    \item[\$] emacsclient hello.c  \correct
    \item[\$] emacsclient hello.py \correct
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Keyboard}
  \begin{center}
    \includegraphics[width=.7\linewidth]{qwerty}
  \end{center}
  \begin{itemize}
  \item[\vim] vimtutor
  \item[\emacs] \Ch{} {\kbd t}
  \end{itemize}
\end{frame}

\section{Shell Basics}
\label{sec:basic-commands}

\begin{frame}{Shell}
  \begin{itemize}
  \item[\shell] A command line interpreter
  \item[\shell] A programming language
  \end{itemize}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.5\textwidth]{sys-arch} }%
    \mode<article>{ \includegraphics[width=.3\textwidth]{sys-arch} }
  \end{center}
\end{frame}

\begin{frame}{Directory Structure}
  \includegraphics[width=\linewidth]{cs2}
  
  \begin{center}\small
    \begin{tabular}{r@{\qquad}>{\ttfamily}l}
      \hline
      \thead{Todo}  & \thead{How}  \\\hline
      Where am I?   & pwd          \\
      What's in it? & ls           \\
      Move around?  & cd           \\
      Disk usage?   & du, df       \\
      USB drive?    & lsblk, mount \\
      New folder?   & mkdir        \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{File Operations}
  \begin{block}{Ways to create a file}
    \begin{itemize}
    \item[\vim] Using an editor (vim, emacs, nano\ldots), or
    \item[\$] \cmd{cat > filename}
    \item[\$] \cmd{echo "hello, world" > filename}
    \item[\$] \cmd{touch filename}
    \end{itemize}
  \end{block}
  More file operations:
  \begin{center}\small
    \begin{tabular}{r@{\quad}>{\ttfamily}l|r@{\quad}>{\ttfamily}l}
      \hline
      \thead{Todo} & \thead{How} & \thead{Todo} & \thead{How}         \\\hline
      Copy?        & cp          & Move/Rename? & mv                  \\
      Delete?      & rm          & What's it?   & file                \\
      Link?        & ln          & Permission?  & chmod, chown        \\
      Count?       & wc          & Archive?   & tar, gzip, 7z, \ldots \\
      Sort?        & sort, uniq  & Search?      & find, grep          \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{Redirection}
  \begin{block}{Redirecting output}\ttfamily
    \begin{itemize}
    \item[\$] ls -l > output.txt
    \item[\$] ps aux >> output.txt
    \end{itemize}
  \end{block}
  \begin{block}{Redirecting input}\ttfamily
    \begin{itemize}
    \item[\$] more < output.txt
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Process Operations}
  \begin{center}\small
    \begin{tabular}{r@{\quad}>{\ttfamily}l|r@{\quad}>{\ttfamily}l}
      \hline
      \thead{Todo} & \thead{How} & \thead{Todo} & \thead{How}         \\\hline
      Kill?&kill, Ctrl-c&suspend?&Ctrl-z\\
      background?&bg, \& &forground?&fg, jobs\\
      status?&ps, top&&\\\hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{System Info}
  \begin{center}\small
    \begin{tabular}{r@{\quad}>{\ttfamily}l|r@{\quad}>{\ttfamily}l}
      \hline
      \thead{Todo}   & \thead{How}         & \thead{Todo} & \thead{How}  \\\hline
      who?           & w, who, whoami      & how long?    & uptime       \\
      software?      & apt, aptitude, dpkg & kernel?      & uname, lsmod \\
      hardware?      & lspci, lsusb, lscpu & memory?      & free, lsmem  \\\hline
    \end{tabular}
  \end{center}
  \begin{block}{APT --- ~\debian~package management}
    \begin{center}\small
      \begin{tabular}{l>{\ttfamily}l}
        \hline
        \thead{Todo} & \thead{How}                                       \\\hline
        upgrading?   & apt update \&\& apt upgrade                       \\
        install?     & apt install xxx                                   \\
        remove?      & apt purge xxx                                     \\
        search?      & apt search xxx                                    \\
        details?     & apt show xxx                                      \\
        friendly UI? & aptitude                                          \\\hline
      \end{tabular}
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{CLI Shortcuts}
  \begin{center}
    \begin{tabular}{>{\ttfamily}r@{\quad}l|>{\ttfamily}r@{\quad}l}
      \Ca: & beginning of line  & \Ce:  & end of line      \\
      \Cf: & forward            & \Cb:  & backward         \\
      \Cn: & next               & \Cp:  & previous         \\
      \Cr: & reverse search     & \Cu:  & cut to beginning \\
      \Ck: & kill (cut to end)  & \Cy:  & yank (paste)     \\
      \Cd: & delete a character & \Tab: & completion       \\
    \end{tabular}
  \end{center}
  \begin{block}{Tmux}
    \begin{center}
    \begin{tabular}{>{\ttfamily}r@{\quad}l|>{\ttfamily}r@{\quad}l}
      \Ca {\kbd c}:  & create window      & \Ca \Ca: & switch window    \\
      \Ca {\kbd n}:  & next window        & \Ca {\kbd p}:   & previous window  \\
      \Ca {\kbd -}:  & split window       & \Ca {\kbd |}:   & split widnow     \\
      \Ca {\kbd j}:  & go down            & \Ca {\kbd k}:   & go up            \\
      \Ca {\kbd l}:  & go right           & \Ca {\kbd h}:   & go left          \\
    \end{tabular}
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Understanding ``\texttt{ls -l}''}
  \begin{minipage}{.71\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{ls-l} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{ls-l} }
    \end{center}
  \end{minipage}\quad
  \begin{minipage}{.25\linewidth}\scriptsize
    \begin{tabular}{c@{\;-\;}l}
      d& directory\\
      -& regular file\\
      l& soft link\\
      c& character device\\
      b& block device\\
      s& socket\\
      p& named pipe (FIFO)
      \end{tabular}
  \end{minipage}

  \begin{block}{9-bit permission}
    \begin{minipage}{.27\linewidth}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{9bit} }%
        \mode<article>{ \includegraphics[width=.6\textwidth]{9bit} }
      \end{center}
    \end{minipage}\quad
    \begin{minipage}{.5\linewidth}\small
      \begin{tabular}{l@{\qquad}l}
        \CMD{chmod 755 foo}&\CMD{chmod 644 foo}\\
        \CMD{chmod 000 foo}&\CMD{chmod 777 foo}\\
        \CMD{chmod a-r foo}&\CMD{chmod u+x foo}\\
        \CMD{chmod g+w foo}&\CMD{chmod go=rx foo}
      \end{tabular}
    \end{minipage}
  \end{block}
\end{frame}

\begin{frame}{Wildcard Expansion}
  \begin{center}
    \begin{tabular}{>{\ttfamily}rl>{\ttfamily}l}
      \hline
      \thead{Character}&\thead{Meaning}&\thead{Example}\\\hline
      ?&any one&\CMD{ls ???.txt}\\
      *&zero or more&\CMD{ls *.c}\\
      {[]}&or&\CMD{ls *.[ch]}\\
      \{\}&and&\CMD{ls *.\{c,h,cpp\}}\\\hline    
    \end{tabular}
  \end{center}
  \begin{block}{Example}
    \CMD{touch \{2,3,4,234\}.\{jpg,png\} \&\& ls}\\[1ex]
    \begin{description}
    \item[output:]
      \begin{tabular}{*{4}{>{\ttfamily}r}}\hline
        2.jpg&234.jpg&3.jpg&4.jpg\\
        2.png&234.png&3.png&4.png\\\hline
      \end{tabular}
    \end{description}
    \vspace*{1ex}
    \begin{multicols}{2}
      \begin{itemize}
      \item[\$] \cmd{rm [234].jpg}
      \item[\$] \cmd{rm \{2,3,4,234\}.jpg}
      \item[\$] \cmd{rm 2*}
      \item[\$] \cmd{rm ?.jpg}
      \item[\$] \cmd{rm ?.*}
      \item[\$] \cmd{rm *}
      \end{itemize}
    \end{multicols}
  \end{block}
\end{frame}

\begin{frame}{Everything Is A File}
  \begin{itemize}
  \item[\$] \cmd{cat /dev/null > /var/log/messages \# empty a file}
    \begin{itemize}
    \item[\$] \cmd{: > /var/log/messages \# no new process}
    \end{itemize}
  \item[\$] \cmd{ls > /dev/null}
  \item[\$] \cmd{dd if=/dev/zero of=/tmp/clean bs=1k count=1k}
  \item[\$] \cmd{dd if=/dev/urandom of=/tmp/random bs=1k count=1k}
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{/proc}}
  Allow higher-level access to driver and kernel information
  \ttfamily
  \begin{itemize}
  \item[\$] cat /proc/cpuinfo
  \item[\$] cat /proc/meminfo
  \item[\$] cat /proc/version
  \item[\$] cat /proc/1/status
  \item[\#] echo 100000 > /proc/sys/kernel/pid\_max
  \end{itemize}
\end{frame}

\begin{frame}{Pipe}{Chain processes together}
  \begin{block}{Unnamed pipe}\ttfamily
    \begin{itemize}
    \item[\$] ps aux | sort | less
    \end{itemize}
  \end{block}
  \begin{block}{Named pipe}\ttfamily
    \begin{enumerate}
    \item \alert{\$} mkfifo mypipe
    \item \alert{\$} gzip -9 -c < mypipe > out.gz
    \item \alert{\$} cat file > mypipe
    \end{enumerate}
  \end{block}  
\end{frame}

\begin{itemize}
\item \url{https://en.wikipedia.org/wiki/Named_pipe}
\end{itemize}

\section{Shell Programming}
\label{sec:shell-programming}

\begin{frame}{\$ --- Give Me The Value Of \ldots}
  \begin{description}
  \item[\texttt{\$var}] Give me the value of variable ``\texttt{var}''
  \item[\texttt{\$(echo hello)}] Give me the value (output) of command ``\cmd{echo hello}''
  \item[\texttt{\$((1+1))}] Give me the value (result) of ``1+1''
  \item[\texttt{\$\$}] Give me the value of special variable ``\texttt{\$}''
  \item[\texttt{\$?}] Give me the value of special variable ``\texttt{?}''
  \item[\texttt{\$0}] Give me the value of special variable ``\texttt{0}''
  \item[\texttt{\$@}] Give me the value of special variable ``\texttt{@}''
  \end{description}
\end{frame}

\begin{frame}{Variables}\ttfamily\small
  \begin{itemize}
  \item[\$] a=8; b=2
  \item[\$] a=a+5; a=\$a+5 \Bad
  \item[\$] let a=a+5; let a+=5 \Good
  \item[\$] let b=b+a; let b+=a \Good
  \item[\$] echo a; echo \$a
  \item[\$] (( a=5, b=6, a+=b )) \Good
  \item[\$] (( b=a<5?8:9 )) \Good
  \item[\$] r=\$(( RANDOM\%100 )) \Good
  \item[\$] echo "\$a" \# partial quoting
  \item[\$] echo '\$a' \# full quoting
  \item[\$] a=\$(ls -l); echo \$a; echo "\$a"
  \item[\$] a=hello; b=world; let a+=b \Bad
  \end{itemize}
\end{frame}

\begin{frame}{Positional Parameters}{\cmd{\$0, \$1, \$2, \ldots, \$@, \$\#}}
  \begin{minipage}{.44\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{isay-sh} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{isay-sh-bw} }
    \end{center}
  \end{minipage}\quad
  \begin{minipage}{.52\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{isay-c} }%
      \mode<article>{ \includegraphics[width=.8\textwidth]{isay-c-bw} }
    \end{center}
  \end{minipage}
\end{frame}

\begin{frame}{Parameter Substitution}
  \begin{block}{Default value}\ttfamily
    \begin{multicols}{2}
      \begin{itemize}
      \item[\$] echo \$\{s:=abc\}
      \item[\$] echo \$\{s:=xyz\}
      \item[\$] echo \$\{v:-8\}
      \item[\$] echo \$\{v:-10\}
      \end{itemize}
    \end{multicols}
  \end{block}
  \begin{block}{Example}
    \begin{center}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=.6\textwidth]{para-substitution-sh} }%
        \mode<article>{ \includegraphics[width=.4\textwidth]{para-substitution-sh-bw} }
      \end{center}
    \end{center}
  \end{block}
\end{frame}
% file:///usr/share/doc/abs-guide/html/parameter-substitution.html

\begin{frame}{Parameter Substitution}
  \begin{block}{Substring removal}
    \CMD{for f in *.pbm; do ppm2tiff \$f \$\{f\%pbm\}tif; done}
  \end{block}
  \begin{block}{Substring replacement}
    \CMD{for f in *.jpg; do mv \$f \$\{f/jpg/JPG\}; done}
  \end{block}  
\end{frame}

\begin{frame}{Environmental Variables}
  \begin{block}{Each process has an environment}\ttfamily\small
    \begin{center}
      \begin{tabular}{lllll}
        \$PATH&\$PWD&\$HOME&\$UID&\$USER\\
        \$GROUPS&\$SHELL&\$TERM&\$DISPLAY&\$TEMP\\
        \$HOSTNAME&\$HOSTTYPE&\$IFS&\$EDITOR&\$BROWSER\\
        \$HISTSIZE&\$FUNCNAME&\$TMOUT&\ldots&\\
      \end{tabular}
    \end{center}
    \begin{itemize}
    \item[] export HISTSIZE=2000
    \item[] export BROWSER='/usr/bin/x-www-browser'
    \item[] export EDITOR='vim'
    \item[] export ALTERNATE\_EDITOR="vim"
    \item[] export PDFVIEWER='/usr/bin/zathura'
    \end{itemize}
  \end{block}
  {\ttfamily
    \begin{itemize}
    \item[\$] env
    \item[\$] declare
    \end{itemize}}
\end{frame}

\begin{frame}[allowframebreaks]{Tests}\small\ttfamily
  \begin{itemize}
  \item[\$] (( 5 < 6 )) \&\& echo should be
  \item[\$] [[ 1 < 2 ]] \&\& echo of course
  \item[\$] [[ \$a -lt \$b ]] \&\& echo yes || echo no
  \item[\$] if [[ \$a -lt \$b ]]; then echo yes; else echo no; fi
  \item[\$] if test \$a -lt \$b; then echo of course; fi
  \item[\$] if a = 5; then echo a=\$a; fi \# whitespace matters \wrong
  \item[\$] if a=5; then echo a=\$a; fi \Bad
  \item[\$] if test a=5; then echo a=\$a; fi \Bad
  \item[\$] if test a = 5; then echo a=\$a; fi \Bad
  \item[\$] if test \$a = 5; then echo a=\$a; fi \correct
  \item[\$] test \$a = 5 \&\& echo a=\$a \correct
  \item[\$] [[ \$a = 5 ]] \&\& echo a=\$a \correct
  \item[\$] [[ cmp a b ]] \&\& echo same file \wrong
  \item[\$] if test cmp a b; then echo same file; fi \wrong
  \item[\$] if cmp a b; then echo same file; fi \correct
  \item[\$] [[ -f \symbol{`~}/.bash\_aliases ]] \&\& . \symbol{`~}/.bash\_aliases
  \item[\$] [[ -x /usr/bin/xterm ]] \&\& /usr/bin/xterm -e tmux \&
  \item[\$] [[ "\$pass" != "\$MYPASS" ]] \&\& echo 'Wrong password!' \&\& exit 1
  \item[\$] help test
  \end{itemize}
  \begin{block}{}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.7\textwidth]{if-then-else-sh} }%
      \mode<article>{ \includegraphics[width=.4\textwidth]{if-then-else-sh-bw} }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Loops}{\ttfamily for ARG in LIST; do COMMAND(s); done}\small\ttfamily
\begin{itemize}
\item[\$] for i in 1 2 3; do echo -n i="\$i "; done
\item[\$] for i in \{1..10\}; do echo \$i; done
\item[\$] for i in \$(seq 10); do echo \$i; done
\item[\$] for ((i=1; i<=10; i++)); do echo \$i; done
\item[\$] for ((i=1, j=1; i<=10; i++, j++)); do\\
  \quad{}echo \$i-\$j \Bad\\
  \quad{}echo \$((\$i-\$j)) \Good\\
  done
\item[\$] for ((i=1; i<=10; i++)) \{ echo \$i; \} \# C style
\item[\$] for i in hello world; do echo -n "\$i "; done
\end{itemize}
\end{frame}

\begin{frame}{Loops}{\ttfamily while CONDITION; do COMMAND(s); done}\small\ttfamily
\begin{itemize}
\item[\$] a=0; while [[ a < 10 ]]; do echo \$a; ((a++)); done \Bad
\item[\$] while [[ \$a < 10 ]]; do echo \$a; ((a++)); done \Bad
\item[\$] while [[ \$a -lt 10 ]]; do echo \$a; ((a++)); done \correct
\item[\$] while [ \$a -lt 10 ]; do echo \$a; ((a++)); done \correct
\item[\$] while (( a < 10 )); do echo \$a; ((a++)); done \correct
\item[\$] until (( a = 10 )); do echo \$a; ((a++)); done \Bad
\item[\$] until (( a == 10 )); do echo \$a; ((a++)); done \correct
\item[\$] while read n; do n2 \$n; done
\item[\$] while read n; do n2 \$n; done < datafile
\item[\$] until (( n == 0 )); do read n; n2 \$n; done
\end{itemize}
\end{frame}

\begin{frame}{\texttt{case}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{n2-sh} }%
    \mode<article>{ \includegraphics[width=.8\textwidth]{n2-sh-bw} }
  \end{center}
\end{frame}

\begin{frame}{\texttt{select}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{select-sh} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{select-sh-bw} }
  \end{center}
\end{frame}

\begin{frame}{Functions}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{func-sh} }%
    \mode<article>{ \includegraphics[width=.8\textwidth]{func-sh-bw} }
  \end{center}
\end{frame}

\begin{frame}{Array}
  \url{https://www.tutorialspoint.com/unix/unix-using-arrays.htm}
  
\end{frame}

\lecture{C Programming Basics}{C basics}
\section{C Programming Basics}
\label{sec:c-programming-basics}

\subsection{Programming Environment}
\label{sec:progr-envir}

\begin{frame}{Program Languages}
  \begin{block}{Machine code}
    The \alert{binary numbers} that the CPUs can understand.
    \begin{center}{\ttfamily
      100111000011101111001111 ... and so on ...}
    \end{center}
  \end{block}
  \begin{block}{Assembly language --- friendly to humans}
    People don't think in numbers.
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.5\textwidth]{asm-sample-asm} }%
      \mode<article>{ \includegraphics[width=.2\textwidth]{asm-sample-asm} }
    \end{center}
    The ASM programs are translated to machine code by \alert{assemblers}.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{High level languages}
    Even easier to understand for humans. Examples:
    \begin{itemize}
    \item C\tikzmark{clang}
    \item FORTRAN\tikzmark{fortran}
    \item Java\tikzmark{java}
    \item C++\tikzmark{cpp}
    \item ...\tikzmark{more}
    \end{itemize}\pause
    \alert{Compilers} do the translation work.    
  \end{block}
  \begin{tikzpicture}[remember picture,overlay,
    every node/.style={ellipse,red,opacity=.4,draw},
    every to/.style={append after command={[->,black!30,thick]}}
    ]
    \node (asm) at ($(pic cs:java) + (3,0)$) {Assembly};
    \node (bin) [right=of asm] {Binary};
    \draw ($(pic cs:clang)+(0,.5ex)$) to [bend left=20] (asm);
    \draw ($(pic cs:fortran)+(0,.5ex)$) to [bend left=15] (asm);
    \draw ($(pic cs:java)+(0,.5ex)$) to (asm);
    \draw ($(pic cs:cpp)+(0,.5ex)$) to [bend right=15] (asm);
    \draw ($(pic cs:more)+(0,.5ex)$) to [bend right=20] (asm);
    \draw (asm) to (bin);
    \end{tikzpicture}
\end{frame}

\subsubsection{The Tool Chain}
\label{sec:tool-chain}

\begin{frame}{Compilation}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{tool-chain} }%
    \mode<article>{ \includegraphics[width=.9\textwidth]{tool-chain} }
  \end{center}
\end{frame}

\begin{description}
\item[Source code] written by programmer in high-level language, in our case in
  \texttt{C}. We write c source code with a \emph{text editor}, such as \texttt{emacs},
  \texttt{vim}, etc.
\item[Preprocessing] is the first pass of any C compilation. It processes
  \texttt{include-files}, \texttt{conditional compilation instructions} and
  \texttt{macros}.
  \begin{description}
  \item[cpp] The GNU C preprocessor
    \begin{itemize}
    \item[\$] \texttt{gcc -E hello.c}
    \end{itemize}
  \end{description}
\item[{Compilation}] is the second pass. It takes the output of the preprocessor, and the
  \texttt{source code}, and generates \texttt{assembly source code}.
  \begin{description}
  \item[gcc/g++] GNU C/C++ compiler
    \begin{itemize}
    \item[\$] \texttt{gcc -S hello.c}
    \end{itemize}
  \end{description}
\item[Assembly] is the third stage of compilation. It takes the assembly source code and
  produces an assembly listing with offsets. The assembler output is stored in an
  \texttt{object file}.
  \begin{description}
  \item[as] the portable GNU assembler
    \begin{itemize}
    \item[\$] \texttt{gcc -c hello.c}
    \end{itemize}
  \end{description}
\item[Linking] is the final stage of compilation. It combines object code with predefined
  routines from \texttt{libraries} and produces the \texttt{executable program}.
  \begin{description}
  \item[ld] The GNU linker
    \begin{itemize}
    \item[\$] \texttt{gcc hello.c -lm}
    \end{itemize}
  \end{description}
\item[{Wrapper}] The whole compilation process is usually not done `by hand', but using a
  \texttt{wrapper} program that combines the functions of preprocessor(cpp),
  compiler(gcc/g++), assembler(as) and linker(ld).
  \begin{itemize}
  \item[\$] \texttt{gcc -Wall hello.c -lm -o hello}
  \end{itemize}
\end{description}

\begin{frame}[fragile]{Compiler vs. Interpreter}
  \begin{block}{\texttt{hello.c}}
    \begin{minipage}{.5\linewidth}
\begin{ccode}
#include <stdio.h>
int main()
{
  printf("Hello, world!\n");
  return 0;
}
\end{ccode}
    \end{minipage}
    \begin{minipage}{.45\linewidth}
    \begin{itemize}
    \item[\$] \texttt{gcc -o hello hello.c}
    \item[\$] \texttt{./hello}
    \end{itemize}
    \end{minipage}
    %\textcolor{LightGray}{\rule{.3\textwidth}{1pt}}
  \end{block}
  \begin{block}{\texttt{hello.sh}}
    \begin{minipage}{.5\linewidth}
      \begin{shellcode}
        #!/bin/bash
        echo 'Hello, world!'
      \end{shellcode}
    \end{minipage}
    \begin{minipage}{.45\linewidth}
      \begin{enumerate}
      \item[\$] \texttt{chmod +x hello.sh}
      \item[\$] \texttt{./hello.sh}
      \end{enumerate}
    \end{minipage}
  \end{block}
  \begin{block}{\texttt{hello.py}}
    \begin{minipage}{.5\linewidth}
\begin{pythoncode}
#!/usr/bin/python
print "Hello, world!"
\end{pythoncode}      
    \end{minipage}
    \begin{minipage}{.45\linewidth}
      \begin{enumerate}
      \item[\$] \texttt{chmod +x hello.py}
      \item[\$] \texttt{./hello.py}
      \end{enumerate}
    \end{minipage}
  \end{block}
\end{frame}

\subsubsection{Header Files}
\label{sec:header-files}

\begin{frame}[fragile]{Header Files}
  \begin{minipage}{.45\linewidth}
    \begin{block}{Why?}
\begin{ccode}
#include "add.h"

int triple(int x)
{
  return add(x, add(x,x));
}
\end{ccode}
    \end{block}
  \end{minipage}\qquad
  \begin{minipage}{.45\linewidth}
    \begin{block}{Why not?}
\begin{ccode}
int add(int, int);

int triple(int x)
{
  return add(x, add(x, x));
}
\end{ccode}
    \end{block}
  \end{minipage}\\[1ex]
  \begin{itemize}
  \item Ensure everyone use the same code
  \item Easy to share, upgrade, reuse
  \end{itemize}
  \begin{block}{In the header files\ldots}
    \begin{multicols}{2}
      \begin{itemize}
      \item function declarations
      \item macro definitions
      \item contants
      \item system wide global variables
      \end{itemize}
    \end{multicols}
  \end{block}
  \begin{itemize}
  \item[\$] \texttt{ls /usr/include/}
  \end{itemize}
\end{frame}

\subsubsection{Library Files}
\label{sec:library-files}

\begin{frame}{Library Files}
  \begin{description}
  \item[Static libraries] \alert{\texttt{.a}} files. Very old ones, but still alive.
    \begin{itemize}
    \item[\$] \texttt{find /usr/lib -name "*.a"}
    \end{itemize}
  \item[Shared libraries] \alert{\texttt{.so}} files. The preferred ones.
    \begin{itemize}
    \item[\$] \texttt{find /usr/lib -name "*.so.*"}
    \end{itemize}
  \end{description}
  Examples:
  \begin{itemize}
  \item[\$] \texttt{gcc -o hello hello.c /usr/lib/libm.a}
  \item[\$] \texttt{gcc -o hello hello.c -lm}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{block}{Static Linking}
    \begin{itemize}
    \item The entire program and all data of a process must be in physical memory for the
      process to execute
    \item The size of a process is thus limited to the size of physical memory
    \end{itemize}
  \end{block}
    \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{static-linking} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{static-linking} }
  \end{center}
\end{frame}

\begin{frame}
  \begin{block}{Dynamic Linking}
    \begin{itemize}
    \item Only one copy in memory
    \item Don't have to re-link after a library update
    \end{itemize}
  \end{block}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{dynamic-linking} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{dynamic-linking} }
  \end{center}
\end{frame}

\begin{frame}{Build A Static Library}{Source codes}
  \begin{minipage}[t]{.47\linewidth}
    \begin{block}{\texttt{main.c}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{main-c} }%
        \mode<article>{ \includegraphics[width=.7\textwidth]{main-c-bw} }
      \end{center}
    \end{block}
    \begin{block}{\texttt{lib.h}}
      \mode<beamer>{\includegraphics[width=.5\textwidth]{lib-h}}%
      \mode<article>{\includegraphics[width=.5\textwidth]{lib-h-bw}}%
    \end{block}
  \end{minipage}\qquad
  \begin{minipage}[t]{.43\linewidth}
    \begin{block}{\texttt{hello.c}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{hello-c} }%
        \mode<article>{ \includegraphics[width=.7\textwidth]{hello-c-bw} }
      \end{center}
    \end{block}
    \begin{block}{\texttt{hi.c}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{hi-c} }%
        \mode<article>{ \includegraphics[width=.7\textwidth]{hi-c-bw} }
      \end{center}
    \end{block}
  \end{minipage}
\end{frame}

\begin{frame}{Build A Static Library}{Step by step}
  \begin{enumerate}
  \item Get \alert{\texttt{hello.o}} and \alert{\texttt{hi.o}}
    \begin{itemize}
    \item[\$] \texttt{gcc -c hello.c hi.c}
    \end{itemize}
  \item Put \alert{\texttt{*.o}} into \alert{\texttt{libhi.a}}
    \begin{itemize}
    \item[\$] \texttt{ar crv libhi.a hello.o hi.o}
    \end{itemize}
  \item Use \alert{\texttt{libhi.a}}
    \begin{itemize}
    \item[\$] \texttt{gcc main.c libhi.a}
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}{Build A Static Library}{Makefile}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{makefile-a} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{makefile-a-bw} }
  \end{center}
\end{frame}

\begin{frame}{Build A Shared Library}{Source codes}
  \begin{block}{\texttt{hello.c}}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.8\textwidth]{hello-c-so} }%
      \mode<article>{ \includegraphics[width=.6\textwidth]{hello-c-so-bw} }
    \end{center}
  \end{block}
  \begin{minipage}{.35\linewidth}
    \begin{block}{\texttt{hello.h}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{hello-h-so} }%
        \mode<article>{ \includegraphics[width=.6\textwidth]{hello-h-so-bw} }
      \end{center}
    \end{block}
  \end{minipage}\qquad
  \begin{minipage}{.36\linewidth}
    \begin{block}{\texttt{hi.c}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{hi-c-so} }%
        \mode<article>{ \includegraphics[width=.6\textwidth]{hi-c-so-bw} }
      \end{center}
    \end{block}
  \end{minipage}
\end{frame}

\begin{frame}{Build A Shared Library}{Step by step}
  \begin{enumerate}
  \item Get \alert{\texttt{hi.o}}
    \begin{itemize}
    \item[\$] \texttt{gcc -fPIC -c hi.c}
    \end{itemize}
  \item Get \alert{\texttt{libhi.so}}
    \begin{itemize}
    \item[\$] \texttt{gcc -shared -o libhi.so hi.o}
    \end{itemize}
  \item Use \alert{\texttt{libhi.so}}
    \begin{itemize}
    \item[\$] \texttt{gcc -L. -Wl,-rpath=. hello.c -lhi}
    \end{itemize}
  \item Check it
    \begin{itemize}
    \item[\$] \texttt{ldd a.out}
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}{Build A Shared Library}{Makefile}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{makefile-so} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{makefile-so-bw} }
  \end{center}
\end{frame}

\begin{frame}{GNU C Library}
  \begin{minipage}{.55\linewidth}
    Linux API > POSIX API
    \begin{itemize}
    \item[\$] \cmd{man 7 libc}
    \item[\$] \cmd{man 3 intro}
    \item[\$] \cmd{man gcc}
    \item[\$] \cmd{info gcc}
    \item[\debian] \cmd{sudo apt install gcc-doc}
    \end{itemize}
  \end{minipage}
  \begin{minipage}{.4\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{api} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{api} }
    \end{center}
  \end{minipage}
\end{frame}

\subsubsection{Error Handling}
\label{sec:error-handling}

\begin{frame}{\texttt{errno.h}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.6\textwidth]{perror-c} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{perror-c-bw} }
  \end{center}\ttfamily
  \begin{itemize}
  \item[\$] man errno
  \item[\$] man errno.h
  \item[\$] man perror
  \end{itemize}
\end{frame}

\begin{itemize}
\item \citetitle[Sec.~1.7]{stevens2013advanced}
\item \url{https://stackoverflow.com/questions/30078281/raise-error-in-a-bash-script}
\end{itemize}

\subsubsection{The Make Utility}

\begin{frame}{The Make Utility}
  To compile a single C program:
  \begin{itemize}
  \item[\$] \cmd{gcc hello.c -o hello}\quad{\Huge \correct}\textsubscript{{\tiny OK. But\ldots}}
    % \tikz \node [opacity=.4,red,scale=3,inner
    % sep=0pt,label={[below=2.5ex,right]{\tiny OK. But...}}] {\Checked};
  \end{itemize}
  \begin{block}{What if you have a large project with 1000+ files?}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{tree} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{tree} }
    \end{center}
    \begin{description}
    \item[Linux 4.9 source tree:] 3799 directories, 55877 files
    \end{description}
  \end{block}
  \begin{description}
  \item[make:] help you maintain your programs.
  \end{description}
\end{frame}

\begin{frame}{Makefile}
  \begin{block}{}
      \mode<beamer>{ \includegraphics[width=.5\textwidth]{mktab1} }%
      \mode<article>{ \includegraphics[width=.3\textwidth]{mktab1-bw} }
  \end{block}
  \begin{block}{Example}
      \mode<beamer>{ \includegraphics[width=.6\textwidth]{mktab2} }%
      \mode<article>{ \includegraphics[width=.4\textwidth]{mktab2-bw} }
  \end{block}
  \begin{itemize}
  \item[\$] \cmd{info make makefiles}
  \end{itemize}
\end{frame}

\begin{frame}{Makefile}
  \begin{minipage}{.75\linewidth}
    \mode<beamer>{ \includegraphics[width=1.1\textwidth]{Makefile2-mk} }%
    \mode<article>{
      \begin{center}
        \includegraphics[width=.8\textwidth]{Makefile2-mk}
      \end{center}}
  \end{minipage}
  \begin{minipage}{.2\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{make-dir-tree} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{make-dir-tree} }
    \end{center}
  \end{minipage}
\end{frame}

\subsubsection{Version Control}
\label{sec:version-control}

\begin{frame}{git}
  \begin{block}{To create a new local git repo}
    In your source code directory, do:\ttfamily
    \begin{itemize}
    \item[\$] git init
    \item[\$] git add .
    \item[\$] git commit -m "something to say\ldots"
    \end{itemize}
  \end{block}
  \begin{block}{To clone a remote repo}
    Example:\ttfamily
    \begin{itemize}
    \item[\$] git clone https://github.com/wx672/lecture-notes.git
    \item[\$] git clone https://github.com/wx672/dotfile.git
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Most commonly used git Commands}\ttfamily
    \begin{itemize}
    \item[\$] git add filename[s]
    \item[\$] git rm filename[s]
    \item[\$] git commit
    \item[\$] git status
    \item[\$] git log
    \item[\$] git diff
    \item[\$] git push
    \item[\$] git pull
    \item[\$] git help \{add,rm,commit,\ldots\}
    \end{itemize}
  \end{block}
  \begin{multicols}{2}
    \begin{itemize}
    \item[\$] man gittutorial
    \item[\$] man gittutorial-2
    \item[\debian] sudo apt install git
    \item[\github] \url{https://github.com}
    \end{itemize}
  \end{multicols}
\end{frame}

\subsubsection{Manual Pages}
\label{sec:manual-pages}

\begin{frame}{Man page}{Layout}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{manpage-txt} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{manpage-txt} }
  \end{center}
\end{frame}

\begin{frame}{Man Page}{Groff source code}
  \begin{minipage}[b]{.6\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=1.6\textwidth]{manpage-1} }%
      \mode<article>{ \includegraphics[width=1.2\textwidth]{manpage-1-bw} }
    \end{center}
  \end{minipage}
  \begin{minipage}[b]{.35\linewidth}\ttfamily
    \begin{itemize}
    \item[\$] man 7 groff
    \item[\$] man txt2man
    \item[\$] man a2x
    \item[\$] ls /usr/share/man
    \end{itemize}
  \end{minipage}
\end{frame}

\subsubsection{A Sample GNU Package}
\label{sec:sample-gnu-package}

\begin{frame}{How to ``Do one thing, and do it well''?}  
  \begin{itemize}
  \item[\$] \cmd{apt source hello}
  \end{itemize}
\end{frame}

\subsection{OS Basics}
\label{sec:os-basics}

\begin{frame}<beamer>{Operating System}
  \centering
  \includegraphics[height=.85\textheight]{kernel-block}
\end{frame}

\begin{frame}{Abstractions}{To hide the complexity of the actual implementations}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{abstraction} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{abstraction} }
  \end{center}
\end{frame}

See also: \citetitle[Sec.~1.9.2, \emph{The Importance of Abstractions in Computer
  Systems}]{Bryant2010computersystems}.

\begin{frame}{A Computer System}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-1-1} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{mos-figs-1-1} }
  \end{center}
\end{frame}

\subsubsection{Hardware}
\label{sec:cpu}

\begin{frame}{CPU Working Cycle}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.6\textwidth]{mos-figs-1-6} }%
    \mode<article>{ \includegraphics[width=.3\textwidth]{mos-figs-1-6} }
  \end{center}
  \begin{enumerate}
  \item Fetch the first instruction from memory
  \item Decode it to determine its type and operands
  \item execute it
  \end{enumerate}
  \begin{block}{Special CPU Registers}
    \begin{description}
    \item[Program counter (PC):] keeps the memory address of the next instruction to
      be fetched
    \item[Stack pointer (SP):] {\symbola ☛} the top of the current stack in memory
    \item[Program status (PS):] holds
      \begin{itemize}
      \item[-] condition code bits
      \item[-] processor state
      \end{itemize}
    \end{description}
  \end{block}
\end{frame}

\begin{frame}{System Bus}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-1-5} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{mos-figs-1-5} }
  \end{center}
  \begin{description}
  \item[Address Bus:] specifies the memory locations (addresses) for the
    data transfers
  \item[Data Bus:] holds the data transfered. Bidirectional
  \item[Control Bus:] contains various lines used to route timing and
    control signals throughout the system
  \end{description}
\end{frame}

\begin{frame}{Controllers and Peripherals}
  \begin{itemize}
  \item Peripherals are real devices controlled by controller chips
  \item Controllers are processors like the CPU itself, have control registers
  \item Device driver writes to the registers, thus control it
  \item Controllers are connected to the CPU and to each other by a variety of buses
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-1-11} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{mos-figs-1-11} }
  \end{center}
\end{frame}

\begin{frame}{Motherboard Chipsets}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{chipsets} }
    \mode<article>{ \includegraphics[width=.5\textwidth]{chipsets-bw} }
  \end{center}
\end{frame}

See also:
\href{http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map}{\emph{Motherboard
    Chipsets And The Memory Map}}
\footnote{\url{http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map}}.

\begin{frame}
  \begin{itemize}
  \item The CPU doesn't know what it's connected to
    \begin{itemize}
    \item[-] CPU test bench?\quad{}network router?\quad{}toaster?\quad{}brain implant?
    \end{itemize}
  \item The CPU talks to the outside world through its pins
    \begin{itemize}
    \item[-] some pins to transmit the physical memory address
    \item[-] other pins to transmit the values
    \end{itemize}
  \item The CPU's gateway to the world is the \alert{front-side bus}
  \end{itemize}
  \begin{block}{Intel Core 2 QX6600}
    \begin{itemize}
    \item 33 pins to transmit the physical memory address
      \begin{itemize}
      \item[-] so there are $2^{33}$ choices of memory locations
      \end{itemize}
    \item 64 pins to send or receive data
      \begin{itemize}
      \item[-] so data path is 64-bit wide, or 8-byte chunks
      \end{itemize}
    \end{itemize}
    This allows the CPU to physically address 64GB of memory ($2^{33}\times{}8B$)    
  \end{block}
\end{frame}

See also:
\href{http://download.intel.com/design/processor/datashts/31559205.pdf}{\emph{Datasheet
    for Intel Core 2 Quad-Core Q6000 Sequence}}
\footnote{\url{http://download.intel.com/design/processor/datashts/31559205.pdf}}.

\begin{frame}[plain]
  \begin{minipage}{.65\linewidth}
    \begin{block}{Some physical memory addresses are mapped away!}
      \begin{itemize}
      \item only the addresses, not the spaces
      \item Memory holes
        \begin{itemize}
        \item[-] 640 KiB~\symbol{`~}~1 MiB
        \item[-] \texttt{/proc/iomem}
        \end{itemize}
      \end{itemize}
    \end{block}
    \begin{block}{Memory-mapped I/O}
      \begin{itemize}
      \item BIOS ROM
      \item video cards
      \item PCI cards
      \item \ldots
      \end{itemize}
      This is why 32-bit OSes have problems using 4 GiB of RAM.
    \end{block}
  \end{minipage}\quad
  \begin{minipage}{.3\linewidth}
    \tikz[baseline,overlay]{
      \node [xshift=1.4cm,yshift=-1cm] at (0,0) {
        \includegraphics[scale=0.6]{boot-mem}}}
  \end{minipage}
  % \begin{center}
  %   What if you don't have 4G RAM?
  % \end{center}
\end{frame}

\begin{frame}
  \begin{block}{the northbridge}
    \begin{enumerate}
    \item receives a physical memory request
    \item decides where to route it
      \begin{itemize}
      \item[-] to RAM? to video card? to \ldots{}?
      \item[-] decision made via the \alert{memory address map}
      \end{itemize}
    \end{enumerate}
  \end{block}
\end{frame}

\begin{itemize}
\item When is the memory address map built? \texttt{setup()}.
\end{itemize}

\subsubsection{Bootstrapping}
\label{sec:bootstrapping}

\begin{frame}{Bootstrapping}
  \begin{block}{Can you pull yourself up by your own bootstraps?}
    \begin{itemize}
    \item[] A computer cannot run without first loading software but must be running
      before any software can be loaded.
    \end{itemize}
  \end{block}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{boot}}%
    \mode<article>{ \includegraphics[width=.7\textwidth]{boot-bw}}
  \end{center}
\end{frame}

\begin{frame}{Intel x86 Bootstrapping}
  \begin{enumerate}
  \item BIOS (\texttt{0xfffffff0})\\
    \begin{small}
      {\Symbol{➠}} POST\quad
      {\Symbol{➠}} HW init\quad
      {\Symbol{➠}} Find a boot device (FD,CD,HD\ldots{})\quad
      {\Symbol{➠}} Copy \alert{sector zero (MBR)} to RAM (\texttt{0x00007c00})
    \end{small}
  \item MBR -- the first 512 bytes, contains
    \begin{itemize}
    \item Small code ($< 446\,B$), e.g. GRUB stage 1, for loading GRUB stage 2
    \item the primary partition table ($16\times{}4=64\,B$)
    \item its job is to load the second-stage boot loader.
    \end{itemize}
  \item GRUB stage 2 --- load the OS kernel into RAM
  \item {\linux} startup
  \item init --- the first user-space process
  \end{enumerate}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{mbr}}%
    \mode<article>{ \includegraphics[width=.5\textwidth]{mbr}}
  \end{center}
  \qquad\CMD{sudo hd -n512 /dev/sda}
\end{frame}


\lecture{Interrupt}{int}
\subsubsection{Interrupt}
\label{sec:interrupt}

\begin{frame}{Why Interrupt?}
  \begin{block}{While a process is reading a disk file, can we do...}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.6\textwidth]{interrupt}}%
      \mode<article>{ \includegraphics[width=.3\textwidth]{interrupt-bw}}
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Modern OS are Interrupt Driven}
  \begin{description}
  \item[HW INT] by sending a signal to CPU
  \item[SW INT] by executing a \alert{system call}
  \item[Trap (exception)] is a software-generated INT coursed by an error or by a
    specific request from an user program
  \item[Interrupt vector] is an array of pointers {\pright} the memory addresses
    of \alert{interrupt handlers}. This array is indexed by a unique device number
    \begin{itemize}
    \item[\$] \cmd{less /proc/devices}
    \item[\$] \cmd{less /proc/interrupts}
    \end{itemize}
  \end{description}
\end{frame}

\begin{frame}{Programmable Interrupt Controllers}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{int-osdi-34}}%
    \mode<article>{ \includegraphics[width=.5\textwidth]{int-osdi-34}}
  \end{center}
\end{frame}

\begin{frame}{Interrupt Processing}
  % \includegraphics[width=.9\textwidth]{int-mos-figs-5-6}\\
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-1-10} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{mos-figs-1-10} }
  \end{center}
\end{frame}

Detailed explanation: in \citetitle[Sec.~1.3.5, \emph{I/O Devices}]{tanenbaum2015modern}.

\begin{frame}{Interrupt Timeline}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{ir-timeline} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{ir-timeline} }
  \end{center}
\end{frame}


\lecture{System Calls}{syscall}
\subsubsection{System Calls}
\label{sec:system-calls}

\begin{frame}{System Calls}
  \begin{block}{A System Call}
    \begin{itemize}
    \item is how a program requests a service from an OS kernel
    \item provides the interface between a process and the OS
    \end{itemize}
  \end{block}
  \begin{itemize}
  \item[\$] \cmd{man 2 intro}
  \item[\$] \cmd{man 2 syscalls}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \mode<beamer>{ \includegraphics[height=\textheight]{syscall} }%
    \mode<article>{ \includegraphics[width=.45\textwidth]{syscall} }
  \end{center}
\end{frame}

\begin{frame}{The 11 steps in making a system call}{\texttt{read(fd,buffer,nbytes)}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{mos-figs-1-18} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{mos-figs-1-18} }
  \end{center}
\end{frame}

\begin{frame}{Example}{Linux \texttt{INT 80h}}
  \begin{description}
  \item[Interrupt Vector Table:] The very first 1KiB of x86 memory. 
    \begin{itemize} 
    \item 256 entries $\times$ 4B = 1KiB
    \item Each entry is a complete memory address (\texttt{segment:offset})
    \item It's populated by Linux and BIOS
    \item Slot \texttt{80h}: address of the kernel services dispatcher ({\pright} sys-call table)
    \end{itemize}
  \end{description}
\end{frame}

\begin{frame}{Example}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{h-asm} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{h-asm-bw} }
  \end{center}
  \begin{block}{}
    \ttfamily
    \begin{enumerate}
    \item[\$] nasm -f elf64 hello.asm -o hello.o
    \item[\$] ld hello.o -o hello
    \item[\$] ./hello
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}%{System Calls}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.75\textwidth]{mos-figs-1-19} }
    \mode<article>{ \includegraphics[width=.7\textwidth]{mos-figs-1-19} }
  \end{center}
\end{frame}

\begin{frame}{System Call Examples}
  \begin{block}{\cmd{fork()}}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.8\textwidth]{fork} }%
      \mode<article>{ \includegraphics[width=.4\textwidth]{fork-bw} }
    \end{center}
  \end{block}
  \qquad\CMD{man 2 fork}
\end{frame}

\begin{frame}
  \begin{block}{\cmd{execve()}}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{fork-exec} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{fork-exec-bw} }
    \end{center}
  \end{block}\ttfamily
  \begin{itemize}
  \item[\$] man 2 execve
  \item[\$] man 3 exec
  \end{itemize}
\end{frame}

Quoted from
\href{https://stackoverflow.com/questions/20823371/what-is-the-difference-between-the-functions-of-the-exec-family-of-system-calls}{
  stackoverflow: What is the difference between the functions of the \emph{exec} family of system calls}:

\begin{quote}
  There is no \emph{exec} system call --- this is usually used to refer to all the
  \emph{execXX} calls as a group. They all do essentially the same thing: loading a new
  program into the current process, and provide it with arguments and environment
  variables. The differences are in how the program is found, how the arguments are
  specified, and where the environment comes from.

  \begin{itemize}
  \item The calls with \emph{v} in the name take an array parameter to specify the
    \texttt{argv[]} array (\emph{vector}) of the new program.
  \item The calls with \emph{l} in the name take the arguments of the new program as a
    variable-length argument \emph{list} to the function itself.
  \item The calls with \emph{e} in the name take an extra argument to provide the
    \emph{environment} of the new program; otherwise, the program inherits the current
    process's environment.
  \item The calls with \emph{p} in the name search the \emph{PATH} environment variable to
    find the program if it doesn't have a directory in it (i.e. it doesn't contain a /
    character). Otherwise, the program name is always treated as a path to the executable.
  \end{itemize}
\end{quote}

\section{The Linux Environment}
\label{sec:linux-environment}

\begin{frame}{Command Line Options}{\texttt{getopt.c}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{getopt-c} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{getopt-c-bw} }
  \end{center}
  \qquad\qquad\CMD{man 3 getopt}
\end{frame}

\begin{frame}{Command Line Options}{\texttt{getopt.sh}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.9\textwidth]{getopt-sh} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{getopt-sh-bw} }
  \end{center}
  \ttfamily
  \begin{itemize}
  \item[\$] ./getopt.sh -h
  \item[\$] ./getopt.sh -lf filename
  \item[\$] ./getopt.sh -l -f filename
  \item[\$] ./getopt.sh -f filename -l
  \end{itemize}
\end{frame}

\begin{frame}{Environment Variable}
  \begin{minipage}{.5\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{env-c} }%
      \mode<article>{ \includegraphics[width=.6\textwidth]{env-c-bw} }
    \end{center}
  \end{minipage}\quad
  \begin{minipage}{.45\linewidth}
  \ttfamily
  \begin{itemize}
  \item[\$] env
  \item[\$] man 3 getenv
  \item[\$] man 3 putenv
  \end{itemize}  
  \end{minipage}
\end{frame}

\citetitle[p.147, Sec. The \texttt{environ} Variable]{matthew2008beginning}

\begin{frame}{Time and Date}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{time-c} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{time-c-bw} }
  \end{center}
  \begin{itemize}
  \item January 1 1970 --- start of the Unix epoch
  \item[\$] \cmd{man 3 time}
  \item[\$] \cmd{man 3 ctime}
  % \item[\$] \cmd{man 3 strftime} (\texttt{sprintf()} for time and date)
  \end{itemize}
\end{frame}

\begin{frame}{Temporary Files}
  \ttfamily
  \begin{minipage}[t]{.55\linewidth}
    \begin{block}{\texttt{mkstemp.c}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{mkstemp-c} }%
        \mode<article>{ \includegraphics[width=.8\textwidth]{mkstemp-c-bw} }
      \end{center}
    \end{block}
  \end{minipage}\qquad
  \begin{minipage}[t]{.35\linewidth}
    \begin{block}{\texttt{mktemp.sh}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{mktemp-sh} }%
        \mode<article>{ \includegraphics[width=.7\textwidth]{mktemp-sh-bw} }
      \end{center}
    \end{block}
    \begin{itemize}
    \item[\$] man 3 mkstemp
    \item[\$] man 3 tmpfile
    \item[\$] man 3 asprintf
    \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}{Logging}
  \begin{block}{\ttfamily syslog.c}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.8\textwidth]{syslog-c} }%
      \mode<article>{ \includegraphics[width=.6\textwidth]{syslog-c-bw} }
    \end{center}
  \end{block}
  \begin{block}{\ttfamily logger.sh}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{logger-sh} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{logger-sh-bw} }
    \end{center}
  \end{block}
  % \ttfamily
  % \begin{itemize}
  % \item[\$] man 3 syslog
  % \item[\$] man logger
  % \end{itemize}
\end{frame}

\section{Working With Files}
\label{sec:working-with-files}

\subsection{File}
\label{sec:file}

\begin{frame}{File}{A logical view of information storage}
  \begin{block}{User's view}
    A file is the smallest storage unit on disk.
    \begin{itemize}
    \item Data cannot be written to disk unless they are within a file
    \end{itemize}
  \end{block}
  \begin{block}{UNIX view}
    Each file is a sequence of 8-bit bytes
    \begin{itemize}
    \item It's up to the application program to interpret this byte stream.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{File}{What is stored in a file?}
  Source code, object files, executable files, shell scripts, PostScript...
  \begin{block}{Different type of files have different structure}
    \begin{itemize}
    \item UNIX looks at contents to determine type
      \begin{description}
      \item[Shell scripts] start with ``\texttt{\#!}''
      \item[PDF] start with ``\texttt{\%PDF...}''
      \item[Executables] start with \alert{magic number}
      \end{description}
    \item Windows uses file naming conventions
      \begin{description}
      \item[executables] end with ``\texttt{.exe}'' and ``\texttt{.com}''
      \item[MS-Word] end with ``\texttt{.doc}''
      \item[MS-Excel] end with ``\texttt{.xls}''
      \end{description}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{File Types}
  \begin{description}
  \item[Regular files:] ASCII, binary
  \item[Directories:] Maintaining the structure of the FS
  \end{description}
  \begin{block}{In UNIX, everything is a file}
    \begin{description}
    \item[Character special files:] I/O related, such as terminals, printers ...
    \item[Block special files:] Devices that can contain file systems, i.e. disks
      \begin{itemize}
      \item[Disks] --- logically, linear collections of blocks; disk driver translates
        them into physical block addresses
      \end{itemize}
    \end{description}
  \end{block}
\end{frame}

\begin{frame}{File Operations}{POSIX file system calls}%[squeeze]
  \begin{tabular}{>{\ttfamily}l|>{\ttfamily}l}
    creat(name, mode)&read(fd, buffer, byte\_count)\\
    open(name, flags)&write(fd, buffer, byte\_count)\\
    close(fd)&lseek(fd, offset, whence)\\
    link(oldname, newname)&chown(name, owner, group\\
    unlink(name)&fchown(fd, owner, group)\\        
    truncate(name, size)&chmod(name, mode\\
    ftruncate(fd, size)&fchmod(fd, mode)\\
    stat(name, buffer)&utimes(name, times)\\
    fstat(fd, buffer)&\\
  \end{tabular}
\end{frame}

\begin{frame}{File System Implementation}
  \begin{block}{A typical file system layout}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{fs-layout} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{fs-layout} }
    \end{center}
  \end{block}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{mbr} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{mbr} }
  \end{center}
\end{frame}

\begin{frame}{On-Disk Information Structure}
  \begin{description}
  \item[Boot block] a MBR copy
  \item[Superblock] Contains volume details
    \begin{center}
      \begin{tabular}{ll}
        number of blocks& size of blocks\\
        free-block count& free-block pointers\\
        free FCB count& free FCB pointers
      \end{tabular}
    \end{center}
  \item[I-node] Organizes the files \alert{FCB (File Control Block)},
    contains file details (metadata).
  \end{description}
\end{frame}

\begin{frame}
  \begin{block}{Superblock}
    Keeps information about the file system
    \begin{itemize}
    \item Type --- ext2, ext3, ext4...
    \item Size
    \item Status --- how it's mounted, free blocks, free inodes, ...
    \item Information about other metadata structures
    \end{itemize}
  \end{block}
  \begin{itemize}
  \item[\$] \cmd{sudo dumpe2fs /dev/sda1 | less}
  \end{itemize}
\end{frame}

\begin{frame}{Implementing Files}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{file-alloc-contiguous} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{file-alloc-contiguous} }
  \end{center}
  \begin{block}{Contiguous Allocation}
    \begin{multicols}{2}
      \begin{itemize}
      \item[\Good] simple
      \item[\Good] good for read only
      \item[\Bad] fragmentation
      \end{itemize}
    \end{multicols}
  \end{block}
\end{frame}

\begin{frame}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{file-alloc-chained} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{file-alloc-chained} }
  \end{center}
  \begin{block}{Linked List (Chained) Allocation}
    A pointer in each disk block
    \begin{multicols}{2}
      \begin{itemize}
      \item[\Good] no waste block
      \item[\Bad] slow random access
      \item[\Bad] not $2^n$
      \end{itemize}
    \end{multicols}
  \end{block}
\end{frame}

\begin{frame}
  \begin{description}
  \item[Linked List (Chained) Allocation] Though there is no external fragmentation,
    consolidation is still preferred.
  \end{description}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{file-alloc-chained2} }%
    \mode<article>{\label{fig:chained2} \includegraphics[width=.5\textwidth]{file-alloc-chained2} }
  \end{center}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item[FAT:] Linked list allocation with a table in RAM
  \end{itemize}
  \begin{minipage}{.59\textwidth}
    \begin{block}{}
      \begin{itemize}
      \item Taking the pointer out of each disk block, and putting it into a table in
        memory
      \item fast random access (chain is in RAM)
      \item is $2^n$
      \item the entire table must be in RAM
        $$disk\nearrow{}\Rightarrow FAT\nearrow{}\Rightarrow RAM_{used}\nearrow$$
      \end{itemize}
    \end{block}
  \end{minipage}\quad
  \begin{minipage}{.35\textwidth}
      \mode<beamer>{ \includegraphics[width=\textwidth]{fat} }%
      \mode<article>{ \includegraphics[width=.8\textwidth]{fat} }
  \end{minipage}
\end{frame}

See also: \citetitle[\emph{Wikipedia:FAT}]{wiki:fat}.

\begin{frame}{Indexed Allocation}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{file-alloc-idx} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{file-alloc-idx} }
  \end{center}
  \begin{description}
  \item[I-node] A data structure for each file. An i-node is in memory \emph{only if} the
    file is open
    $$files_{opened}\nearrow{}\Rightarrow{}RAM_{used}\nearrow{}$$
  \end{description}
\end{frame}

See also: \citetitle[\emph{Wikipedia:inode}]{wiki:inode}.

\begin{frame}<beamer>{I-node}
  \begin{tikzpicture}[remember picture, overlay]
    \node [scale=.8,anchor=south west] at (current page.south west)
    {\includegraphics{osc-11-28}};
        
    \node [scale=.7,xshift=-5em,yshift=-5em,anchor=north east,align=left]
    at (current page.north east) {%
      \begin{tabular}{cl}\hline
        \thead{File type}&\thead{Description}\\\hline
        0&Unknown\\
        1&Regular file\\
        2&Directory\\
        3&Character device\\
        4&Block device\\
        5&Named pipe\\
        6&Socket\\
        7&Symbolic link\\\hline
      \end{tabular}\\[1ex]\textbf{Mode:} 9-bit pattern};
  \end{tikzpicture}
\end{frame}

\begin{frame}{UNIX Treats a Directory as a File}
  \mode<article>{\includegraphics[width=.7\textwidth]{inode-struct}}%
  \mode<beamer>{ \hspace{-2.5em}
    \begin{tikzpicture}[remember picture, overlay]
      \node [scale=.29,anchor=south west] at (current page.south west)
      {\includegraphics{inode-struct}};
        
      \node [scale=.7,xshift=-5em,yshift=-5em,anchor=north east] at (current page.north east) {
        \begin{tabular}{|l|l|}
          \hline
          .&2\\\hline
          ..&2\\\hline
          bin&11116545\\\hline
          boot&2\\\hline
          cdrom&12\\\hline
          dev&3\\\hline
          \vdots&\vdots
        \end{tabular}}; 
    \end{tikzpicture}}
\end{frame}

\begin{frame}{\texttt{open()}}
  \begin{description}
    \item[Why?] To avoid constant searching
    \begin{itemize}
    \item Without \texttt{open()}, every file operation involves searching the directory for
      the file.
    \end{itemize}
  \end{description}
  The steps in looking up \texttt{/usr/ast/mbox}
  \begin{center}\label{fig:dir-lookup}
    \mode<beamer>{ \includegraphics[width=.9\textwidth]{04-35} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{04-35} }
  \end{center}
\end{frame}

\begin{frame}
  \begin{block}{\texttt{fd open(pathname, flags)}}
    \begin{itemize}
    \item[] A per-process \alert{open-file table} is kept in the OS
      \begin{itemize}
      \item upon a successful \texttt{open()} syscall, a new entry is added into this table
      \item indexed by \alert{file descriptor (fd)}
      \item \texttt{close()} to remove an entry from the table
      \end{itemize}
    \item[] To see files opened by a process, e.g. \texttt{init}
      \begin{itemize}
      \item[\$] \cmd{lsof -p 1}
      \end{itemize}
    \end{itemize}
  \end{block}
    \qquad\CMD{man 2 open}
\end{frame}

\begin{frame}
  \begin{block}{A process executes the following code:}\ttfamily
    \begin{itemize}
    \item[] fd1 = open("/etc/passwd", O\_RDONLY);
    \item[] fd2 = open("local", O\_RDWR);
    \item[] fd3 = open("/etc/passwd", O\_WRONLY);
    \end{itemize}
  \end{block}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.6\textwidth]{file-tables2} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{file-tables2} }
  \end{center}
\end{frame}

\begin{frame}
  \begin{block}{One more process B:}\ttfamily
    \begin{itemize}
    \item[] fd1 = open("/etc/passwd", O\_RDONLY);
    \item[] fd2 = open("private", O\_RDONLY);
    \end{itemize}
  \end{block}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{file-tables3} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{file-tables3} }
  \end{center}
\end{frame}

\begin{frame}
  \begin{minipage}[t]{.53\linewidth}
    \begin{block}{\texttt{write()}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{write-c} }%
        \mode<article>{ \includegraphics[width=.7\textwidth]{write-c-bw} }
      \end{center}
    \end{block}
    \ttfamily
    \begin{itemize}
    \item[\$] man 2 write
    \item[\$] man 3 write
    \end{itemize}
  \end{minipage}\qquad
  \begin{minipage}[t]{.37\linewidth}
    \begin{block}{\texttt{read()}}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{read-c} }%
        \mode<article>{ \includegraphics[width=.7\textwidth]{read-c-bw} }
      \end{center}
    \end{block}
    \ttfamily
    \begin{itemize}
    \item[\$] man 2 read
    \item[\$] man 3 read
    \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}{\cmd{cp}}
  \begin{center}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.95\textwidth]{cp-syscall-c} }%
      \mode<article>{ \includegraphics[width=.8\textwidth]{cp-syscall-c-bw} }
    \end{center}
  \end{center}
\end{frame}

\begin{frame}{\texttt{stdio} --- The Standard I/O Library}
  \begin{description}
  \item[System calls:] \cmd{open(), read(), write(), close()}\ldots
  \item[Library functions:] \cmd{fopen(), fread(), fwrite, fclose()}\ldots
  \end{description}
  \begin{block}{Avoid calling syscalls directly as much as you can}
    \begin{minipage}{.4\linewidth}
      \begin{itemize}
      \item Portability
      \item Buffered I/O
      \end{itemize}
    \end{minipage}\qquad
    \begin{minipage}{.4\linewidth}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=\textwidth]{api} }%
        \mode<article>{ \includegraphics[width=.5\textwidth]{api} }
      \end{center}
    \end{minipage}
  \end{block}  
\end{frame}

\begin{frame}{\texttt{open()} {\scriptsize vs.} \texttt{fopen()}}
  \begin{center}
    \begin{minipage}{.48\linewidth}
      \cmd{open()}\\[1ex]
      \mode<beamer>{\includegraphics[width=\linewidth]{open-c}\\[1ex]}%
      \mode<article>{\includegraphics[width=\linewidth]{open-c-bw}\\[1ex]}
      \CMD{strace -c ./open}
    \end{minipage}\quad
    \begin{minipage}{.48\linewidth}
      \cmd{fopen()} --- Buffered I/O\\[1ex]
      \mode<beamer>{\includegraphics[width=\linewidth]{fopen-c}\\[1ex]}%
      \mode<article>{\includegraphics[width=\linewidth]{fopen-c-bw}\\[1ex]}
      \CMD{strace -c ./fopen}
    \end{minipage}
  \end{center}{\footnotesize
  \begin{itemize}
  \item[\$] \cmd{dd if=/dev/zero of=/tmp/1m.test bs=1k count=1024}
  \end{itemize}}
\end{frame}

\url|https://stackoverflow.com/questions/1658476/c-fopen-vs-open|

\begin{frame}{\texttt{cp} --- {\small With} \texttt{stdio}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.6\textwidth]{cp-libc-c} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{cp-libc-c-bw} }
  \end{center}
  \begin{description}
  \item[Homework:] Try \texttt{fread()/fwrite()} instead.
  \end{description}
\end{frame}

\url|https://stackoverflow.com/questions/32742430/is-getc-a-macro-or-a-function|
\url|https://stackoverflow.com/questions/9104568/macro-vs-function-in-c|

\subsection{Directory}
\label{sec:directory}

\begin{frame}{Implementing Directories}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-6-16} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{mos-figs-6-16} }
  \end{center}
  \begin{itemize}
  \item[(a)] A simple directory (Windows)
    \begin{itemize}
    \item fixed size entries
    \item disk addresses and attributes in directory entry
    \end{itemize}
  \item[(b)] Directory in which each entry just refers to an i-node (UNIX)
  \end{itemize}
\end{frame}

\begin{frame}%{Directory}
  \begin{block}{Directory entry in \texttt{glibc}}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{dirent-c} }%
      \mode<article>{ \includegraphics[width=.6\textwidth]{dirent-c-bw} }
    \end{center}
  \end{block}
  \begin{itemize}
  \item[\$] \cmd{man readdir}
  \item[\$] \cmd{view /usr/include/x86\_64-linux-gnu/bits/dirent.h}
  \end{itemize}
\end{frame}

\begin{frame}{Ext2 Directories}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{ext2dir2} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{ext2dir2} }
  \end{center}
  \begin{minipage}{.39\textwidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{ext2dir} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{ext2dir} }
    \end{center}
  \end{minipage}\quad
  \begin{minipage}{.55\textwidth}
    \begin{itemize}
    \item Directories are special files
    \item ``\texttt{.}'' and ``\texttt{..}'' first
    \item Padding to $4\times{}$
    \item inode number is 0 --- deleted file
    \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}{\ttfamily ls}
  \mode<beamer>{%
    \begin{tikzpicture}[remember picture, overlay]%
      \node [scale=.27,opacity=.5,anchor=east] at (current page.east)%
      {\includegraphics{ls-real}};
    \end{tikzpicture}}
  
  \begin{minipage}{.6\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{ls-c} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{ls-c-bw} }
    \end{center}
  \end{minipage}\quad
  \begin{minipage}{.35\linewidth}
    \begin{description}
    \item[The real \texttt{ls.c}?] 
    \end{description}
    \mode<beamer>{
    \begin{flushright}
      \begin{large}
        116 A4 pages\\
        5308 lines\\[1em]
        Do one thing, and do it really well.\\[2em]
      \end{large}
    \end{flushright}
    {\small \CMD{apt source coreutils}}}
  \mode<article>{
    \begin{itemize}
    \item 116 A4 pages
    \item 5308 lines
    \end{itemize}
    Do one thing, and do it really well.
    \begin{itemize}
    \item[\$] \cmd{apt source coreutils}
    \end{itemize}}
  \end{minipage}  
\end{frame}

\begin{frame}{\ttfamily mkdir(), chdir(), rmdir(), getcwd()}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.9\textwidth]{mkdir-c} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{mkdir-c-bw} }
  \end{center}
\end{frame}

\begin{frame}{Hard Links}
  \begin{block}{Hard links {\pright} the same inode}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{hard-link} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{hard-link} }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Drawback}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{hardlink-drawback} }%
      \mode<article>{ \includegraphics[width=.4\textwidth]{hardlink-drawback} }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Symbolic Links}
  \begin{block}{A symbolic link has its own inode {\pright} a directory entry}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.9\textwidth]{soft-link} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{soft-link} }
    \end{center}
  \end{block}
  \begin{description}
  \item[Fast symbolic link:] Short path name ($< 60\,chars$) needs no data block. Can be
    stored in the 15 pointer fields
  \end{description}
\end{frame}

\begin{frame}{\ttfamily link(), unlink(), symlink()}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{link-c} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{link-c-bw} }
  \end{center}
\end{frame}


% \subsection{The \texttt{/proc} File System}
% \label{sec:textttpr-file-syst}

% \begin{frame}{\texttt{/proc}}

% \end{frame}

\lecture{The Linux Environment}{Linux Environment}


\lecture{Process}{proc}
\section{Processes and Threads}
\label{sec:processes-threads}

\subsection{Process}
\label{sec:process}

\begin{frame}{Process}
  \begin{description}
  \item[A process] is an instance of a program in execution
  \end{description}
  \begin{minipage}{.65\linewidth}
    \begin{block}{\mbox{Processes are like human beings:}}
        \begin{itemize}
        \item[\Symbol{➠}] they are generated
        \item[\Symbol{➠}] they have a life
        \item[\Symbol{➠}] they optionally generate one or more child processes, and
        \item[\Symbol{➠}] eventually they die
        \end{itemize}
        A small difference:
        \begin{itemize}
        \item sex is not really common among processes
        \item each process has just one parent
        \end{itemize}
      \end{block}
  \end{minipage}\quad
  \begin{minipage}{.3\linewidth}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-1-20} }%
      \mode<article>{ \includegraphics[width=.5\textwidth]{mos-figs-1-20} }
    \end{center}
  \end{minipage}
\end{frame}

\begin{frame}{Process Control Block (PCB)}
  \begin{varwidth}{.7\textwidth}
    \begin{block}{Implementation}
        A process is \alert{the collection of data structures} that fully describes how far
        the execution of the program has progressed.
        \begin{itemize}
        \item Each process is represented by a \alert{PCB}
        \item \texttt{task\_struct} in \linux{}
        \end{itemize}
      \end{block}
    \end{varwidth}\quad
    \begin{varwidth}{.2\textwidth}
      \begin{center}
        \mode<beamer>{ \includegraphics[width=1.5\textwidth]{pcb} }%
        \mode<article>{ \includegraphics[width=\textwidth]{pcb} }
      \end{center}      
    \end{varwidth}
\end{frame}

\begin{frame}{Process Creation}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{process-creation} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{process-creation} }
  \end{center}
  \begin{itemize}
  \item When a process is created, it is almost identical to its parent
    \begin{itemize}
    \item It receives a (logical) copy of the parent's address space, and
    \item executes the same code as the parent
    \end{itemize}
  \item The parent and child have separate copies of the data (stack and heap)
  \end{itemize}
\end{frame}

\begin{frame}{Process State Transition}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-2-2} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{mos-figs-2-2} }
  \end{center}
\end{frame}

\begin{frame}{CPU Switch From Process To Process}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{cpu-switch} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{cpu-switch} }
  \end{center}
\end{frame}

\begin{frame}{Forking in C}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{fork} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{fork-bw} }
  \end{center}
\end{frame}

\begin{frame}{\texttt{exec()}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{fork-exec-osc} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{fork-exec-osc-bw} }
  \end{center}
\end{frame}

\paragraph{More about \texttt{argv[0]}}

\texttt{int execve(const char *pathname, char *const argv[], char *const envp[]);}
\begin{itemize}
\item \texttt{pathname} should be the binary image of a program. Or it can be a script
  (\cmd{man 2 execve});
\item \texttt{argv[0]} is the new process name, usually the same as the basename of
  \texttt{pathname}, though it can be any other string. It can even be NULL (see
  Figure~\ref{fig:argv0} for example).

  The fact that \texttt{argv[0]} contains the name used to invoke the program can be
  employed to perform a useful trick. We can create multiple links to (i.e., names for)
  the same program, and then have the program look at \texttt{argv[0]} and take different
  actions depending on the name used to invoke it. An example of this technique is
  provided by the \emph{gzip(1)}, \emph{gunzip(1)}, and \emph{zcat(1)} commands, all of
  which are links to the same executable
  file. \citetitle[Sec.~6.6]{Kerrisk:2010:LPI:1869911}
\item \url{https://stackoverflow.com/questions/2794150/when-can-argv0-have-null}
\item \url{https://stackoverflow.com/questions/36673765/why-can-the-execve-system-call-run-bin-sh-without-any-argv-arguments-but-not}
\end{itemize}

\begin{figure}
  \centering
  \begin{minipage}{.4\linewidth}
    \begin{center}
      \includegraphics[width=\textwidth]{caller-c-bw}
      \caption{\texttt{caller.c}}
    \end{center}
  \end{minipage}\qquad
  \begin{minipage}{.4\linewidth}
    \begin{center}
      \includegraphics[width=\textwidth]{callee-c-bw}
      \caption{\texttt{callee.c}}
    \end{center}
  \end{minipage}\\[1em]
  \ttfamily
  \begin{itemize}
  \item[\$] gcc -Wall caller.c -o caller.out
  \item[\$] gcc -Wall callee.c -o callee.out
  \item[\$] ./caller.out ./callee.out
  \end{itemize}
  \caption{\texttt{argv[0]} can be NULL}
  \label{fig:argv0}
\end{figure}

\subsection{Thread}
\label{sec:thread}

\begin{frame}{Process vs. Thread}
    \begin{tabular}{r@{\quad{}=\quad}l}
      a single-threaded process&resource + execution\\
      a  multi-threaded process&resource + executions\\
    \end{tabular}
    \begin{center}
      \mode<beamer>{ \includegraphics[width=.7\textwidth]{mos-figs-2-6} }%
      \mode<article>{ \includegraphics[width=.6\textwidth]{mos-figs-2-6} }
    \end{center}
  \begin{description}
  \item[A process] = a unit of resource ownership, used to group resources together;
  \item[A thread] = a unit of scheduling, scheduled for execution on the CPU.
  \end{description}  
\end{frame}

\begin{frame}{Threads}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{thread-components} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{thread-components} }
  \end{center}
\end{frame}

\begin{frame}{POSIX Threads}
  \begin{description}
  \item[IEEE 1003.1c] The standard for writing portable threaded programs. The threads package it
    defines is called \alert{Pthreads}, including over 60 function calls, supported by most UNIX
    systems.
  \end{description}
  \begin{block}{Some of the Pthreads function calls}
    \begin{center}
      \begin{small}
        \begin{tabularx}{\textwidth}{>{\ttfamily}lX}
          \hline
          \thead{Thread call}&\thead{Description}\\\hline
          pthread\_create&Create a new thread\\
          pthread\_exit&Terminate the calling thread\\
          pthread\_join&Wait for a specific thread to exit\\
          pthread\_yield&Release the CPU to let another thread run\\
          pthread\_attr\_init&Create and initialize a thread's attribute structure\\
          pthread\_attr\_destroy&Remove a thread's attribute structure\\\hline
        \end{tabularx}
      \end{small}
    \end{center}
  \end{block}
\end{frame}

\begin{frame}{Pthreads}{Example 1}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{thread1} }%
    \mode<article>{ \includegraphics[width=\textwidth]{thread1-bw} }
  \end{center}
\end{frame}

\begin{frame}{Pthreads}
  \begin{description}
  \item[\texttt{pthread\_t}] defined in \texttt{pthread.h}, is often called a "thread id"
    (\texttt{tid});
  \item[\texttt{pthread\_create()}] returns zero on success and a non-zero value on failure;
  \item[\texttt{pthread\_join()}] returns zero on success and a non-zero value on failure;
  \end{description}
  \begin{block}{How to use pthread?}
    \begin{itemize}
    \item \texttt{\#include<pthread.h>}
    \item[\$] \texttt{gcc thread1.c -o thread1 -pthread}
    \item[\$] \texttt{./thread1}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Pthreads}{Example 2}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{thread2} }%
    \mode<article>{ \includegraphics[width=.8\textwidth]{thread2-bw} }
  \end{center}
\end{frame}

\begin{frame}{Linux Threads}
  \begin{block}{To the Linux kernel, there is no concept of a thread}
    \begin{itemize}
    \item Linux implements all threads as standard processes
    \item To Linux, a thread is merely a process that shares certain resources with other
      processes
    \item Some OS (MS Windows, Sun Solaris) have cheap threads and expensive processes.
    \item Linux processes are already quite lightweight
      \begin{itemize}
      \item[] On a 75MHz Pentium
        \begin{tabular}{r}
          thread: $1.7\mu{}s$\\
          fork: $1.8\mu{}s$
        \end{tabular}
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Linux Threads}
  \begin{description}
  \item[\texttt{clone()}] creates a separate process that shares the address space of the
    calling process. The cloned task behaves \emph{much like} a separate thread.
  \end{description}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.55\textwidth]{syscall} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{syscall} }
  \end{center}
\end{frame}

\begin{frame}{\texttt{clone()}}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{clone-prototype} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{clone-prototype-bw} }
  \end{center}
  \begin{small}
    \begin{description}
    \item[arg 1] the function to be executed, i.e. \texttt{fn(arg)}, which returns an \texttt{int};
    \item[arg 2] a pointer {\pright} a (usually malloced) memory space to be used as
      the stack for the new thread;
    \item[arg 3] a set of flags used to indicate how much the calling process is to be
      shared. In fact,
      \begin{itemize}
      \item[]  \texttt{clone(0) == fork()}
      \end{itemize}
    \item[arg 4] the arguments passed to the function.
    \end{description}
    It returns the PID of the child process or -1 on failure.
  \end{small}
  \begin{itemize}
    \item[\$] \texttt{man clone}
  \end{itemize}
\end{frame}

\begin{frame}{The \texttt{clone()} System Call}
  \begin{block}{Some flags:}
    \begin{center}
      \begin{tabular}{>{\ttfamily}ll}
        \hline
        \thead{flag}&\thead{Shared}\\\hline
        CLONE\_FS&File-system info\\
        CLONE\_VM&Same memory space\\
        CLONE\_SIGHAND&Signal handlers\\
        CLONE\_FILES&The set of open files\\\hline
      \end{tabular}
    \end{center}
  \end{block}
  \begin{block}{In practice, one should try to avoid calling \texttt{clone()} directly}
    \begin{itemize}
    \item[] Instead, use a threading library (such as pthreads) which use \texttt{clone()}
      when starting a thread (such as during a call to \texttt{pthread\_create()})
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{\texttt{clone()} Example}
  \begin{center}
    \mode<beamer>{
      \includegraphics[width=\textwidth]{clone2}
      \pause
      \begin{tikzpicture}[remember picture, overlay]
        \node [yshift=-7em,xshift=5em,rotate=-20,scale=6,text opacity=0.7,color=red] at
        (current page.center) {\Symbol{✘}};
      \end{tikzpicture}
    } \mode<article>{ \includegraphics[width=.45\textwidth]{clone2-bw-crop} }
  \end{center}
\end{frame}

\begin{frame}[fragile]{Stack Grows Downwards}
\begin{ccode}
child_stack = (void**)malloc(8192) + 8192/sizeof(*child_stack);
\end{ccode}
  \mode<beamer>{
    \begin{tikzpicture}[remember picture, overlay]
      \node [yshift=-0.1em,xshift=9em,rotate=0,scale=12,text opacity=0.7,color=red] at
      (current page.center) {\Symbol{✔}};
    \end{tikzpicture}}
\end{frame}

\subsection{Signals}
\label{sec:signals}

\begin{itemize}
\item Singals are software interrupts. Every signal has a name (SIGXXXX). Signals are
  classic examples of asynchronous events. They occur at what appear to be random times to
  the process. The process can't simply test a variable (such as \texttt{errno}) to see
  whether a signal has occurred; instead, the process has to tell the kernel ``if and when
  this signal occurs, do the following.'' \citetitle[chap. 10]{stevens2013advanced}
\item Signals are software interrupts sent to a program to indicate that an important
  event has occurred. The events can vary from user requests to illegal memory access
  errors. Some signals, such as the interrupt signal, indicate that a user has asked the
  program to do something that is not in the usual flow of
  control. (\url{https://www.tutorialspoint.com/unix/unix-signals-traps})
\item Signals are similar to interrupts, the difference being that interrupts are mediated
  by the processor and handled by the kernel while signals are mediated by the kernel
  (possibly via system calls) and handled by processes. The kernel may pass an interrupt
  as a signal to the process that caused it (typical examples are SIGSEGV, SIGBUS, SIGILL
  and SIGFPE). (\url{https://en.wikipedia.org/wiki/Signal_(IPC)})
\item signal(7)
\item[\$] \cmd{trap -l}
\end{itemize}

\begin{frame}{Signals}
  \begin{itemize}
  \item Singals are software interrupts
  \item Every signal has a name (SIGXXXX)
  \item One process can send a signal to another process
  \end{itemize}
  \begin{block}{Sending signals}
    \begin{itemize}
    \item[\$] \Cc, \Cz, \ldots
    \item[\$] \cmd{kill -signal <pid>}
    \end{itemize}
  \end{block}
  \begin{block}{Trapping signals}
    \begin{itemize}
    \item[\#!] \cmd{trap <command> <signals>}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Trap}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.5\textwidth]{trap1-sh} }%
    \mode<article>{ \includegraphics[width=.4\textwidth]{trap1-sh-bw} }
  \end{center}\ttfamily
  \begin{itemize}
  \item[\#!] trap "rm -rf \$tmpfiles" EXIT
  \end{itemize}
\end{frame}

\begin{frame}{Example}{SIGINT}
\begin{center}
  \mode<beamer>{ \includegraphics[trim={0 0 0 12em},width=.6\textwidth]{shell2-c} }%
  \mode<article>{ \includegraphics[width=.7\textwidth]{shell2-c-bw} }
\end{center}
\end{frame}

\begin{itemize}
\item \url{https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work}
\end{itemize}

\begin{frame}{Example}{SIGUSR1}
  \begin{minipage}{.5\linewidth}
  \mode<beamer>{ \includegraphics[width=\textwidth]{sigusr-c} }%
  \mode<article>{ \includegraphics[width=\textwidth]{sigusr-c-bw} }    
  \end{minipage}\quad
  \begin{minipage}{.4\linewidth}\ttfamily
    \begin{itemize}
    \item[\$] kill -USR1 <PID>
    \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}{Example}{SIGALRM}
  \begin{minipage}{.45\linewidth}
  \mode<beamer>{  \includegraphics[clip,trim={0 13em 0 0},width=\textwidth]{alarm-c} }%
  \mode<article>{ \includegraphics[clip,trim={0 13em 0 0},width=\textwidth]{alarm-c-bw} }    
  \end{minipage}\quad
  \begin{minipage}{.45\linewidth}
  \mode<beamer>{  \includegraphics[clip,trim={0 0 0 17.5em},width=\textwidth]{alarm-c} }%
  \mode<article>{ \includegraphics[clip,trim={0 0 0 17.5em},width=\textwidth]{alarm-c-bw} }    
  \end{minipage}
\end{frame}


\lecture{IPC}{ipc}
\section{IPC}
\label{sec:ipc}

\subsection{Pipes and FIFOs}
\label{sec:pipes-fifos}

\begin{itemize}
\item \citetitle[chap.~44]{Kerrisk:2010:LPI:1869911}
\end{itemize}

\begin{frame}{Pipe}
  \begin{itemize}
  \item[\$] \cmd{ls | wc -l}
  \end{itemize}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{pipe-ls-wc} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{pipe-ls-wc} }
  \end{center}
  \begin{itemize}
  \item A pipe is a byte stream
  \item Unidirectional
  \item \texttt{read()} would be blocked if nothing written at the other end
  \end{itemize}
  \ttfamily
  \begin{block}{tee}
    \begin{center}
      \begin{minipage}{.35\linewidth}
        \begin{itemize}
        \item[\$] ls | tee ls.out
        \end{itemize}
      \end{minipage}\quad
      \begin{minipage}{.55\linewidth}
        \mode<beamer>{ \includegraphics[width=\textwidth]{tee} }%
        \mode<article>{ \includegraphics[width=.6\textwidth]{tee} }
      \end{minipage}
    \end{center}
  \end{block}
\end{frame}

\begin{itemize}
\item When we say that a pipe is a byte stream, we mean that there is no concept of
  messages or message boundaries when using a pipe. The process reading from a pipe can
  read blocks of data of any size, regardless of the size of blocks written by the writing
  process. Furthermore, the data passes through the pipe sequentially --- bytes are read from
  a pipe in exactly the order they were written. It is not possible to randomly access the
  data in a pipe using \texttt{lseek()}. \citetitle[chap.~44]{Kerrisk:2010:LPI:1869911}
\end{itemize}


\begin{frame}
\begin{center}
  \mode<beamer>{ \includegraphics[width=.6\textwidth]{pipe} }%
  \mode<article>{ \includegraphics[width=.4\textwidth]{pipe} }
\end{center}
\begin{itemize}
\item No direct link between A and B
\item A pipe is simply a buffer maintained in kernel memory
  \begin{itemize}
  \item[\$] \cmd{cat /proc/sys/fs/pipe-max-size}
  \end{itemize}
\item Need system calls
\end{itemize}
\end{frame}

\begin{frame}{\texttt{pipe()}}
  \begin{center}
    \begin{minipage}{.35\linewidth}
      \mode<beamer>{ \includegraphics[width=\textwidth]{pipe-prototype-c} }%
      \mode<article>{ \includegraphics[width=.7\textwidth]{pipe-prototype-c-bw} }
    \end{minipage}\quad
    \begin{minipage}{.35\linewidth}
      \mode<beamer>{ \includegraphics[width=\textwidth]{pipe1} }%
      \mode<article>{ \includegraphics[width=.8\textwidth]{pipe1} }
    \end{minipage}
  \end{center}
  \begin{description}
  \item[\texttt{pipe()} + \texttt{fork()}]
  \end{description}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.7\textwidth]{pipe2} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{pipe2} }
  \end{center}
\end{frame}

\begin{itemize}
\item Pipes must have a reader and a writer. If a process tries to write to a pipe that
  has no reader, it will be sent the SIGPIPE signal from the kernel. This is imperative
  when more than two processes are involved in a
  pipeline. (\url{http://www.tldp.org/LDP/lpg/node20.html})
\item While it is possible for the parent and child to both read from and write to the
  pipe, this is not usual. Therefore, immediately after the \texttt{fork()}, one process
  closes its descriptor for the write end of the pipe, and the other closes its descriptor
  for the read end. For example, if the parent is to send data to the child, then it would
  close its read descriptor for the pipe, \texttt{filedes[0]}, while the child would close
  its write descriptor for the pipe, \texttt{filedes[1]}.
  
  One reason that it is not usual to have both the parent and child reading from a single
  pipe is that if two processes try to simultaneously read from a pipe, we can't be sure
  which process will be the first to succeed—the two processes race for data.  Preventing
  such races would require the use of some synchronization mechanism.  However, if we
  require bidirectional communication, there is a simpler way: just create two pipes, one
  for sending data in each direction between the two processes.  (If employing this
  technique, then we need to be wary of deadlocks that may occur if both processes block
  while trying to read from empty pipes or while trying to write to pipes that are already
  full.) \citetitle[chap.~44, p.~893]{Kerrisk:2010:LPI:1869911}
\item Pipes can be used for communication between any two (or more) related processes, as
  long as the pipe was created by a common ancestor before the series of \texttt{fork()}
  calls that led to the existence of the processes. For example, a pipe could be used for
  communication between a process and its grandchild. The first process creates the pipe,
  and then forks a child that in turn forks to yield the grandchild. A common scenario is
  that a pipe is used for communication between two siblings --- their parent creates the
  pipe, and then creates the two children. This is what the shell does when building a
  pipeline.
\item \textbf{Closing unused pipe file descriptors}. The process reading from the pipe
  closes its write descriptor for the pipe, so that, when the other process completes its
  output and closes its write descriptor, the reader sees end-of-file (once it has read
  any outstanding data in the pipe).  If the reading process doesn't close the write end
  of the pipe, then, after the other process closes its write descriptor, the reader won't
  see end-of-file, even after it has read all data from the pipe. Instead, a
  \texttt{read()} would block waiting for data, because the kernel knows that there is
  still at least one write descriptor open for the pipe. That this descriptor is held open
  by the reading process itself is irrelevant; in theory, that process could still write
  to the pipe, even if it is blocked trying to read.  For example, the \texttt{read()}
  might be interrupted by a signal handler that writes data to the pipe.

  The writing process closes its read descriptor for the pipe for a different reason.
  When a process tries to write to a pipe for which no process has an open read
  descriptor, the kernel sends the SIGPIPE signal to the writing process. By default, this
  signal kills a process. A process can instead arrange to catch or ignore this signal, in
  which case the \texttt{write()} on the pipe fails with the error EPIPE (broken
  pipe). Receiving the SIGPIPE signal or getting the EPIPE error is a useful indication
  about the status of the pipe, and this is why unused read descriptors for the pipe
  should be closed.

  If the writing process doesn't close the read end of the pipe, then, even after the
  other process closes the read end of the pipe, the writing process will still be able to
  write to the pipe. Eventually, the writing process will fill the pipe, and a further
  attempt to write will block indefinitely.

  One final reason for closing unused file descriptors is that it is only after all file
  descriptors in all processes that refer to a pipe are closed that the pipe is destroyed
  and its resources released for reuse by other processes. At this point, any unread data
  in the pipe is lost.
\end{itemize}

\begin{frame}
  \begin{center}
    \mode<beamer>{ \includegraphics[clip,trim={0 0 0 8.5em},width=.65\textwidth]{simple_pipe-c} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{simple_pipe-c-bw} }
  \end{center}
\end{frame}

\begin{itemize}
\item
  \url{https://stackoverflow.com/questions/5422831/what-is-the-difference-between-using-exit-exit-in-a-conventional-linux-fo}
\item \texttt{\_exit(2)}
\end{itemize}

\begin{frame}{\texttt{popen()}}

\end{frame}

\begin{frame}{Named Pipe (FIFO)}
  \begin{description}
  \item[PIPEs] pass data between related processes.
  \item[FIFOs] pass data between any processes.
  \end{description}
  \begin{block}{\CMD{mkfifo myfifo}}
    \begin{center}
      \begin{minipage}{.45\linewidth}\ttfamily
        \begin{itemize}
        \item[\$] echo hello > myfifo
        \item[\$] cat myfifo
        \end{itemize}
      \end{minipage}\quad
      \begin{minipage}{.5\linewidth}
        \mode<beamer>{ \includegraphics[width=\textwidth]{fifo} }%
        \mode<article>{ \includegraphics[width=.6\textwidth]{fifo} }
      \end{minipage}
    \end{center}
  \end{block}
  \ttfamily
  \begin{block}{tee}
    \begin{minipage}{.5\linewidth}
      \begin{itemize}
      \item[\$] echo hello | tee myfifo
      \item[\$] wc myfifo
      \end{itemize}
    \end{minipage}\quad
    \begin{minipage}{.45\linewidth}
      \mode<beamer>{ \includegraphics[width=\textwidth]{fifo-tee} }%
      \mode<article>{ \includegraphics[width=.6\textwidth]{fifo-tee} }
    \end{minipage}
  \end{block}
\end{frame}

\begin{itemize}
\item \url{https://en.wikipedia.org/wiki/Named_pipe}
\end{itemize}

\begin{frame}{IPC With FIFO}
  \mode<beamer>{ \includegraphics[width=\textwidth]{fifo2-ipc} }%
  \mode<article>{ \includegraphics[width=\textwidth]{fifo2-c-bw} }
\end{frame}

\begin{frame}{}{}
  {\ttfamily
    \begin{itemize}
    \item[\$] watch 'lsof -n.1 /tmp/myfifo'
    \item[\$] ./a.out O\_RDONLY
    \item[\$] ./a.out O\_WRONLY
    \item[\$] ./a.out O\_RDONLY O\_NONBLOCK
    \item[\$] ./a.out O\_WRONLY O\_NONBLOCK
    \end{itemize}}
  \begin{block}{\texttt{O\_NONBLOCK}}
    \begin{itemize}
    \item A \texttt{read()/write()} will wait on an empty blocking FIFO
    \item A \texttt{read()} on an empty nonblocking FIFO will return 0 bytes
    \item \cmd{open(const char *path, O\_WRONLY | O\_NONBLOCK);}
      \begin{itemize}
      \item Returns an error (-1) if FIFO not open
      \item Okay if someone's reading the FIFO
      \end{itemize}
    \item If opened with \texttt{O\_RDWR}, the result is undefined
    \end{itemize}
  \end{block}
\end{frame}

\begin{itemize}
\item If opened with \texttt{O\_RDWR}, the result is undefined. If you do want to pass
  data in both directions, it's much better to use a pair of FIFOs or pipes, one for each
  direction.
\item There are four legal combinations of \texttt{O\_RDONLY}, \texttt{O\_WRONLY}, and the
  \texttt{O\_NONBLOCK} flag. 
  \begin{center}
    \includegraphics[width=\textwidth]{o_nonblock-c-bw}
  \end{center}
\end{itemize}

\subsection{Semaphores}
\label{sec:semaphores}

\begin{frame}{Race Conditions}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=.8\textwidth]{mos-figs-2-18} }%
    \mode<article>{ \includegraphics[width=.45\textwidth]{mos-figs-2-18} }
  \end{center}
\end{frame}

\begin{frame}{Mutual Exclusion}
  \begin{description}
  \item[Critical Region] is a piece of code accessing a common resource.
  \end{description}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{mos-figs-2-19} }%
    \mode<article>{ \includegraphics[width=.7\textwidth]{mos-figs-2-19} }
  \end{center}
\end{frame}

\begin{frame}
  \begin{block}{A solution to the critical region problem must satisfy three conditions}
    \begin{description}
    \item[Mutual Exclusion:] No two processes may be simultaneously inside their critical
      regions.
    \item[Progress:] No process running outside its critical region may block other
      processes.
    \item[Bounded Waiting:] No process should have to wait forever to enter its critical
      region.
    \end{description}
  \end{block}
\end{frame}

\begin{frame}{Mutual Exclusion With Busy Waiting}{Strict Alternation}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{strict-alternation} }%
    \mode<article>{ \includegraphics[width=.5\textwidth]{strict-alternation-bw} }
  \end{center}
  \begin{itemize}
  \item[\Bad] One process can be blocked by another not in its critical region
  \end{itemize}
\end{frame}

\begin{frame}{Mutual Exclusion With Busy Waiting}{Peterson's Solution}
  \begin{center}
    \mode<beamer>{ \includegraphics[width=\textwidth]{peterson} }%
    \mode<article>{ \includegraphics[width=.6\textwidth]{peterson-bw} }
  \end{center}
  \begin{refsection}
    \nocite{wiki:peterson}
    \printbibliography[heading=none]
  \end{refsection}
\end{frame}

\begin{frame}{Mutual Exclusion With Busy Waiting}{Lock file}
  \mode<beamer>{ \includegraphics[clip,trim={0 0 0 6.5em},width=\textwidth]{lock2-c} }%
  \mode<article>{ \includegraphics[width=.8\textwidth]{lock2-c-bw} }
  \begin{itemize}
  \item[\Bad] Lock file could be left in system after \Cc
  \end{itemize}
\end{frame}

\begin{frame}{\wrong}
  \mode<beamer>{ \includegraphics[clip,trim={0 0 0 9.5em},width=\textwidth]{lock2-sigint-c} }%
  \mode<article>{ \includegraphics[width=\textwidth]{lock2-sigint-c-bw} }
\end{frame}

\begin{frame}{What is a Semaphore?\,\includegraphics[width=1em]{semaphore-papa}}
  \begin{center}
    \begin{minipage}{.4\linewidth}
      \begin{itemize}
      \item A locking mechanism
      \item An integer or ADT
      \end{itemize}
    \end{minipage}\quad
    \begin{minipage}{.45\linewidth}
      \mode<beamer>{ \includegraphics[width=\textwidth]{down-up} }%
      \mode<article>{ \includegraphics[width=\textwidth]{down-up-bw} }
    \end{minipage}
  \end{center}
  \begin{center}\ttfamily\small
    \begin{tabular}{ll}\hline
      \multicolumn2{c}{\emph{Atomic} Operations}\\\hline
      P()         &V()\\
      Wait()      &Signal()\\
      Down()      &Up()\\
      Decrement() &Increment()\\
      ...         &...\\\hline
    \end{tabular}
  \end{center}
  More meaningful names:
  \begin{itemize}
  \item \texttt{increment\_and\_wake\_a\_waiting\_process\_if\_any()}
  \item \texttt{decrement\_and\_block\_if\_the\_result\_is\_negative()}
  \end{itemize}
\end{frame}


\lecture{User Interface}{ui}
\section{User Interface}
\label{sec:ui}

\subsection{Dialog, Zenity}
\label{sec:dialog}

\subsection{Ncurses}
\label{sec:curses}

\subsection{GTK+}
\label{sec:gtk+}

\subsection{Qt}
\label{sec:qt}

\section{Terminal}
\label{sec:terminal}

\begin{itemize}
\item chap 62 of \citetitle{Kerrisk:2010:LPI:1869911}
\item \url|http://tldp.org/HOWTO/Text-Terminal-HOWTO-16.html|
\item \url{http://pubs.opengroup.org/onlinepubs/9699919799/}
\item[\$] \cmd{man infocmp}
\end{itemize}


\lecture{IDE}{ide}
\section{IDE}
\label{sec:ide}
Makefile, git

\end{document}
%%% Local Variables:
%%% reftex-default-bibliography: "ref.bib"
%%% mode: latex
%%% TeX-master: "lap-b"
%%% End:
